var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// dist/web-ifc.js
var require_web_ifc = __commonJS((exports2, module2) => {
  var WebIFCWasm2 = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(WebIFCWasm3) {
      WebIFCWasm3 = WebIFCWasm3 || {};
      var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise(function(resolve, reject) {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      var moduleOverrides = {};
      var key;
      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = function(status, toThrow) {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = false;
      var ENVIRONMENT_IS_WORKER = false;
      var ENVIRONMENT_IS_NODE = false;
      var ENVIRONMENT_IS_SHELL = false;
      ENVIRONMENT_IS_WEB = typeof window === "object";
      ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
      ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      var nodeFS;
      var nodePath;
      if (ENVIRONMENT_IS_NODE) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = require("path").dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = __dirname + "/";
        }
        read_ = function shell_read(filename, binary) {
          if (!nodeFS)
            nodeFS = require("fs");
          if (!nodePath)
            nodePath = require("path");
          filename = nodePath["normalize"](filename);
          return nodeFS["readFileSync"](filename, binary ? null : "utf8");
        };
        readBinary = function readBinary2(filename) {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        if (process["argv"].length > 1) {
          thisProgram = process["argv"][1].replace(/\\/g, "/");
        }
        arguments_ = process["argv"].slice(2);
        process["on"]("uncaughtException", function(ex) {
          if (!(ex instanceof ExitStatus)) {
            throw ex;
          }
        });
        process["on"]("unhandledRejection", abort);
        quit_ = function(status) {
          process["exit"](status);
        };
        Module["inspect"] = function() {
          return "[Emscripten Module object]";
        };
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof read != "undefined") {
          read_ = function shell_read(f) {
            return read(f);
          };
        }
        readBinary = function readBinary2(f) {
          var data;
          if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f));
          }
          data = read(f, "binary");
          assert(typeof data === "object");
          return data;
        };
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit === "function") {
          quit_ = function(status) {
            quit(status);
          };
        }
        if (typeof print !== "undefined") {
          if (typeof console === "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document !== "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        {
          read_ = function shell_read(url) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = function readBinary2(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = function readAsync2(url, onload, onerror) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function xhr_onload() {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = function(title) {
          document.title = title;
        };
      } else {
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = null;
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      if (Module["quit"])
        quit_ = Module["quit"];
      var STACK_ALIGN = 16;
      function alignMemory(size, factor) {
        if (!factor)
          factor = STACK_ALIGN;
        return Math.ceil(size / factor) * factor;
      }
      var tempRet0 = 0;
      var setTempRet0 = function(value) {
        tempRet0 = value;
      };
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      var noExitRuntime;
      if (Module["noExitRuntime"])
        noExitRuntime = Module["noExitRuntime"];
      if (typeof WebAssembly !== "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS = 0;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heap, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heap[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(heap.subarray(idx, endPtr));
        } else {
          var str = "";
          while (idx < endPtr) {
            var u0 = heap[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heap[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heap[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++] = 192 | u >> 6;
            heap[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++] = 224 | u >> 12;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            heap[outIdx++] = 240 | u >> 18;
            heap[outIdx++] = 128 | u >> 12 & 63;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343)
            u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
          if (u <= 127)
            ++len;
          else if (u <= 2047)
            len += 2;
          else if (u <= 65535)
            len += 3;
          else
            len += 4;
        }
        return len;
      }
      var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function UTF16ToString(ptr, maxBytesToRead) {
        var endPtr = ptr;
        var idx = endPtr >> 1;
        var maxIdx = idx + maxBytesToRead / 2;
        while (!(idx >= maxIdx) && HEAPU16[idx])
          ++idx;
        endPtr = idx << 1;
        if (endPtr - ptr > 32 && UTF16Decoder) {
          return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
        } else {
          var str = "";
          for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
            var codeUnit = HEAP16[ptr + i * 2 >> 1];
            if (codeUnit == 0)
              break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        }
      }
      function stringToUTF16(str, outPtr, maxBytesToWrite) {
        if (maxBytesToWrite === void 0) {
          maxBytesToWrite = 2147483647;
        }
        if (maxBytesToWrite < 2)
          return 0;
        maxBytesToWrite -= 2;
        var startPtr = outPtr;
        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
        for (var i = 0; i < numCharsToWrite; ++i) {
          var codeUnit = str.charCodeAt(i);
          HEAP16[outPtr >> 1] = codeUnit;
          outPtr += 2;
        }
        HEAP16[outPtr >> 1] = 0;
        return outPtr - startPtr;
      }
      function lengthBytesUTF16(str) {
        return str.length * 2;
      }
      function UTF32ToString(ptr, maxBytesToRead) {
        var i = 0;
        var str = "";
        while (!(i >= maxBytesToRead / 4)) {
          var utf32 = HEAP32[ptr + i * 4 >> 2];
          if (utf32 == 0)
            break;
          ++i;
          if (utf32 >= 65536) {
            var ch = utf32 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          } else {
            str += String.fromCharCode(utf32);
          }
        }
        return str;
      }
      function stringToUTF32(str, outPtr, maxBytesToWrite) {
        if (maxBytesToWrite === void 0) {
          maxBytesToWrite = 2147483647;
        }
        if (maxBytesToWrite < 4)
          return 0;
        var startPtr = outPtr;
        var endPtr = startPtr + maxBytesToWrite - 4;
        for (var i = 0; i < str.length; ++i) {
          var codeUnit = str.charCodeAt(i);
          if (codeUnit >= 55296 && codeUnit <= 57343) {
            var trailSurrogate = str.charCodeAt(++i);
            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
          }
          HEAP32[outPtr >> 2] = codeUnit;
          outPtr += 4;
          if (outPtr + 4 > endPtr)
            break;
        }
        HEAP32[outPtr >> 2] = 0;
        return outPtr - startPtr;
      }
      function lengthBytesUTF32(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var codeUnit = str.charCodeAt(i);
          if (codeUnit >= 55296 && codeUnit <= 57343)
            ++i;
          len += 4;
        }
        return len;
      }
      function writeArrayToMemory(array, buffer2) {
        HEAP8.set(array, buffer2);
      }
      function writeAsciiToMemory(str, buffer2, dontAddNull) {
        for (var i = 0; i < str.length; ++i) {
          HEAP8[buffer2++ >> 0] = str.charCodeAt(i);
        }
        if (!dontAddNull)
          HEAP8[buffer2 >> 0] = 0;
      }
      function alignUp(x, multiple) {
        if (x % multiple > 0) {
          x += multiple - x % multiple;
        }
        return x;
      }
      var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
      if (Module["wasmMemory"]) {
        wasmMemory = Module["wasmMemory"];
      } else {
        wasmMemory = new WebAssembly.Memory({initial: INITIAL_MEMORY / 65536, maximum: 2147483648 / 65536});
      }
      if (wasmMemory) {
        buffer = wasmMemory.buffer;
      }
      INITIAL_MEMORY = buffer.byteLength;
      updateGlobalBufferAndViews(buffer);
      var wasmTable;
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeExited = false;
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        runtimeInitialized = true;
        if (!Module["noFSInit"] && !FS.init.initialized)
          FS.init();
        TTY.init();
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        FS.ignorePermissions = false;
        callRuntimeCallbacks(__ATMAIN__);
      }
      function exitRuntime() {
        runtimeExited = true;
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function getUniqueRunDependency(id) {
        return id;
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what += "";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      function hasPrefix(str, prefix) {
        return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return hasPrefix(filename, dataURIPrefix);
      }
      var fileURIPrefix = "file://";
      function isFileURI(filename) {
        return hasPrefix(filename, fileURIPrefix);
      }
      var wasmBinaryFile = "web-ifc.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
      function getBinary() {
        try {
          if (wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(wasmBinaryFile);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise() {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
          return fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary();
          });
        }
        return Promise.resolve().then(getBinary);
      }
      function createWasm() {
        var info = {a: asmLibraryArg};
        function receiveInstance(instance, module3) {
          var exports4 = instance.exports;
          Module["asm"] = exports4;
          wasmTable = Module["asm"]["W"];
          removeRunDependency("wasm-instantiate");
        }
        addRunDependency("wasm-instantiate");
        function receiveInstantiatedSource(output) {
          receiveInstance(output["instance"]);
        }
        function instantiateArrayBuffer(receiver) {
          return getBinaryPromise().then(function(binary) {
            return WebAssembly.instantiate(binary, info);
          }).then(receiver, function(reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
        }
        function instantiateAsync() {
          if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
            return fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiatedSource, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(receiveInstantiatedSource);
              });
            });
          } else {
            return instantiateArrayBuffer(receiveInstantiatedSource);
          }
        }
        if (Module["instantiateWasm"]) {
          try {
            var exports3 = Module["instantiateWasm"](info, receiveInstance);
            return exports3;
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            return false;
          }
        }
        instantiateAsync().catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback(Module);
            continue;
          }
          var func = callback.func;
          if (typeof func === "number") {
            if (callback.arg === void 0) {
              wasmTable.get(func)();
            } else {
              wasmTable.get(func)(callback.arg);
            }
          } else {
            func(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      function dynCallLegacy(sig, ptr, args) {
        if (args && args.length) {
          return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
        }
        return Module["dynCall_" + sig].call(null, ptr);
      }
      function dynCall(sig, ptr, args) {
        if (sig.indexOf("j") != -1) {
          return dynCallLegacy(sig, ptr, args);
        }
        return wasmTable.get(ptr).apply(null, args);
      }
      function ___assert_fail(condition, filename, line, func) {
        abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      function setErrNo(value) {
        HEAP32[___errno_location() >> 2] = value;
        return value;
      }
      var PATH = {splitPath: function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      }, normalizeArray: function(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      }, normalize: function(path) {
        var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter(function(p) {
          return !!p;
        }), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      }, dirname: function(path) {
        var result = PATH.splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      }, basename: function(path) {
        if (path === "/")
          return "/";
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1)
          return path;
        return path.substr(lastSlash + 1);
      }, extname: function(path) {
        return PATH.splitPath(path)[3];
      }, join: function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      }, join2: function(l, r) {
        return PATH.normalize(l + "/" + r);
      }};
      function getRandomDevice() {
        if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
          var randomBuffer = new Uint8Array(1);
          return function() {
            crypto.getRandomValues(randomBuffer);
            return randomBuffer[0];
          };
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require("crypto");
            return function() {
              return crypto_module["randomBytes"](1)[0];
            };
          } catch (e) {
          }
        }
        return function() {
          abort("randomDevice");
        };
      }
      var PATH_FS = {resolve: function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();
          if (typeof path !== "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            return "";
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charAt(0) === "/";
        }
        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      }, relative: function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }};
      var TTY = {ttys: [], init: function() {
      }, shutdown: function() {
      }, register: function(dev, ops) {
        TTY.ttys[dev] = {input: [], output: [], ops};
        FS.registerDevice(dev, TTY.stream_ops);
      }, stream_ops: {open: function(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      }, close: function(stream) {
        stream.tty.ops.flush(stream.tty);
      }, flush: function(stream) {
        stream.tty.ops.flush(stream.tty);
      }, read: function(stream, buffer2, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer2[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      }, write: function(stream, buffer2, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }}, default_tty_ops: {get_char: function(tty) {
        if (!tty.input.length) {
          var result = null;
          if (ENVIRONMENT_IS_NODE) {
            var BUFSIZE = 256;
            var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
            var bytesRead = 0;
            try {
              bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
            } catch (e) {
              if (e.toString().indexOf("EOF") != -1)
                bytesRead = 0;
              else
                throw e;
            }
            if (bytesRead > 0) {
              result = buf.slice(0, bytesRead).toString("utf-8");
            } else {
              result = null;
            }
          } else if (typeof window != "undefined" && typeof window.prompt == "function") {
            result = window.prompt("Input: ");
            if (result !== null) {
              result += "\n";
            }
          } else if (typeof readline == "function") {
            result = readline();
            if (result !== null) {
              result += "\n";
            }
          }
          if (!result) {
            return null;
          }
          tty.input = intArrayFromString(result, true);
        }
        return tty.input.shift();
      }, put_char: function(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      }, flush: function(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }}, default_tty1_ops: {put_char: function(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      }, flush: function(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }}};
      function mmapAlloc(size) {
        var alignedSize = alignMemory(size, 16384);
        var ptr = _malloc(alignedSize);
        while (size < alignedSize)
          HEAP8[ptr + size++] = 0;
        return ptr;
      }
      var MEMFS = {ops_table: null, mount: function(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      }, createNode: function(parent, name2, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {dir: {node: {getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink}, stream: {llseek: MEMFS.stream_ops.llseek}}, file: {node: {getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr}, stream: {llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync}}, link: {node: {getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink}, stream: {}}, chrdev: {node: {getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr}, stream: FS.chrdev_stream_ops}};
        }
        var node = FS.createNode(parent, name2, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name2] = node;
        }
        return node;
      }, getFileDataAsRegularArray: function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i)
            arr.push(node.contents[i]);
          return arr;
        }
        return node.contents;
      }, getFileDataAsTypedArray: function(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      }, expandFileStorage: function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        return;
      }, resizeFileStorage: function(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }
          node.usedBytes = newSize;
          return;
        }
        if (!node.contents)
          node.contents = [];
        if (node.contents.length > newSize)
          node.contents.length = newSize;
        else
          while (node.contents.length < newSize)
            node.contents.push(0);
        node.usedBytes = newSize;
      }, node_ops: {getattr: function(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      }, setattr: function(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      }, lookup: function(parent, name2) {
        throw FS.genericErrors[44];
      }, mknod: function(parent, name2, mode, dev) {
        return MEMFS.createNode(parent, name2, mode, dev);
      }, rename: function(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        old_node.parent = new_dir;
      }, unlink: function(parent, name2) {
        delete parent.contents[name2];
      }, rmdir: function(parent, name2) {
        var node = FS.lookupNode(parent, name2);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name2];
      }, readdir: function(node) {
        var entries = [".", ".."];
        for (var key2 in node.contents) {
          if (!node.contents.hasOwnProperty(key2)) {
            continue;
          }
          entries.push(key2);
        }
        return entries;
      }, symlink: function(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      }, readlink: function(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }}, stream_ops: {read: function(stream, buffer2, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer2.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer2[offset + i] = contents[position + i];
        }
        return size;
      }, write: function(stream, buffer2, offset, length, position, canOwn) {
        if (buffer2.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer2.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer2.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer2.subarray) {
          node.contents.set(buffer2.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer2[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      }, llseek: function(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      }, allocate: function(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      }, mmap: function(stream, address, length, position, prot, flags) {
        assert(address === 0);
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {ptr, allocated};
      }, msync: function(stream, buffer2, offset, length, mmapFlags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (mmapFlags & 2) {
          return 0;
        }
        var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
        return 0;
      }}};
      var FS = {root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: {openFlags: {READ: 1, WRITE: 2}}, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
        if (!path)
          return {path: "", node: null};
        var defaults = {follow_mount: true, recurse_count: 0};
        for (var key2 in defaults) {
          if (opts[key2] === void 0) {
            opts[key2] = defaults[key2];
          }
        }
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
          return !!p;
        }), false);
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {recurse_count: opts.recurse_count});
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return {path: current_path, node: current};
      }, getPath: function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path)
              return mount;
            return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
          }
          path = path ? node.name + "/" + path : node.name;
          node = node.parent;
        }
      }, hashName: function(parentid, name2) {
        var hash = 0;
        for (var i = 0; i < name2.length; i++) {
          hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      }, hashAddNode: function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      }, hashRemoveNode: function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      }, lookupNode: function(parent, name2) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name2);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name2) {
            return node;
          }
        }
        return FS.lookup(parent, name2);
      }, createNode: function(parent, name2, mode, rdev) {
        var node = new FS.FSNode(parent, name2, mode, rdev);
        FS.hashAddNode(node);
        return node;
      }, destroyNode: function(node) {
        FS.hashRemoveNode(node);
      }, isRoot: function(node) {
        return node === node.parent;
      }, isMountpoint: function(node) {
        return !!node.mounted;
      }, isFile: function(mode) {
        return (mode & 61440) === 32768;
      }, isDir: function(mode) {
        return (mode & 61440) === 16384;
      }, isLink: function(mode) {
        return (mode & 61440) === 40960;
      }, isChrdev: function(mode) {
        return (mode & 61440) === 8192;
      }, isBlkdev: function(mode) {
        return (mode & 61440) === 24576;
      }, isFIFO: function(mode) {
        return (mode & 61440) === 4096;
      }, isSocket: function(mode) {
        return (mode & 49152) === 49152;
      }, flagModes: {r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090}, modeStringToFlags: function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }
        return flags;
      }, flagsToPermissionString: function(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      }, nodePermissions: function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      }, mayLookup: function(dir) {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      }, mayCreate: function(dir, name2) {
        try {
          var node = FS.lookupNode(dir, name2);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, "wx");
      }, mayDelete: function(dir, name2, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name2);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      }, mayOpen: function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      }, getStream: function(fd) {
        return FS.streams[fd];
      }, createStream: function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function() {
          };
          FS.FSStream.prototype = {object: {get: function() {
            return this.node;
          }, set: function(val) {
            this.node = val;
          }}, isRead: {get: function() {
            return (this.flags & 2097155) !== 1;
          }}, isWrite: {get: function() {
            return (this.flags & 2097155) !== 0;
          }}, isAppend: {get: function() {
            return this.flags & 1024;
          }}};
        }
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      }, closeStream: function(fd) {
        FS.streams[fd] = null;
      }, chrdev_stream_ops: {open: function(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
      }, llseek: function() {
        throw new FS.ErrnoError(70);
      }}, major: function(dev) {
        return dev >> 8;
      }, minor: function(dev) {
        return dev & 255;
      }, makedev: function(ma, mi) {
        return ma << 8 | mi;
      }, registerDevice: function(dev, ops) {
        FS.devices[dev] = {stream_ops: ops};
      }, getDevice: function(dev) {
        return FS.devices[dev];
      }, getMounts: function(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push.apply(check, m.mounts);
        }
        return mounts;
      }, syncfs: function(populate, callback) {
        if (typeof populate === "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach(function(mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      }, mount: function(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, {follow_mount: false});
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {type, opts, mountpoint, mounts: []};
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      }, unmount: function(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, {follow_mount: false});
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach(function(hash) {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      }, lookup: function(parent, name2) {
        return parent.node_ops.lookup(parent, name2);
      }, mknod: function(path, mode, dev) {
        var lookup = FS.lookupPath(path, {parent: true});
        var parent = lookup.node;
        var name2 = PATH.basename(path);
        if (!name2 || name2 === "." || name2 === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name2);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name2, mode, dev);
      }, create: function(path, mode) {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      }, mkdir: function(path, mode) {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      }, mkdirTree: function(path, mode) {
        var dirs = path.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i])
            continue;
          d += "/" + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20)
              throw e;
          }
        }
      }, mkdev: function(path, mode, dev) {
        if (typeof dev === "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      }, symlink: function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, {parent: true});
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      }, rename: function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, {parent: true});
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, {parent: true});
        new_dir = lookup.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate["willMovePath"]) {
            FS.trackingDelegate["willMovePath"](old_path, new_path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate["onMovePath"])
            FS.trackingDelegate["onMovePath"](old_path, new_path);
        } catch (e) {
          err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }
      }, rmdir: function(path) {
        var lookup = FS.lookupPath(path, {parent: true});
        var parent = lookup.node;
        var name2 = PATH.basename(path);
        var node = FS.lookupNode(parent, name2);
        var errCode = FS.mayDelete(parent, name2, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name2);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate["onDeletePath"])
            FS.trackingDelegate["onDeletePath"](path);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      }, readdir: function(path) {
        var lookup = FS.lookupPath(path, {follow: true});
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      }, unlink: function(path) {
        var lookup = FS.lookupPath(path, {parent: true});
        var parent = lookup.node;
        var name2 = PATH.basename(path);
        var node = FS.lookupNode(parent, name2);
        var errCode = FS.mayDelete(parent, name2, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name2);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate["onDeletePath"])
            FS.trackingDelegate["onDeletePath"](path);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      }, readlink: function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      }, stat: function(path, dontFollow) {
        var lookup = FS.lookupPath(path, {follow: !dontFollow});
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      }, lstat: function(path) {
        return FS.stat(path, true);
      }, chmod: function(path, mode, dontFollow) {
        var node;
        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {follow: !dontFollow});
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now()});
      }, lchmod: function(path, mode) {
        FS.chmod(path, mode, true);
      }, fchmod: function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      }, chown: function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {follow: !dontFollow});
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {timestamp: Date.now()});
      }, lchown: function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      }, fchown: function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      }, truncate: function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === "string") {
          var lookup = FS.lookupPath(path, {follow: true});
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {size: len, timestamp: Date.now()});
      }, ftruncate: function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      }, utime: function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, {follow: true});
        var node = lookup.node;
        node.node_ops.setattr(node, {timestamp: Math.max(atime, mtime)});
      }, open: function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === "undefined" ? 438 : mode;
        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === "object") {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {follow: !(flags & 131072)});
            node = lookup.node;
          } catch (e) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false}, fd_start, fd_end);
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles)
            FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate["onOpenFile"]) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate["onOpenFile"](path, trackingFlags);
          }
        } catch (e) {
          err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
        }
        return stream;
      }, close: function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents)
          stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      }, isClosed: function(stream) {
        return stream.fd === null;
      }, llseek: function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      }, read: function(stream, buffer2, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      }, write: function(stream, buffer2, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
        if (!seeking)
          stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate["onWriteToFile"])
            FS.trackingDelegate["onWriteToFile"](stream.path);
        } catch (e) {
          err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
        }
        return bytesWritten;
      }, allocate: function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      }, mmap: function(stream, address, length, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      }, msync: function(stream, buffer2, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
      }, munmap: function(stream) {
        return 0;
      }, ioctl: function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      }, readFile: function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      }, writeFile: function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      }, cwd: function() {
        return FS.currentPath;
      }, chdir: function(path) {
        var lookup = FS.lookupPath(path, {follow: true});
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      }, createDefaultDirectories: function() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      }, createDefaultDevices: function() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {read: function() {
          return 0;
        }, write: function(stream, buffer2, offset, length, pos) {
          return length;
        }});
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device = getRandomDevice();
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      }, createSpecialDirectories: function() {
        FS.mkdir("/proc");
        FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({mount: function() {
          var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
          node.node_ops = {lookup: function(parent, name2) {
            var fd = +name2;
            var stream = FS.getStream(fd);
            if (!stream)
              throw new FS.ErrnoError(8);
            var ret = {parent: null, mount: {mountpoint: "fake"}, node_ops: {readlink: function() {
              return stream.path;
            }}};
            ret.parent = ret;
            return ret;
          }};
          return node;
        }}, {}, "/proc/self/fd");
      }, createStandardStreams: function() {
        if (Module["stdin"]) {
          FS.createDevice("/dev", "stdin", Module["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (Module["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (Module["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", 0);
        var stdout = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      }, ensureErrnoError: function() {
        if (FS.ErrnoError)
          return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno2) {
            this.errno = errno2;
          };
          this.setErrno(errno);
          this.message = "FS error";
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      }, staticInit: function() {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {MEMFS};
      }, init: function(input, output, error) {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module["stdin"] = input || Module["stdin"];
        Module["stdout"] = output || Module["stdout"];
        Module["stderr"] = error || Module["stderr"];
        FS.createStandardStreams();
      }, quit: function() {
        FS.init.initialized = false;
        var fflush = Module["_fflush"];
        if (fflush)
          fflush(0);
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      }, getMode: function(canRead, canWrite) {
        var mode = 0;
        if (canRead)
          mode |= 292 | 73;
        if (canWrite)
          mode |= 146;
        return mode;
      }, findObject: function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      }, analyzePath: function(path, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path, {follow: !dontResolveLastLink});
          path = lookup.path;
        } catch (e) {
        }
        var ret = {isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null};
        try {
          var lookup = FS.lookupPath(path, {parent: true});
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, {follow: !dontResolveLastLink});
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      }, createPath: function(parent, path, canRead, canWrite) {
        parent = typeof parent === "string" ? parent : FS.getPath(parent);
        var parts = path.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
          }
          parent = current;
        }
        return current;
      }, createFile: function(parent, name2, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
        var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === "string") {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      }, createDevice: function(parent, name2, input, output) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major)
          FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {open: function(stream) {
          stream.seekable = false;
        }, close: function(stream) {
          if (output && output.buffer && output.buffer.length) {
            output(10);
          }
        }, read: function(stream, buffer2, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer2[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }});
        return FS.mkdev(path, mode, dev);
      }, forceLoadFile: function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest !== "undefined") {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }
      }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = function(from, to) {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            if (typeof Uint8Array != "undefined")
              xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(xhr2.response || []);
            } else {
              return intArrayFromString(xhr2.responseText || "", true);
            }
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] === "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {length: {get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }}, chunkSize: {get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }}});
          var properties = {isDevice: false, contents: lazyArray};
        } else {
          var properties = {isDevice: false, url};
        }
        var node = FS.createFile(parent, name2, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {usedBytes: {get: function() {
          return this.contents.length;
        }}});
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key2) {
          var fn = node.stream_ops[key2];
          stream_ops[key2] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer2[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer2[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init();
        var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);
        function processData(byteArray) {
          function finish(byteArray2) {
            if (preFinish)
              preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
            }
            if (onload)
              onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module["preloadPlugins"].forEach(function(plugin) {
            if (handled)
              return;
            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, function() {
                if (onerror)
                  onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled)
            finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == "string") {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      }, indexedDB: function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      }, DB_NAME: function() {
        return "EM_FS_" + window.location.pathname;
      }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
        onload = onload || function() {
        };
        onerror = onerror || function() {
        };
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() {
              ok++;
              if (ok + fail == total)
                finish();
            };
            putRequest.onerror = function putRequest_onerror() {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }, loadFilesFromDB: function(paths, onload, onerror) {
        onload = onload || function() {
        };
        onerror = onerror || function() {
        };
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total)
                finish();
            };
            getRequest.onerror = function getRequest_onerror() {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
      var SYSCALLS = {mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path) {
        if (path[0] !== "/") {
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      }, doStat: function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            return -54;
          }
          throw e;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = 0;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAP32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        HEAP32[buf + 32 >> 2] = 0;
        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAP32[buf + 48 >> 2] = 4096;
        HEAP32[buf + 52 >> 2] = stat.blocks;
        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
        HEAP32[buf + 60 >> 2] = 0;
        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
        HEAP32[buf + 68 >> 2] = 0;
        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
        HEAP32[buf + 76 >> 2] = 0;
        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
        return 0;
      }, doMsync: function(addr, stream, len, flags, offset) {
        var buffer2 = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer2, offset, len, flags);
      }, doMkdir: function(path, mode) {
        path = PATH.normalize(path);
        if (path[path.length - 1] === "/")
          path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      }, doMknod: function(path, mode, dev) {
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default:
            return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      }, doReadlink: function(path, buf, bufsize) {
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      }, doAccess: function(path, amode) {
        if (amode & ~7) {
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, {follow: true});
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      }, doDup: function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest)
          FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      }, doReadv: function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.read(stream, HEAP8, ptr, len, offset);
          if (curr < 0)
            return -1;
          ret += curr;
          if (curr < len)
            break;
        }
        return ret;
      }, doWritev: function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.write(stream, HEAP8, ptr, len, offset);
          if (curr < 0)
            return -1;
          ret += curr;
        }
        return ret;
      }, varargs: void 0, get: function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      }, getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }, getStreamFromFD: function(fd) {
        var stream = FS.getStream(fd);
        if (!stream)
          throw new FS.ErrnoError(8);
        return stream;
      }, get64: function(low, high) {
        return low;
      }};
      function ___sys_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          switch (cmd) {
            case 0: {
              var arg = SYSCALLS.get();
              if (arg < 0) {
                return -28;
              }
              var newStream;
              newStream = FS.open(stream.path, stream.flags, 0, arg);
              return newStream.fd;
            }
            case 1:
            case 2:
              return 0;
            case 3:
              return stream.flags;
            case 4: {
              var arg = SYSCALLS.get();
              stream.flags |= arg;
              return 0;
            }
            case 12: {
              var arg = SYSCALLS.get();
              var offset = 0;
              HEAP16[arg + offset >> 1] = 2;
              return 0;
            }
            case 13:
            case 14:
              return 0;
            case 16:
            case 8:
              return -28;
            case 9:
              setErrNo(28);
              return -1;
            default: {
              return -28;
            }
          }
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return -e.errno;
        }
      }
      function ___sys_ioctl(fd, op, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          switch (op) {
            case 21509:
            case 21505: {
              if (!stream.tty)
                return -59;
              return 0;
            }
            case 21510:
            case 21511:
            case 21512:
            case 21506:
            case 21507:
            case 21508: {
              if (!stream.tty)
                return -59;
              return 0;
            }
            case 21519: {
              if (!stream.tty)
                return -59;
              var argp = SYSCALLS.get();
              HEAP32[argp >> 2] = 0;
              return 0;
            }
            case 21520: {
              if (!stream.tty)
                return -59;
              return -28;
            }
            case 21531: {
              var argp = SYSCALLS.get();
              return FS.ioctl(stream, op, argp);
            }
            case 21523: {
              if (!stream.tty)
                return -59;
              return 0;
            }
            case 21524: {
              if (!stream.tty)
                return -59;
              return 0;
            }
            default:
              abort("bad ioctl syscall " + op);
          }
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return -e.errno;
        }
      }
      function ___sys_open(path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var pathname = SYSCALLS.getStr(path);
          var mode = SYSCALLS.get();
          var stream = FS.open(pathname, flags, mode);
          return stream.fd;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return -e.errno;
        }
      }
      var tupleRegistrations = {};
      function runDestructors(destructors) {
        while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
        }
      }
      function simpleReadValueFromPointer(pointer) {
        return this["fromWireType"](HEAPU32[pointer >> 2]);
      }
      var awaitingDependencies = {};
      var registeredTypes = {};
      var typeDependencies = {};
      var char_0 = 48;
      var char_9 = 57;
      function makeLegalFunctionName(name2) {
        if (name2 === void 0) {
          return "_unknown";
        }
        name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
        var f = name2.charCodeAt(0);
        if (f >= char_0 && f <= char_9) {
          return "_" + name2;
        } else {
          return name2;
        }
      }
      function createNamedFunction(name2, body) {
        name2 = makeLegalFunctionName(name2);
        return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
      }
      function extendError(baseErrorType, errorName) {
        var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
          var stack = new Error(message).stack;
          if (stack !== void 0) {
            this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
          }
        });
        errorClass.prototype = Object.create(baseErrorType.prototype);
        errorClass.prototype.constructor = errorClass;
        errorClass.prototype.toString = function() {
          if (this.message === void 0) {
            return this.name;
          } else {
            return this.name + ": " + this.message;
          }
        };
        return errorClass;
      }
      var InternalError = void 0;
      function throwInternalError(message) {
        throw new InternalError(message);
      }
      function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
        myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
        });
        function onComplete(typeConverters2) {
          var myTypeConverters = getTypeConverters(typeConverters2);
          if (myTypeConverters.length !== myTypes.length) {
            throwInternalError("Mismatched type converter count");
          }
          for (var i = 0; i < myTypes.length; ++i) {
            registerType(myTypes[i], myTypeConverters[i]);
          }
        }
        var typeConverters = new Array(dependentTypes.length);
        var unregisteredTypes = [];
        var registered = 0;
        dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
            typeConverters[i] = registeredTypes[dt];
          } else {
            unregisteredTypes.push(dt);
            if (!awaitingDependencies.hasOwnProperty(dt)) {
              awaitingDependencies[dt] = [];
            }
            awaitingDependencies[dt].push(function() {
              typeConverters[i] = registeredTypes[dt];
              ++registered;
              if (registered === unregisteredTypes.length) {
                onComplete(typeConverters);
              }
            });
          }
        });
        if (unregisteredTypes.length === 0) {
          onComplete(typeConverters);
        }
      }
      function __embind_finalize_value_array(rawTupleType) {
        var reg = tupleRegistrations[rawTupleType];
        delete tupleRegistrations[rawTupleType];
        var elements = reg.elements;
        var elementsLength = elements.length;
        var elementTypes = elements.map(function(elt) {
          return elt.getterReturnType;
        }).concat(elements.map(function(elt) {
          return elt.setterArgumentType;
        }));
        var rawConstructor = reg.rawConstructor;
        var rawDestructor = reg.rawDestructor;
        whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
          elements.forEach(function(elt, i) {
            var getterReturnType = elementTypes2[i];
            var getter = elt.getter;
            var getterContext = elt.getterContext;
            var setterArgumentType = elementTypes2[i + elementsLength];
            var setter = elt.setter;
            var setterContext = elt.setterContext;
            elt.read = function(ptr) {
              return getterReturnType["fromWireType"](getter(getterContext, ptr));
            };
            elt.write = function(ptr, o) {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
              runDestructors(destructors);
            };
          });
          return [{name: reg.name, fromWireType: function(ptr) {
            var rv = new Array(elementsLength);
            for (var i = 0; i < elementsLength; ++i) {
              rv[i] = elements[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          }, toWireType: function(destructors, o) {
            if (elementsLength !== o.length) {
              throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
            }
            var ptr = rawConstructor();
            for (var i = 0; i < elementsLength; ++i) {
              elements[i].write(ptr, o[i]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: rawDestructor}];
        });
      }
      var structRegistrations = {};
      function __embind_finalize_value_object(structType) {
        var reg = structRegistrations[structType];
        delete structRegistrations[structType];
        var rawConstructor = reg.rawConstructor;
        var rawDestructor = reg.rawDestructor;
        var fieldRecords = reg.fields;
        var fieldTypes = fieldRecords.map(function(field) {
          return field.getterReturnType;
        }).concat(fieldRecords.map(function(field) {
          return field.setterArgumentType;
        }));
        whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
          var fields = {};
          fieldRecords.forEach(function(field, i) {
            var fieldName = field.fieldName;
            var getterReturnType = fieldTypes2[i];
            var getter = field.getter;
            var getterContext = field.getterContext;
            var setterArgumentType = fieldTypes2[i + fieldRecords.length];
            var setter = field.setter;
            var setterContext = field.setterContext;
            fields[fieldName] = {read: function(ptr) {
              return getterReturnType["fromWireType"](getter(getterContext, ptr));
            }, write: function(ptr, o) {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
              runDestructors(destructors);
            }};
          });
          return [{name: reg.name, fromWireType: function(ptr) {
            var rv = {};
            for (var i in fields) {
              rv[i] = fields[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          }, toWireType: function(destructors, o) {
            for (var fieldName in fields) {
              if (!(fieldName in o)) {
                throw new TypeError('Missing field:  "' + fieldName + '"');
              }
            }
            var ptr = rawConstructor();
            for (fieldName in fields) {
              fields[fieldName].write(ptr, o[fieldName]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: rawDestructor}];
        });
      }
      function getShiftFromSize(size) {
        switch (size) {
          case 1:
            return 0;
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
          default:
            throw new TypeError("Unknown type size: " + size);
        }
      }
      function embind_init_charCodes() {
        var codes = new Array(256);
        for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
        }
        embind_charCodes = codes;
      }
      var embind_charCodes = void 0;
      function readLatin1String(ptr) {
        var ret = "";
        var c = ptr;
        while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
        }
        return ret;
      }
      var BindingError = void 0;
      function throwBindingError(message) {
        throw new BindingError(message);
      }
      function registerType(rawType, registeredInstance, options) {
        options = options || {};
        if (!("argPackAdvance" in registeredInstance)) {
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        }
        var name2 = registeredInstance.name;
        if (!rawType) {
          throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
        }
        if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
            return;
          } else {
            throwBindingError("Cannot register type '" + name2 + "' twice");
          }
        }
        registeredTypes[rawType] = registeredInstance;
        delete typeDependencies[rawType];
        if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
            cb();
          });
        }
      }
      function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
        var shift = getShiftFromSize(size);
        name2 = readLatin1String(name2);
        registerType(rawType, {name: name2, fromWireType: function(wt) {
          return !!wt;
        }, toWireType: function(destructors, o) {
          return o ? trueValue : falseValue;
        }, argPackAdvance: 8, readValueFromPointer: function(pointer) {
          var heap;
          if (size === 1) {
            heap = HEAP8;
          } else if (size === 2) {
            heap = HEAP16;
          } else if (size === 4) {
            heap = HEAP32;
          } else {
            throw new TypeError("Unknown boolean type size: " + name2);
          }
          return this["fromWireType"](heap[pointer >> shift]);
        }, destructorFunction: null});
      }
      function ClassHandle_isAliasOf(other) {
        if (!(this instanceof ClassHandle)) {
          return false;
        }
        if (!(other instanceof ClassHandle)) {
          return false;
        }
        var leftClass = this.$$.ptrType.registeredClass;
        var left = this.$$.ptr;
        var rightClass = other.$$.ptrType.registeredClass;
        var right = other.$$.ptr;
        while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
        }
        while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
        }
        return leftClass === rightClass && left === right;
      }
      function shallowCopyInternalPointer(o) {
        return {count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType};
      }
      function throwInstanceAlreadyDeleted(obj) {
        function getInstanceTypeName(handle) {
          return handle.$$.ptrType.registeredClass.name;
        }
        throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
      }
      var finalizationGroup = false;
      function detachFinalizer(handle) {
      }
      function runDestructor($$) {
        if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
        } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
        }
      }
      function releaseClassHandle($$) {
        $$.count.value -= 1;
        var toDelete = $$.count.value === 0;
        if (toDelete) {
          runDestructor($$);
        }
      }
      function attachFinalizer(handle) {
        if (typeof FinalizationGroup === "undefined") {
          attachFinalizer = function(handle2) {
            return handle2;
          };
          return handle;
        }
        finalizationGroup = new FinalizationGroup(function(iter) {
          for (var result = iter.next(); !result.done; result = iter.next()) {
            var $$ = result.value;
            if (!$$.ptr) {
              console.warn("object already deleted: " + $$.ptr);
            } else {
              releaseClassHandle($$);
            }
          }
        });
        attachFinalizer = function(handle2) {
          finalizationGroup.register(handle2, handle2.$$, handle2.$$);
          return handle2;
        };
        detachFinalizer = function(handle2) {
          finalizationGroup.unregister(handle2.$$);
        };
        return attachFinalizer(handle);
      }
      function ClassHandle_clone() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
        } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {$$: {value: shallowCopyInternalPointer(this.$$)}}));
          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
        }
      }
      function ClassHandle_delete() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        detachFinalizer(this);
        releaseClassHandle(this.$$);
        if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = void 0;
          this.$$.ptr = void 0;
        }
      }
      function ClassHandle_isDeleted() {
        return !this.$$.ptr;
      }
      var delayFunction = void 0;
      var deletionQueue = [];
      function flushPendingDeletes() {
        while (deletionQueue.length) {
          var obj = deletionQueue.pop();
          obj.$$.deleteScheduled = false;
          obj["delete"]();
        }
      }
      function ClassHandle_deleteLater() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        deletionQueue.push(this);
        if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
        }
        this.$$.deleteScheduled = true;
        return this;
      }
      function init_ClassHandle() {
        ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
        ClassHandle.prototype["clone"] = ClassHandle_clone;
        ClassHandle.prototype["delete"] = ClassHandle_delete;
        ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
        ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
      }
      function ClassHandle() {
      }
      var registeredPointers = {};
      function ensureOverloadTable(proto, methodName, humanName) {
        if (proto[methodName].overloadTable === void 0) {
          var prevFunc = proto[methodName];
          proto[methodName] = function() {
            if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
              throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
            }
            return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
          };
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
        }
      }
      function exposePublicSymbol(name2, value, numArguments) {
        if (Module.hasOwnProperty(name2)) {
          if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
            throwBindingError("Cannot register public name '" + name2 + "' twice");
          }
          ensureOverloadTable(Module, name2, name2);
          if (Module.hasOwnProperty(numArguments)) {
            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
          }
          Module[name2].overloadTable[numArguments] = value;
        } else {
          Module[name2] = value;
          if (numArguments !== void 0) {
            Module[name2].numArguments = numArguments;
          }
        }
      }
      function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
        this.name = name2;
        this.constructor = constructor;
        this.instancePrototype = instancePrototype;
        this.rawDestructor = rawDestructor;
        this.baseClass = baseClass;
        this.getActualType = getActualType;
        this.upcast = upcast;
        this.downcast = downcast;
        this.pureVirtualFunctions = [];
      }
      function upcastPointer(ptr, ptrClass, desiredClass) {
        while (ptrClass !== desiredClass) {
          if (!ptrClass.upcast) {
            throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
          }
          ptr = ptrClass.upcast(ptr);
          ptrClass = ptrClass.baseClass;
        }
        return ptr;
      }
      function constNoSmartPtrRawPointerToWireType(destructors, handle) {
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          return 0;
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        return ptr;
      }
      function genericPointerToWireType(destructors, handle) {
        var ptr;
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          if (this.isSmartPointer) {
            ptr = this.rawConstructor();
            if (destructors !== null) {
              destructors.push(this.rawDestructor, ptr);
            }
            return ptr;
          } else {
            return 0;
          }
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        if (!this.isConst && handle.$$.ptrType.isConst) {
          throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        if (this.isSmartPointer) {
          if (handle.$$.smartPtr === void 0) {
            throwBindingError("Passing raw pointer to smart pointer is illegal");
          }
          switch (this.sharingPolicy) {
            case 0:
              if (handle.$$.smartPtrType === this) {
                ptr = handle.$$.smartPtr;
              } else {
                throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
              }
              break;
            case 1:
              ptr = handle.$$.smartPtr;
              break;
            case 2:
              if (handle.$$.smartPtrType === this) {
                ptr = handle.$$.smartPtr;
              } else {
                var clonedHandle = handle["clone"]();
                ptr = this.rawShare(ptr, __emval_register(function() {
                  clonedHandle["delete"]();
                }));
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
              }
              break;
            default:
              throwBindingError("Unsupporting sharing policy");
          }
        }
        return ptr;
      }
      function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          return 0;
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        if (handle.$$.ptrType.isConst) {
          throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        return ptr;
      }
      function RegisteredPointer_getPointee(ptr) {
        if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
        }
        return ptr;
      }
      function RegisteredPointer_destructor(ptr) {
        if (this.rawDestructor) {
          this.rawDestructor(ptr);
        }
      }
      function RegisteredPointer_deleteObject(handle) {
        if (handle !== null) {
          handle["delete"]();
        }
      }
      function downcastPointer(ptr, ptrClass, desiredClass) {
        if (ptrClass === desiredClass) {
          return ptr;
        }
        if (desiredClass.baseClass === void 0) {
          return null;
        }
        var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
        if (rv === null) {
          return null;
        }
        return desiredClass.downcast(rv);
      }
      function getInheritedInstanceCount() {
        return Object.keys(registeredInstances).length;
      }
      function getLiveInheritedInstances() {
        var rv = [];
        for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
            rv.push(registeredInstances[k]);
          }
        }
        return rv;
      }
      function setDelayFunction(fn) {
        delayFunction = fn;
        if (deletionQueue.length && delayFunction) {
          delayFunction(flushPendingDeletes);
        }
      }
      function init_embind() {
        Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
        Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
        Module["flushPendingDeletes"] = flushPendingDeletes;
        Module["setDelayFunction"] = setDelayFunction;
      }
      var registeredInstances = {};
      function getBasestPointer(class_, ptr) {
        if (ptr === void 0) {
          throwBindingError("ptr should not be undefined");
        }
        while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
        }
        return ptr;
      }
      function getInheritedInstance(class_, ptr) {
        ptr = getBasestPointer(class_, ptr);
        return registeredInstances[ptr];
      }
      function makeClassHandle(prototype, record) {
        if (!record.ptrType || !record.ptr) {
          throwInternalError("makeClassHandle requires ptr and ptrType");
        }
        var hasSmartPtrType = !!record.smartPtrType;
        var hasSmartPtr = !!record.smartPtr;
        if (hasSmartPtrType !== hasSmartPtr) {
          throwInternalError("Both smartPtrType and smartPtr must be specified");
        }
        record.count = {value: 1};
        return attachFinalizer(Object.create(prototype, {$$: {value: record}}));
      }
      function RegisteredPointer_fromWireType(ptr) {
        var rawPointer = this.getPointee(ptr);
        if (!rawPointer) {
          this.destructor(ptr);
          return null;
        }
        var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
        if (registeredInstance !== void 0) {
          if (registeredInstance.$$.count.value === 0) {
            registeredInstance.$$.ptr = rawPointer;
            registeredInstance.$$.smartPtr = ptr;
            return registeredInstance["clone"]();
          } else {
            var rv = registeredInstance["clone"]();
            this.destructor(ptr);
            return rv;
          }
        }
        function makeDefaultHandle() {
          if (this.isSmartPointer) {
            return makeClassHandle(this.registeredClass.instancePrototype, {ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr});
          } else {
            return makeClassHandle(this.registeredClass.instancePrototype, {ptrType: this, ptr});
          }
        }
        var actualType = this.registeredClass.getActualType(rawPointer);
        var registeredPointerRecord = registeredPointers[actualType];
        if (!registeredPointerRecord) {
          return makeDefaultHandle.call(this);
        }
        var toType;
        if (this.isConst) {
          toType = registeredPointerRecord.constPointerType;
        } else {
          toType = registeredPointerRecord.pointerType;
        }
        var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
        if (dp === null) {
          return makeDefaultHandle.call(this);
        }
        if (this.isSmartPointer) {
          return makeClassHandle(toType.registeredClass.instancePrototype, {ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr});
        } else {
          return makeClassHandle(toType.registeredClass.instancePrototype, {ptrType: toType, ptr: dp});
        }
      }
      function init_RegisteredPointer() {
        RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
        RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
        RegisteredPointer.prototype["argPackAdvance"] = 8;
        RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
        RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
        RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
      }
      function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
        this.name = name2;
        this.registeredClass = registeredClass;
        this.isReference = isReference;
        this.isConst = isConst;
        this.isSmartPointer = isSmartPointer;
        this.pointeeType = pointeeType;
        this.sharingPolicy = sharingPolicy;
        this.rawGetPointee = rawGetPointee;
        this.rawConstructor = rawConstructor;
        this.rawShare = rawShare;
        this.rawDestructor = rawDestructor;
        if (!isSmartPointer && registeredClass.baseClass === void 0) {
          if (isConst) {
            this["toWireType"] = constNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
          } else {
            this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
          }
        } else {
          this["toWireType"] = genericPointerToWireType;
        }
      }
      function replacePublicSymbol(name2, value, numArguments) {
        if (!Module.hasOwnProperty(name2)) {
          throwInternalError("Replacing nonexistant public symbol");
        }
        if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
          Module[name2].overloadTable[numArguments] = value;
        } else {
          Module[name2] = value;
          Module[name2].argCount = numArguments;
        }
      }
      function getDynCaller(sig, ptr) {
        assert(sig.indexOf("j") >= 0, "getDynCaller should only be called with i64 sigs");
        var argCache = [];
        return function() {
          argCache.length = arguments.length;
          for (var i = 0; i < arguments.length; i++) {
            argCache[i] = arguments[i];
          }
          return dynCall(sig, ptr, argCache);
        };
      }
      function embind__requireFunction(signature, rawFunction) {
        signature = readLatin1String(signature);
        function makeDynCaller() {
          if (signature.indexOf("j") != -1) {
            return getDynCaller(signature, rawFunction);
          }
          return wasmTable.get(rawFunction);
        }
        var fp = makeDynCaller();
        if (typeof fp !== "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
        }
        return fp;
      }
      var UnboundTypeError = void 0;
      function getTypeName(type) {
        var ptr = ___getTypeName(type);
        var rv = readLatin1String(ptr);
        _free(ptr);
        return rv;
      }
      function throwUnboundTypeError(message, types) {
        var unboundTypes = [];
        var seen = {};
        function visit(type) {
          if (seen[type]) {
            return;
          }
          if (registeredTypes[type]) {
            return;
          }
          if (typeDependencies[type]) {
            typeDependencies[type].forEach(visit);
            return;
          }
          unboundTypes.push(type);
          seen[type] = true;
        }
        types.forEach(visit);
        throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
      }
      function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
        name2 = readLatin1String(name2);
        getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
        if (upcast) {
          upcast = embind__requireFunction(upcastSignature, upcast);
        }
        if (downcast) {
          downcast = embind__requireFunction(downcastSignature, downcast);
        }
        rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
        var legalFunctionName = makeLegalFunctionName(name2);
        exposePublicSymbol(legalFunctionName, function() {
          throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
        });
        whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
          base = base[0];
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
          var constructor = createNamedFunction(legalFunctionName, function() {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name2);
            }
            if (registeredClass.constructor_body === void 0) {
              throw new BindingError(name2 + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[arguments.length];
            if (body === void 0) {
              throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
            }
            return body.apply(this, arguments);
          });
          var instancePrototype = Object.create(basePrototype, {constructor: {value: constructor}});
          constructor.prototype = instancePrototype;
          var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
          var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
          var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
          var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
          registeredPointers[rawType] = {pointerType: pointerConverter, constPointerType: constPointerConverter};
          replacePublicSymbol(legalFunctionName, constructor);
          return [referenceConverter, pointerConverter, constPointerConverter];
        });
      }
      function heap32VectorToArray(count, firstElement) {
        var array = [];
        for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
        }
        return array;
      }
      function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
        assert(argCount > 0);
        var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
        invoker = embind__requireFunction(invokerSignature, invoker);
        var args = [rawConstructor];
        var destructors = [];
        whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = "constructor " + classType.name;
          if (classType.registeredClass.constructor_body === void 0) {
            classType.registeredClass.constructor_body = [];
          }
          if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
            throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          }
          classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
            throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
          };
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
              if (arguments.length !== argCount - 1) {
                throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
              }
              destructors.length = 0;
              args.length = argCount;
              for (var i = 1; i < argCount; ++i) {
                args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
              }
              var ptr = invoker.apply(null, args);
              runDestructors(destructors);
              return argTypes[0]["fromWireType"](ptr);
            };
            return [];
          });
          return [];
        });
      }
      function new_(constructor, argumentList) {
        if (!(constructor instanceof Function)) {
          throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
        }
        var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
        });
        dummy.prototype = constructor.prototype;
        var obj = new dummy();
        var r = constructor.apply(obj, argumentList);
        return r instanceof Object ? r : obj;
      }
      function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
        var argCount = argTypes.length;
        if (argCount < 2) {
          throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
        }
        var isClassMethodFunc = argTypes[1] !== null && classType !== null;
        var needsDestructorStack = false;
        for (var i = 1; i < argTypes.length; ++i) {
          if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
            needsDestructorStack = true;
            break;
          }
        }
        var returns = argTypes[0].name !== "void";
        var argsList = "";
        var argsListWired = "";
        for (var i = 0; i < argCount - 2; ++i) {
          argsList += (i !== 0 ? ", " : "") + "arg" + i;
          argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
        }
        var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
        if (needsDestructorStack) {
          invokerFnBody += "var destructors = [];\n";
        }
        var dtorStack = needsDestructorStack ? "destructors" : "null";
        var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
        var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
        if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
        }
        for (var i = 0; i < argCount - 2; ++i) {
          invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
          args1.push("argType" + i);
          args2.push(argTypes[i + 2]);
        }
        if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
        }
        invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
        if (needsDestructorStack) {
          invokerFnBody += "runDestructors(destructors);\n";
        } else {
          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
            var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
            if (argTypes[i].destructorFunction !== null) {
              invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
              args1.push(paramName + "_dtor");
              args2.push(argTypes[i].destructorFunction);
            }
          }
        }
        if (returns) {
          invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
        } else {
        }
        invokerFnBody += "}\n";
        args1.push(invokerFnBody);
        var invokerFunction = new_(Function, args1).apply(null, args2);
        return invokerFunction;
      }
      function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
        var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
        methodName = readLatin1String(methodName);
        rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
        whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + "." + methodName;
          if (isPureVirtual) {
            classType.registeredClass.pureVirtualFunctions.push(methodName);
          }
          function unboundTypesHandler() {
            throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
          }
          var proto = classType.registeredClass.instancePrototype;
          var method = proto[methodName];
          if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
            unboundTypesHandler.argCount = argCount - 2;
            unboundTypesHandler.className = classType.name;
            proto[methodName] = unboundTypesHandler;
          } else {
            ensureOverloadTable(proto, methodName, humanName);
            proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
          }
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
            if (proto[methodName].overloadTable === void 0) {
              memberFunction.argCount = argCount - 2;
              proto[methodName] = memberFunction;
            } else {
              proto[methodName].overloadTable[argCount - 2] = memberFunction;
            }
            return [];
          });
          return [];
        });
      }
      var emval_free_list = [];
      var emval_handle_array = [{}, {value: void 0}, {value: null}, {value: true}, {value: false}];
      function __emval_decref(handle) {
        if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
          emval_handle_array[handle] = void 0;
          emval_free_list.push(handle);
        }
      }
      function count_emval_handles() {
        var count = 0;
        for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== void 0) {
            ++count;
          }
        }
        return count;
      }
      function get_first_emval() {
        for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== void 0) {
            return emval_handle_array[i];
          }
        }
        return null;
      }
      function init_emval() {
        Module["count_emval_handles"] = count_emval_handles;
        Module["get_first_emval"] = get_first_emval;
      }
      function __emval_register(value) {
        switch (value) {
          case void 0: {
            return 1;
          }
          case null: {
            return 2;
          }
          case true: {
            return 3;
          }
          case false: {
            return 4;
          }
          default: {
            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
            emval_handle_array[handle] = {refcount: 1, value};
            return handle;
          }
        }
      }
      function __embind_register_emval(rawType, name2) {
        name2 = readLatin1String(name2);
        registerType(rawType, {name: name2, fromWireType: function(handle) {
          var rv = emval_handle_array[handle].value;
          __emval_decref(handle);
          return rv;
        }, toWireType: function(destructors, value) {
          return __emval_register(value);
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: null});
      }
      function _embind_repr(v) {
        if (v === null) {
          return "null";
        }
        var t = typeof v;
        if (t === "object" || t === "array" || t === "function") {
          return v.toString();
        } else {
          return "" + v;
        }
      }
      function floatReadValueFromPointer(name2, shift) {
        switch (shift) {
          case 2:
            return function(pointer) {
              return this["fromWireType"](HEAPF32[pointer >> 2]);
            };
          case 3:
            return function(pointer) {
              return this["fromWireType"](HEAPF64[pointer >> 3]);
            };
          default:
            throw new TypeError("Unknown float type: " + name2);
        }
      }
      function __embind_register_float(rawType, name2, size) {
        var shift = getShiftFromSize(size);
        name2 = readLatin1String(name2);
        registerType(rawType, {name: name2, fromWireType: function(value) {
          return value;
        }, toWireType: function(destructors, value) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
          }
          return value;
        }, argPackAdvance: 8, readValueFromPointer: floatReadValueFromPointer(name2, shift), destructorFunction: null});
      }
      function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
        var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
        name2 = readLatin1String(name2);
        rawInvoker = embind__requireFunction(signature, rawInvoker);
        exposePublicSymbol(name2, function() {
          throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
        }, argCount - 1);
        whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
          var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
          replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
          return [];
        });
      }
      function integerReadValueFromPointer(name2, shift, signed) {
        switch (shift) {
          case 0:
            return signed ? function readS8FromPointer(pointer) {
              return HEAP8[pointer];
            } : function readU8FromPointer(pointer) {
              return HEAPU8[pointer];
            };
          case 1:
            return signed ? function readS16FromPointer(pointer) {
              return HEAP16[pointer >> 1];
            } : function readU16FromPointer(pointer) {
              return HEAPU16[pointer >> 1];
            };
          case 2:
            return signed ? function readS32FromPointer(pointer) {
              return HEAP32[pointer >> 2];
            } : function readU32FromPointer(pointer) {
              return HEAPU32[pointer >> 2];
            };
          default:
            throw new TypeError("Unknown integer type: " + name2);
        }
      }
      function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
        name2 = readLatin1String(name2);
        if (maxRange === -1) {
          maxRange = 4294967295;
        }
        var shift = getShiftFromSize(size);
        var fromWireType = function(value) {
          return value;
        };
        if (minRange === 0) {
          var bitshift = 32 - 8 * size;
          fromWireType = function(value) {
            return value << bitshift >>> bitshift;
          };
        }
        var isUnsignedType = name2.indexOf("unsigned") != -1;
        registerType(primitiveType, {name: name2, fromWireType, toWireType: function(destructors, value) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
          }
          if (value < minRange || value > maxRange) {
            throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
          }
          return isUnsignedType ? value >>> 0 : value | 0;
        }, argPackAdvance: 8, readValueFromPointer: integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null});
      }
      function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
        var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        var TA = typeMapping[dataTypeIndex];
        function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle];
          var data = heap[handle + 1];
          return new TA(buffer, data, size);
        }
        name2 = readLatin1String(name2);
        registerType(rawType, {name: name2, fromWireType: decodeMemoryView, argPackAdvance: 8, readValueFromPointer: decodeMemoryView}, {ignoreDuplicateRegistrations: true});
      }
      function __embind_register_std_string(rawType, name2) {
        name2 = readLatin1String(name2);
        var stdStringIsUTF8 = name2 === "std::string";
        registerType(rawType, {name: name2, fromWireType: function(value) {
          var length = HEAPU32[value >> 2];
          var str;
          if (stdStringIsUTF8) {
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i;
              if (i == length || HEAPU8[currentBytePtr] == 0) {
                var maxRead = currentBytePtr - decodeStartPtr;
                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + 1;
              }
            }
          } else {
            var a = new Array(length);
            for (var i = 0; i < length; ++i) {
              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
            }
            str = a.join("");
          }
          _free(value);
          return str;
        }, toWireType: function(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
          var getLength;
          var valueIsOfTypeString = typeof value === "string";
          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
            throwBindingError("Cannot pass non-string to std::string");
          }
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            getLength = function() {
              return lengthBytesUTF8(value);
            };
          } else {
            getLength = function() {
              return value.length;
            };
          }
          var length = getLength();
          var ptr = _malloc(4 + length + 1);
          HEAPU32[ptr >> 2] = length;
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF8(value, ptr + 4, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i = 0; i < length; ++i) {
                var charCode = value.charCodeAt(i);
                if (charCode > 255) {
                  _free(ptr);
                  throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                }
                HEAPU8[ptr + 4 + i] = charCode;
              }
            } else {
              for (var i = 0; i < length; ++i) {
                HEAPU8[ptr + 4 + i] = value[i];
              }
            }
          }
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: function(ptr) {
          _free(ptr);
        }});
      }
      function __embind_register_std_wstring(rawType, charSize, name2) {
        name2 = readLatin1String(name2);
        var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
        if (charSize === 2) {
          decodeString = UTF16ToString;
          encodeString = stringToUTF16;
          lengthBytesUTF = lengthBytesUTF16;
          getHeap = function() {
            return HEAPU16;
          };
          shift = 1;
        } else if (charSize === 4) {
          decodeString = UTF32ToString;
          encodeString = stringToUTF32;
          lengthBytesUTF = lengthBytesUTF32;
          getHeap = function() {
            return HEAPU32;
          };
          shift = 2;
        }
        registerType(rawType, {name: name2, fromWireType: function(value) {
          var length = HEAPU32[value >> 2];
          var HEAP = getHeap();
          var str;
          var decodeStartPtr = value + 4;
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === void 0) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
          _free(value);
          return str;
        }, toWireType: function(destructors, value) {
          if (!(typeof value === "string")) {
            throwBindingError("Cannot pass non-string to C++ string type " + name2);
          }
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[ptr >> 2] = length >> shift;
          encodeString(value, ptr + 4, length + charSize);
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: function(ptr) {
          _free(ptr);
        }});
      }
      function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
        tupleRegistrations[rawType] = {name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: []};
      }
      function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
        tupleRegistrations[rawTupleType].elements.push({getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext});
      }
      function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
        structRegistrations[rawType] = {name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: []};
      }
      function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
        structRegistrations[structType].fields.push({fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext});
      }
      function __embind_register_void(rawType, name2) {
        name2 = readLatin1String(name2);
        registerType(rawType, {isVoid: true, name: name2, argPackAdvance: 0, fromWireType: function() {
          return void 0;
        }, toWireType: function(destructors, o) {
          return void 0;
        }});
      }
      function requireHandle(handle) {
        if (!handle) {
          throwBindingError("Cannot use deleted val. handle = " + handle);
        }
        return emval_handle_array[handle].value;
      }
      function requireRegisteredType(rawType, humanName) {
        var impl = registeredTypes[rawType];
        if (impl === void 0) {
          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
        }
        return impl;
      }
      function __emval_as(handle, returnType, destructorsRef) {
        handle = requireHandle(handle);
        returnType = requireRegisteredType(returnType, "emval::as");
        var destructors = [];
        var rd = __emval_register(destructors);
        HEAP32[destructorsRef >> 2] = rd;
        return returnType["toWireType"](destructors, handle);
      }
      var emval_symbols = {};
      function getStringOrSymbol(address) {
        var symbol = emval_symbols[address];
        if (symbol === void 0) {
          return readLatin1String(address);
        } else {
          return symbol;
        }
      }
      function emval_get_global() {
        if (typeof globalThis === "object") {
          return globalThis;
        }
        return function() {
          return Function;
        }()("return this")();
      }
      function __emval_get_global(name2) {
        if (name2 === 0) {
          return __emval_register(emval_get_global());
        } else {
          name2 = getStringOrSymbol(name2);
          return __emval_register(emval_get_global()[name2]);
        }
      }
      function __emval_get_property(handle, key2) {
        handle = requireHandle(handle);
        key2 = requireHandle(key2);
        return __emval_register(handle[key2]);
      }
      function __emval_incref(handle) {
        if (handle > 4) {
          emval_handle_array[handle].refcount += 1;
        }
      }
      function __emval_instanceof(object, constructor) {
        object = requireHandle(object);
        constructor = requireHandle(constructor);
        return object instanceof constructor;
      }
      function __emval_is_number(handle) {
        handle = requireHandle(handle);
        return typeof handle === "number";
      }
      function __emval_new_array() {
        return __emval_register([]);
      }
      function __emval_new_cstring(v) {
        return __emval_register(getStringOrSymbol(v));
      }
      function __emval_new_object() {
        return __emval_register({});
      }
      function __emval_run_destructors(handle) {
        var destructors = emval_handle_array[handle].value;
        runDestructors(destructors);
        __emval_decref(handle);
      }
      function __emval_set_property(handle, key2, value) {
        handle = requireHandle(handle);
        key2 = requireHandle(key2);
        value = requireHandle(value);
        handle[key2] = value;
      }
      function __emval_take_value(type, argv) {
        type = requireRegisteredType(type, "_emval_take_value");
        var v = type["readValueFromPointer"](argv);
        return __emval_register(v);
      }
      function _abort() {
        abort();
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        _emscripten_get_now = function() {
          var t = process["hrtime"]();
          return t[0] * 1e3 + t[1] / 1e6;
        };
      } else if (typeof dateNow !== "undefined") {
        _emscripten_get_now = dateNow;
      } else
        _emscripten_get_now = function() {
          return performance.now();
        };
      var _emscripten_get_now_is_monotonic = true;
      function _clock_gettime(clk_id, tp) {
        var now;
        if (clk_id === 0) {
          now = Date.now();
        } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
          now = _emscripten_get_now();
        } else {
          setErrNo(28);
          return -1;
        }
        HEAP32[tp >> 2] = now / 1e3 | 0;
        HEAP32[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0;
        return 0;
      }
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest, src, src + num);
      }
      function _emscripten_get_heap_size() {
        return HEAPU8.length;
      }
      function emscripten_realloc_buffer(size) {
        try {
          wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
          updateGlobalBufferAndViews(wasmMemory.buffer);
          return 1;
        } catch (e) {
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        requestedSize = requestedSize >>> 0;
        var oldSize = _emscripten_get_heap_size();
        var maxHeapSize = 2147483648;
        if (requestedSize > maxHeapSize) {
          return false;
        }
        var minHeapSize = 16777216;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        return false;
      }
      var ENV = {};
      function getExecutableName() {
        return thisProgram || "./this.program";
      }
      function getEnvStrings() {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env = {USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: lang, _: getExecutableName()};
          for (var x in ENV) {
            env[x] = ENV[x];
          }
          var strings = [];
          for (var x in env) {
            strings.push(x + "=" + env[x]);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      }
      function _environ_get(__environ, environ_buf) {
        try {
          var bufSize = 0;
          getEnvStrings().forEach(function(string, i) {
            var ptr = environ_buf + bufSize;
            HEAP32[__environ + i * 4 >> 2] = ptr;
            writeAsciiToMemory(string, ptr);
            bufSize += string.length + 1;
          });
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _environ_sizes_get(penviron_count, penviron_buf_size) {
        try {
          var strings = getEnvStrings();
          HEAP32[penviron_count >> 2] = strings.length;
          var bufSize = 0;
          strings.forEach(function(string) {
            bufSize += string.length + 1;
          });
          HEAP32[penviron_buf_size >> 2] = bufSize;
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_close(fd) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          FS.close(stream);
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_read(fd, iov, iovcnt, pnum) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var num = SYSCALLS.doReadv(stream, iov, iovcnt);
          HEAP32[pnum >> 2] = num;
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var HIGH_OFFSET = 4294967296;
          var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
          var DOUBLE_LIMIT = 9007199254740992;
          if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
            return -61;
          }
          FS.llseek(stream, offset, whence);
          tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
          if (stream.getdents && offset === 0 && whence === 0)
            stream.getdents = null;
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var num = SYSCALLS.doWritev(stream, iov, iovcnt);
          HEAP32[pnum >> 2] = num;
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _setTempRet0($i) {
        setTempRet0($i | 0);
      }
      function __isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function __arraySum(array, index) {
        var sum = 0;
        for (var i = 0; i <= index; sum += array[i++]) {
        }
        return sum;
      }
      var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function __addDays(date, days) {
        var newDate = new Date(date.getTime());
        while (days > 0) {
          var leap = __isLeapYear(newDate.getFullYear());
          var currentMonth = newDate.getMonth();
          var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
          if (days > daysInCurrentMonth - newDate.getDate()) {
            days -= daysInCurrentMonth - newDate.getDate() + 1;
            newDate.setDate(1);
            if (currentMonth < 11) {
              newDate.setMonth(currentMonth + 1);
            } else {
              newDate.setMonth(0);
              newDate.setFullYear(newDate.getFullYear() + 1);
            }
          } else {
            newDate.setDate(newDate.getDate() + days);
            return newDate;
          }
        }
        return newDate;
      }
      function _strftime(s, maxsize, format, tm) {
        var tm_zone = HEAP32[tm + 40 >> 2];
        var date = {tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""};
        var pattern = UTF8ToString(format);
        var EXPANSION_RULES_1 = {"%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y"};
        for (var rule in EXPANSION_RULES_1) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        }
        var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function leadingSomething(value, digits, character) {
          var str = typeof value === "number" ? value.toString() : value || "";
          while (str.length < digits) {
            str = character[0] + str;
          }
          return str;
        }
        function leadingNulls(value, digits) {
          return leadingSomething(value, digits, "0");
        }
        function compareByDay(date1, date2) {
          function sgn(value) {
            return value < 0 ? -1 : value > 0 ? 1 : 0;
          }
          var compare;
          if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
              compare = sgn(date1.getDate() - date2.getDate());
            }
          }
          return compare;
        }
        function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0:
              return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1:
              return janFourth;
            case 2:
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3:
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4:
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5:
              return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(janFourth.getFullYear() - 1, 11, 30);
          }
        }
        function getWeekBasedYear(date2) {
          var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear() + 1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear() - 1;
          }
        }
        var EXPANSION_RULES_2 = {"%a": function(date2) {
          return WEEKDAYS[date2.tm_wday].substring(0, 3);
        }, "%A": function(date2) {
          return WEEKDAYS[date2.tm_wday];
        }, "%b": function(date2) {
          return MONTHS[date2.tm_mon].substring(0, 3);
        }, "%B": function(date2) {
          return MONTHS[date2.tm_mon];
        }, "%C": function(date2) {
          var year = date2.tm_year + 1900;
          return leadingNulls(year / 100 | 0, 2);
        }, "%d": function(date2) {
          return leadingNulls(date2.tm_mday, 2);
        }, "%e": function(date2) {
          return leadingSomething(date2.tm_mday, 2, " ");
        }, "%g": function(date2) {
          return getWeekBasedYear(date2).toString().substring(2);
        }, "%G": function(date2) {
          return getWeekBasedYear(date2);
        }, "%H": function(date2) {
          return leadingNulls(date2.tm_hour, 2);
        }, "%I": function(date2) {
          var twelveHour = date2.tm_hour;
          if (twelveHour == 0)
            twelveHour = 12;
          else if (twelveHour > 12)
            twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        }, "%j": function(date2) {
          return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
        }, "%m": function(date2) {
          return leadingNulls(date2.tm_mon + 1, 2);
        }, "%M": function(date2) {
          return leadingNulls(date2.tm_min, 2);
        }, "%n": function() {
          return "\n";
        }, "%p": function(date2) {
          if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
            return "AM";
          } else {
            return "PM";
          }
        }, "%S": function(date2) {
          return leadingNulls(date2.tm_sec, 2);
        }, "%t": function() {
          return "	";
        }, "%u": function(date2) {
          return date2.tm_wday || 7;
        }, "%U": function(date2) {
          var janFirst = new Date(date2.tm_year + 1900, 0, 1);
          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
          var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
          if (compareByDay(firstSunday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
            var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
            var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
            return leadingNulls(Math.ceil(days / 7), 2);
          }
          return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
        }, "%V": function(date2) {
          var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
          var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
            return "53";
          }
          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
            return "01";
          }
          var daysDifference;
          if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
            daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
          } else {
            daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
          }
          return leadingNulls(Math.ceil(daysDifference / 7), 2);
        }, "%w": function(date2) {
          return date2.tm_wday;
        }, "%W": function(date2) {
          var janFirst = new Date(date2.tm_year, 0, 1);
          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
          var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
          if (compareByDay(firstMonday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
            var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
            var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
            return leadingNulls(Math.ceil(days / 7), 2);
          }
          return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
        }, "%y": function(date2) {
          return (date2.tm_year + 1900).toString().substring(2);
        }, "%Y": function(date2) {
          return date2.tm_year + 1900;
        }, "%z": function(date2) {
          var off = date2.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          off = off / 60 * 100 + off % 60;
          return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
        }, "%Z": function(date2) {
          return date2.tm_zone;
        }, "%%": function() {
          return "%";
        }};
        for (var rule in EXPANSION_RULES_2) {
          if (pattern.indexOf(rule) >= 0) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
          }
        }
        var bytes = intArrayFromString(pattern, false);
        if (bytes.length > maxsize) {
          return 0;
        }
        writeArrayToMemory(bytes, s);
        return bytes.length - 1;
      }
      function _strftime_l(s, maxsize, format, tm) {
        return _strftime(s, maxsize, format, tm);
      }
      var FSNode = function(parent, name2, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name2;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
      };
      var readMode = 292 | 73;
      var writeMode = 146;
      Object.defineProperties(FSNode.prototype, {read: {get: function() {
        return (this.mode & readMode) === readMode;
      }, set: function(val) {
        val ? this.mode |= readMode : this.mode &= ~readMode;
      }}, write: {get: function() {
        return (this.mode & writeMode) === writeMode;
      }, set: function(val) {
        val ? this.mode |= writeMode : this.mode &= ~writeMode;
      }}, isFolder: {get: function() {
        return FS.isDir(this.mode);
      }}, isDevice: {get: function() {
        return FS.isChrdev(this.mode);
      }}});
      FS.FSNode = FSNode;
      FS.staticInit();
      Module["FS_createPath"] = FS.createPath;
      Module["FS_createDataFile"] = FS.createDataFile;
      Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
      Module["FS_createLazyFile"] = FS.createLazyFile;
      Module["FS_createDevice"] = FS.createDevice;
      Module["FS_unlink"] = FS.unlink;
      InternalError = Module["InternalError"] = extendError(Error, "InternalError");
      embind_init_charCodes();
      BindingError = Module["BindingError"] = extendError(Error, "BindingError");
      init_ClassHandle();
      init_RegisteredPointer();
      init_embind();
      UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
      init_emval();
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      __ATINIT__.push({func: function() {
        ___wasm_call_ctors();
      }});
      var asmLibraryArg = {x: ___assert_fail, A: ___sys_fcntl64, O: ___sys_ioctl, P: ___sys_open, U: __embind_finalize_value_array, s: __embind_finalize_value_object, S: __embind_register_bool, v: __embind_register_class, u: __embind_register_class_constructor, d: __embind_register_class_function, R: __embind_register_emval, C: __embind_register_float, i: __embind_register_function, m: __embind_register_integer, j: __embind_register_memory_view, D: __embind_register_std_string, w: __embind_register_std_wstring, V: __embind_register_value_array, g: __embind_register_value_array_element, t: __embind_register_value_object, k: __embind_register_value_object_field, T: __embind_register_void, q: __emval_as, b: __emval_decref, L: __emval_get_global, n: __emval_get_property, l: __emval_incref, Q: __emval_instanceof, E: __emval_is_number, y: __emval_new_array, f: __emval_new_cstring, r: __emval_new_object, p: __emval_run_destructors, h: __emval_set_property, e: __emval_take_value, c: _abort, M: _clock_gettime, H: _emscripten_memcpy_big, o: _emscripten_resize_heap, J: _environ_get, K: _environ_sizes_get, B: _fd_close, N: _fd_read, F: _fd_seek, z: _fd_write, a: wasmMemory, G: _setTempRet0, I: _strftime_l};
      var asm = createWasm();
      var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
        return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["X"]).apply(null, arguments);
      };
      var _main = Module["_main"] = function() {
        return (_main = Module["_main"] = Module["asm"]["Y"]).apply(null, arguments);
      };
      var _malloc = Module["_malloc"] = function() {
        return (_malloc = Module["_malloc"] = Module["asm"]["Z"]).apply(null, arguments);
      };
      var ___getTypeName = Module["___getTypeName"] = function() {
        return (___getTypeName = Module["___getTypeName"] = Module["asm"]["_"]).apply(null, arguments);
      };
      var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
        return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["$"]).apply(null, arguments);
      };
      var ___errno_location = Module["___errno_location"] = function() {
        return (___errno_location = Module["___errno_location"] = Module["asm"]["aa"]).apply(null, arguments);
      };
      var _free = Module["_free"] = function() {
        return (_free = Module["_free"] = Module["asm"]["ba"]).apply(null, arguments);
      };
      var dynCall_jiji = Module["dynCall_jiji"] = function() {
        return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["ca"]).apply(null, arguments);
      };
      var dynCall_viijii = Module["dynCall_viijii"] = function() {
        return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["da"]).apply(null, arguments);
      };
      var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
        return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["ea"]).apply(null, arguments);
      };
      var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
        return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["fa"]).apply(null, arguments);
      };
      var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
        return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["ga"]).apply(null, arguments);
      };
      Module["addRunDependency"] = addRunDependency;
      Module["removeRunDependency"] = removeRunDependency;
      Module["FS_createPath"] = FS.createPath;
      Module["FS_createDataFile"] = FS.createDataFile;
      Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
      Module["FS_createLazyFile"] = FS.createLazyFile;
      Module["FS_createDevice"] = FS.createDevice;
      Module["FS_unlink"] = FS.unlink;
      Module["FS"] = FS;
      var calledRun;
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status + ")";
        this.status = status;
      }
      var calledMain = false;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain(args) {
        var entryFunction = Module["_main"];
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exit(ret, true);
        } catch (e) {
          if (e instanceof ExitStatus) {
            return;
          } else if (e == "unwind") {
            noExitRuntime = true;
            return;
          } else {
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          }
        } finally {
          calledMain = true;
        }
      }
      function run(args) {
        args = args || arguments_;
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0)
          return;
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain(args);
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run;
      function exit(status, implicit) {
        if (implicit && noExitRuntime && status === 0) {
          return;
        }
        if (noExitRuntime) {
        } else {
          EXITSTATUS = status;
          exitRuntime();
          if (Module["onExit"])
            Module["onExit"](status);
          ABORT = true;
        }
        quit_(status, new ExitStatus(status));
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      noExitRuntime = true;
      run();
      return WebIFCWasm3.ready;
    };
  }();
  if (typeof exports2 === "object" && typeof module2 === "object")
    module2.exports = WebIFCWasm2;
  else if (typeof define === "function" && define["amd"])
    define([], function() {
      return WebIFCWasm2;
    });
  else if (typeof exports2 === "object")
    exports2["WebIFCWasm"] = WebIFCWasm2;
});

// node_modules/three/build/three.js
var require_three = __commonJS((exports2, module2) => {
  (function(global, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.THREE = {}));
  })(exports2, function(exports3) {
    "use strict";
    var runtime = function(exports4) {
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports4.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      IteratorPrototype[iteratorSymbol] = function() {
        return this;
      };
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports4.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports4.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports4.awrap = function(arg) {
        return {
          __await: arg
        };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      AsyncIterator.prototype[asyncIteratorSymbol] = function() {
        return this;
      };
      exports4.AsyncIterator = AsyncIterator;
      exports4.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports4.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined$1) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports4.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              while (++i2 < iterable.length) {
                if (hasOwn.call(iterable, i2)) {
                  next2.value = iterable[i2];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined$1;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      exports4.values = values;
      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name2 in this) {
              if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
                this[name2] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined$1;
            }
            return !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        catch: function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined$1;
          }
          return ContinueSentinel;
        }
      };
      return exports4;
    }(typeof module2 === "object" ? module2.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
    var REVISION2 = "126";
    var MOUSE2 = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
    };
    var TOUCH2 = {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
    };
    var CullFaceNone2 = 0;
    var CullFaceBack2 = 1;
    var CullFaceFront2 = 2;
    var CullFaceFrontBack = 3;
    var BasicShadowMap = 0;
    var PCFShadowMap2 = 1;
    var PCFSoftShadowMap2 = 2;
    var VSMShadowMap2 = 3;
    var FrontSide2 = 0;
    var BackSide2 = 1;
    var DoubleSide3 = 2;
    var FlatShading2 = 1;
    var SmoothShading = 2;
    var NoBlending2 = 0;
    var NormalBlending2 = 1;
    var AdditiveBlending2 = 2;
    var SubtractiveBlending2 = 3;
    var MultiplyBlending2 = 4;
    var CustomBlending2 = 5;
    var AddEquation2 = 100;
    var SubtractEquation2 = 101;
    var ReverseSubtractEquation2 = 102;
    var MinEquation2 = 103;
    var MaxEquation2 = 104;
    var ZeroFactor2 = 200;
    var OneFactor2 = 201;
    var SrcColorFactor2 = 202;
    var OneMinusSrcColorFactor2 = 203;
    var SrcAlphaFactor2 = 204;
    var OneMinusSrcAlphaFactor2 = 205;
    var DstAlphaFactor2 = 206;
    var OneMinusDstAlphaFactor2 = 207;
    var DstColorFactor2 = 208;
    var OneMinusDstColorFactor2 = 209;
    var SrcAlphaSaturateFactor2 = 210;
    var NeverDepth2 = 0;
    var AlwaysDepth2 = 1;
    var LessDepth2 = 2;
    var LessEqualDepth2 = 3;
    var EqualDepth2 = 4;
    var GreaterEqualDepth2 = 5;
    var GreaterDepth2 = 6;
    var NotEqualDepth2 = 7;
    var MultiplyOperation2 = 0;
    var MixOperation2 = 1;
    var AddOperation2 = 2;
    var NoToneMapping2 = 0;
    var LinearToneMapping2 = 1;
    var ReinhardToneMapping2 = 2;
    var CineonToneMapping2 = 3;
    var ACESFilmicToneMapping2 = 4;
    var CustomToneMapping2 = 5;
    var UVMapping2 = 300;
    var CubeReflectionMapping2 = 301;
    var CubeRefractionMapping2 = 302;
    var EquirectangularReflectionMapping2 = 303;
    var EquirectangularRefractionMapping2 = 304;
    var CubeUVReflectionMapping2 = 306;
    var CubeUVRefractionMapping2 = 307;
    var RepeatWrapping2 = 1e3;
    var ClampToEdgeWrapping2 = 1001;
    var MirroredRepeatWrapping2 = 1002;
    var NearestFilter2 = 1003;
    var NearestMipmapNearestFilter2 = 1004;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipmapLinearFilter2 = 1005;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter2 = 1006;
    var LinearMipmapNearestFilter2 = 1007;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipmapLinearFilter2 = 1008;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType2 = 1009;
    var ByteType2 = 1010;
    var ShortType2 = 1011;
    var UnsignedShortType2 = 1012;
    var IntType2 = 1013;
    var UnsignedIntType2 = 1014;
    var FloatType2 = 1015;
    var HalfFloatType2 = 1016;
    var UnsignedShort4444Type2 = 1017;
    var UnsignedShort5551Type2 = 1018;
    var UnsignedShort565Type2 = 1019;
    var UnsignedInt248Type2 = 1020;
    var AlphaFormat2 = 1021;
    var RGBFormat2 = 1022;
    var RGBAFormat2 = 1023;
    var LuminanceFormat2 = 1024;
    var LuminanceAlphaFormat2 = 1025;
    var RGBEFormat = RGBAFormat2;
    var DepthFormat2 = 1026;
    var DepthStencilFormat2 = 1027;
    var RedFormat2 = 1028;
    var RedIntegerFormat2 = 1029;
    var RGFormat2 = 1030;
    var RGIntegerFormat2 = 1031;
    var RGBIntegerFormat2 = 1032;
    var RGBAIntegerFormat2 = 1033;
    var RGB_S3TC_DXT1_Format2 = 33776;
    var RGBA_S3TC_DXT1_Format2 = 33777;
    var RGBA_S3TC_DXT3_Format2 = 33778;
    var RGBA_S3TC_DXT5_Format2 = 33779;
    var RGB_PVRTC_4BPPV1_Format2 = 35840;
    var RGB_PVRTC_2BPPV1_Format2 = 35841;
    var RGBA_PVRTC_4BPPV1_Format2 = 35842;
    var RGBA_PVRTC_2BPPV1_Format2 = 35843;
    var RGB_ETC1_Format2 = 36196;
    var RGB_ETC2_Format2 = 37492;
    var RGBA_ETC2_EAC_Format2 = 37496;
    var RGBA_ASTC_4x4_Format2 = 37808;
    var RGBA_ASTC_5x4_Format2 = 37809;
    var RGBA_ASTC_5x5_Format2 = 37810;
    var RGBA_ASTC_6x5_Format2 = 37811;
    var RGBA_ASTC_6x6_Format2 = 37812;
    var RGBA_ASTC_8x5_Format2 = 37813;
    var RGBA_ASTC_8x6_Format2 = 37814;
    var RGBA_ASTC_8x8_Format2 = 37815;
    var RGBA_ASTC_10x5_Format2 = 37816;
    var RGBA_ASTC_10x6_Format2 = 37817;
    var RGBA_ASTC_10x8_Format2 = 37818;
    var RGBA_ASTC_10x10_Format2 = 37819;
    var RGBA_ASTC_12x10_Format2 = 37820;
    var RGBA_ASTC_12x12_Format2 = 37821;
    var RGBA_BPTC_Format2 = 36492;
    var SRGB8_ALPHA8_ASTC_4x4_Format2 = 37840;
    var SRGB8_ALPHA8_ASTC_5x4_Format2 = 37841;
    var SRGB8_ALPHA8_ASTC_5x5_Format2 = 37842;
    var SRGB8_ALPHA8_ASTC_6x5_Format2 = 37843;
    var SRGB8_ALPHA8_ASTC_6x6_Format2 = 37844;
    var SRGB8_ALPHA8_ASTC_8x5_Format2 = 37845;
    var SRGB8_ALPHA8_ASTC_8x6_Format2 = 37846;
    var SRGB8_ALPHA8_ASTC_8x8_Format2 = 37847;
    var SRGB8_ALPHA8_ASTC_10x5_Format2 = 37848;
    var SRGB8_ALPHA8_ASTC_10x6_Format2 = 37849;
    var SRGB8_ALPHA8_ASTC_10x8_Format2 = 37850;
    var SRGB8_ALPHA8_ASTC_10x10_Format2 = 37851;
    var SRGB8_ALPHA8_ASTC_12x10_Format2 = 37852;
    var SRGB8_ALPHA8_ASTC_12x12_Format2 = 37853;
    var LoopOnce2 = 2200;
    var LoopRepeat2 = 2201;
    var LoopPingPong2 = 2202;
    var InterpolateDiscrete2 = 2300;
    var InterpolateLinear2 = 2301;
    var InterpolateSmooth2 = 2302;
    var ZeroCurvatureEnding2 = 2400;
    var ZeroSlopeEnding2 = 2401;
    var WrapAroundEnding2 = 2402;
    var NormalAnimationBlendMode2 = 2500;
    var AdditiveAnimationBlendMode2 = 2501;
    var TrianglesDrawMode2 = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding2 = 3e3;
    var sRGBEncoding2 = 3001;
    var GammaEncoding2 = 3007;
    var RGBEEncoding2 = 3002;
    var LogLuvEncoding2 = 3003;
    var RGBM7Encoding2 = 3004;
    var RGBM16Encoding2 = 3005;
    var RGBDEncoding2 = 3006;
    var BasicDepthPacking2 = 3200;
    var RGBADepthPacking2 = 3201;
    var TangentSpaceNormalMap2 = 0;
    var ObjectSpaceNormalMap2 = 1;
    var ZeroStencilOp = 0;
    var KeepStencilOp2 = 7680;
    var ReplaceStencilOp = 7681;
    var IncrementStencilOp = 7682;
    var DecrementStencilOp = 7683;
    var IncrementWrapStencilOp = 34055;
    var DecrementWrapStencilOp = 34056;
    var InvertStencilOp = 5386;
    var NeverStencilFunc = 512;
    var LessStencilFunc = 513;
    var EqualStencilFunc = 514;
    var LessEqualStencilFunc = 515;
    var GreaterStencilFunc = 516;
    var NotEqualStencilFunc = 517;
    var GreaterEqualStencilFunc = 518;
    var AlwaysStencilFunc2 = 519;
    var StaticDrawUsage2 = 35044;
    var DynamicDrawUsage2 = 35048;
    var StreamDrawUsage = 35040;
    var StaticReadUsage = 35045;
    var DynamicReadUsage = 35049;
    var StreamReadUsage = 35041;
    var StaticCopyUsage = 35046;
    var DynamicCopyUsage = 35050;
    var StreamCopyUsage = 35042;
    var GLSL1 = "100";
    var GLSL32 = "300 es";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          return function() {
            if (i2 >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i2++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function EventDispatcher2() {
    }
    Object.assign(EventDispatcher2.prototype, {
      addEventListener: function addEventListener(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function hasEventListener(type, listener) {
        if (this._listeners === void 0)
          return false;
        var listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      },
      removeEventListener: function removeEventListener(type, listener) {
        if (this._listeners === void 0)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function dispatchEvent(event) {
        if (this._listeners === void 0)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          var array = listenerArray.slice(0);
          for (var i2 = 0, l = array.length; i2 < l; i2++) {
            array[i2].call(this, event);
          }
        }
      }
    });
    var _lut2 = [];
    for (var i = 0; i < 256; i++) {
      _lut2[i] = (i < 16 ? "0" : "") + i.toString(16);
    }
    var _seed2 = 1234567;
    var MathUtils2 = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function generateUUID() {
        var d0 = Math.random() * 4294967295 | 0;
        var d1 = Math.random() * 4294967295 | 0;
        var d2 = Math.random() * 4294967295 | 0;
        var d3 = Math.random() * 4294967295 | 0;
        var uuid = _lut2[d0 & 255] + _lut2[d0 >> 8 & 255] + _lut2[d0 >> 16 & 255] + _lut2[d0 >> 24 & 255] + "-" + _lut2[d1 & 255] + _lut2[d1 >> 8 & 255] + "-" + _lut2[d1 >> 16 & 15 | 64] + _lut2[d1 >> 24 & 255] + "-" + _lut2[d2 & 63 | 128] + _lut2[d2 >> 8 & 255] + "-" + _lut2[d2 >> 16 & 255] + _lut2[d2 >> 24 & 255] + _lut2[d3 & 255] + _lut2[d3 >> 8 & 255] + _lut2[d3 >> 16 & 255] + _lut2[d3 >> 24 & 255];
        return uuid.toUpperCase();
      },
      clamp: function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      },
      euclideanModulo: function euclideanModulo(n, m) {
        return (n % m + m) % m;
      },
      mapLinear: function mapLinear(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      lerp: function lerp(x, y, t) {
        return (1 - t) * x + t * y;
      },
      damp: function damp(x, y, lambda, dt) {
        return MathUtils2.lerp(x, y, 1 - Math.exp(-lambda * dt));
      },
      pingpong: function pingpong(x, length) {
        if (length === void 0) {
          length = 1;
        }
        return length - Math.abs(MathUtils2.euclideanModulo(x, length * 2) - length);
      },
      smoothstep: function smoothstep(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function smootherstep(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      randInt: function randInt(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      },
      randFloat: function randFloat(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function randFloatSpread(range) {
        return range * (0.5 - Math.random());
      },
      seededRandom: function seededRandom(s) {
        if (s !== void 0)
          _seed2 = s % 2147483647;
        _seed2 = _seed2 * 16807 % 2147483647;
        return (_seed2 - 1) / 2147483646;
      },
      degToRad: function degToRad(degrees) {
        return degrees * MathUtils2.DEG2RAD;
      },
      radToDeg: function radToDeg(radians) {
        return radians * MathUtils2.RAD2DEG;
      },
      isPowerOfTwo: function isPowerOfTwo(value) {
        return (value & value - 1) === 0 && value !== 0;
      },
      ceilPowerOfTwo: function ceilPowerOfTwo(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      },
      floorPowerOfTwo: function floorPowerOfTwo(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      },
      setQuaternionFromProperEuler: function setQuaternionFromProperEuler(q, a, b, c, order) {
        var cos = Math.cos;
        var sin = Math.sin;
        var c2 = cos(b / 2);
        var s2 = sin(b / 2);
        var c13 = cos((a + c) / 2);
        var s13 = sin((a + c) / 2);
        var c1_3 = cos((a - c) / 2);
        var s1_3 = sin((a - c) / 2);
        var c3_1 = cos((c - a) / 2);
        var s3_1 = sin((c - a) / 2);
        switch (order) {
          case "XYX":
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
          case "YZY":
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
          case "ZXZ":
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
          case "XZX":
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
          case "YXY":
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
          case "ZYZ":
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
    };
    var Vector22 = /* @__PURE__ */ function() {
      function Vector23(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this.x = x;
        this.y = y;
      }
      var _proto = Vector23.prototype;
      _proto.set = function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      };
      _proto.setScalar = function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      };
      _proto.setX = function setX(x) {
        this.x = x;
        return this;
      };
      _proto.setY = function setY(y) {
        this.y = y;
        return this;
      };
      _proto.setComponent = function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      };
      _proto.getComponent = function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
      };
      _proto.clone = function clone() {
        return new this.constructor(this.x, this.y);
      };
      _proto.copy = function copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      };
      _proto.add = function add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      };
      _proto.addScalar = function addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      };
      _proto.addVectors = function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      };
      _proto.addScaledVector = function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      };
      _proto.sub = function sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      };
      _proto.subScalar = function subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      };
      _proto.subVectors = function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      };
      _proto.multiply = function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      };
      _proto.divide = function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      };
      _proto.divideScalar = function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      };
      _proto.applyMatrix3 = function applyMatrix3(m) {
        var x = this.x, y = this.y;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
      };
      _proto.min = function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      };
      _proto.max = function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      };
      _proto.clamp = function clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      };
      _proto.clampScalar = function clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      };
      _proto.clampLength = function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      };
      _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      };
      _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      };
      _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      };
      _proto.roundToZero = function roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      };
      _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y;
      };
      _proto.cross = function cross(v) {
        return this.x * v.y - this.y * v.x;
      };
      _proto.lengthSq = function lengthSq() {
        return this.x * this.x + this.y * this.y;
      };
      _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };
      _proto.manhattanLength = function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      };
      _proto.normalize = function normalize() {
        return this.divideScalar(this.length() || 1);
      };
      _proto.angle = function angle() {
        var angle2 = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle2;
      };
      _proto.distanceTo = function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      };
      _proto.distanceToSquared = function distanceToSquared(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      };
      _proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      };
      _proto.setLength = function setLength(length) {
        return this.normalize().multiplyScalar(length);
      };
      _proto.lerp = function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      };
      _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      };
      _proto.equals = function equals3(v) {
        return v.x === this.x && v.y === this.y;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      };
      _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      };
      _proto.rotateAround = function rotateAround(center, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      };
      _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      };
      _createClass(Vector23, [{
        key: "width",
        get: function get() {
          return this.x;
        },
        set: function set(value) {
          this.x = value;
        }
      }, {
        key: "height",
        get: function get() {
          return this.y;
        },
        set: function set(value) {
          this.y = value;
        }
      }]);
      return Vector23;
    }();
    Vector22.prototype.isVector2 = true;
    var Matrix32 = /* @__PURE__ */ function() {
      function Matrix33() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (arguments.length > 0) {
          console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      var _proto = Matrix33.prototype;
      _proto.set = function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      };
      _proto.identity = function identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      };
      _proto.copy = function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      };
      _proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      };
      _proto.setFromMatrix4 = function setFromMatrix4(m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      };
      _proto.multiply = function multiply(m) {
        return this.multiplyMatrices(this, m);
      };
      _proto.premultiply = function premultiply(m) {
        return this.multiplyMatrices(m, this);
      };
      _proto.multiplyMatrices = function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[3], a13 = ae[6];
        var a21 = ae[1], a22 = ae[4], a23 = ae[7];
        var a31 = ae[2], a32 = ae[5], a33 = ae[8];
        var b11 = be[0], b12 = be[3], b13 = be[6];
        var b21 = be[1], b22 = be[4], b23 = be[7];
        var b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      };
      _proto.determinant = function determinant() {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
      };
      _proto.invert = function invert() {
        var te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      };
      _proto.transpose = function transpose() {
        var tmp3;
        var m = this.elements;
        tmp3 = m[1];
        m[1] = m[3];
        m[3] = tmp3;
        tmp3 = m[2];
        m[2] = m[6];
        m[6] = tmp3;
        tmp3 = m[5];
        m[5] = m[7];
        m[7] = tmp3;
        return this;
      };
      _proto.getNormalMatrix = function getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      };
      _proto.transposeIntoArray = function transposeIntoArray(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      };
      _proto.setUvTransform = function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        var c = Math.cos(rotation);
        var s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
      };
      _proto.scale = function scale(sx, sy) {
        var te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      };
      _proto.rotate = function rotate(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var te = this.elements;
        var a11 = te[0], a12 = te[3], a13 = te[6];
        var a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
      };
      _proto.translate = function translate(tx, ty) {
        var te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      };
      _proto.equals = function equals3(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        for (var i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      };
      _proto.clone = function clone() {
        return new this.constructor().fromArray(this.elements);
      };
      return Matrix33;
    }();
    Matrix32.prototype.isMatrix3 = true;
    var _canvas2;
    var ImageUtils2 = {
      getDataURL: function getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        var canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas2 === void 0)
            _canvas2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          _canvas2.width = image.width;
          _canvas2.height = image.height;
          var context = _canvas2.getContext("2d");
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas2;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
    };
    var textureId2 = 0;
    var Texture2 = /* @__PURE__ */ function(_EventDispatcher) {
      _inheritsLoose(Texture3, _EventDispatcher);
      function Texture3(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        var _this;
        if (image === void 0) {
          image = Texture3.DEFAULT_IMAGE;
        }
        if (mapping === void 0) {
          mapping = Texture3.DEFAULT_MAPPING;
        }
        if (wrapS === void 0) {
          wrapS = ClampToEdgeWrapping2;
        }
        if (wrapT === void 0) {
          wrapT = ClampToEdgeWrapping2;
        }
        if (magFilter === void 0) {
          magFilter = LinearFilter2;
        }
        if (minFilter === void 0) {
          minFilter = LinearMipmapLinearFilter2;
        }
        if (format === void 0) {
          format = RGBAFormat2;
        }
        if (type === void 0) {
          type = UnsignedByteType2;
        }
        if (anisotropy === void 0) {
          anisotropy = 1;
        }
        if (encoding === void 0) {
          encoding = LinearEncoding2;
        }
        _this = _EventDispatcher.call(this) || this;
        Object.defineProperty(_assertThisInitialized(_this), "id", {
          value: textureId2++
        });
        _this.uuid = MathUtils2.generateUUID();
        _this.name = "";
        _this.image = image;
        _this.mipmaps = [];
        _this.mapping = mapping;
        _this.wrapS = wrapS;
        _this.wrapT = wrapT;
        _this.magFilter = magFilter;
        _this.minFilter = minFilter;
        _this.anisotropy = anisotropy;
        _this.format = format;
        _this.internalFormat = null;
        _this.type = type;
        _this.offset = new Vector22(0, 0);
        _this.repeat = new Vector22(1, 1);
        _this.center = new Vector22(0, 0);
        _this.rotation = 0;
        _this.matrixAutoUpdate = true;
        _this.matrix = new Matrix32();
        _this.generateMipmaps = true;
        _this.premultiplyAlpha = false;
        _this.flipY = true;
        _this.unpackAlignment = 4;
        _this.encoding = encoding;
        _this.version = 0;
        _this.onUpdate = null;
        return _this;
      }
      var _proto = Texture3.prototype;
      _proto.updateMatrix = function updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.copy = function copy(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
      };
      _proto.toJSON = function toJSON2(meta) {
        var isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        var output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (this.image !== void 0) {
          var image = this.image;
          if (image.uuid === void 0) {
            image.uuid = MathUtils2.generateUUID();
          }
          if (!isRootObject && meta.images[image.uuid] === void 0) {
            var url;
            if (Array.isArray(image)) {
              url = [];
              for (var i2 = 0, l = image.length; i2 < l; i2++) {
                if (image[i2].isDataTexture) {
                  url.push(serializeImage2(image[i2].image));
                } else {
                  url.push(serializeImage2(image[i2]));
                }
              }
            } else {
              url = serializeImage2(image);
            }
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url
            };
          }
          output.image = image.uuid;
        }
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      };
      _proto.dispose = function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      };
      _proto.transformUv = function transformUv(uv) {
        if (this.mapping !== UVMapping2)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping2:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping2:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping2:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping2:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping2:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping2:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      };
      _createClass(Texture3, [{
        key: "needsUpdate",
        set: function set(value) {
          if (value === true)
            this.version++;
        }
      }]);
      return Texture3;
    }(EventDispatcher2);
    Texture2.DEFAULT_IMAGE = void 0;
    Texture2.DEFAULT_MAPPING = UVMapping2;
    Texture2.prototype.isTexture = true;
    function serializeImage2(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        return ImageUtils2.getDataURL(image);
      } else {
        if (image.data) {
          return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
          };
        } else {
          console.warn("THREE.Texture: Unable to serialize Texture.");
          return {};
        }
      }
    }
    var Vector42 = /* @__PURE__ */ function() {
      function Vector43(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (w === void 0) {
          w = 1;
        }
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      var _proto = Vector43.prototype;
      _proto.set = function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      };
      _proto.setScalar = function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      };
      _proto.setX = function setX(x) {
        this.x = x;
        return this;
      };
      _proto.setY = function setY(y) {
        this.y = y;
        return this;
      };
      _proto.setZ = function setZ(z) {
        this.z = z;
        return this;
      };
      _proto.setW = function setW(w) {
        this.w = w;
        return this;
      };
      _proto.setComponent = function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      };
      _proto.getComponent = function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index);
        }
      };
      _proto.clone = function clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      };
      _proto.copy = function copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== void 0 ? v.w : 1;
        return this;
      };
      _proto.add = function add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      };
      _proto.addScalar = function addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      };
      _proto.addVectors = function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      };
      _proto.addScaledVector = function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      };
      _proto.sub = function sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      };
      _proto.subScalar = function subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      };
      _proto.subVectors = function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      };
      _proto.multiply = function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      };
      _proto.applyMatrix4 = function applyMatrix4(m) {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      };
      _proto.divideScalar = function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      };
      _proto.setAxisAngleFromQuaternion = function setAxisAngleFromQuaternion(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      };
      _proto.setAxisAngleFromRotationMatrix = function setAxisAngleFromRotationMatrix(m) {
        var angle, x, y, z;
        var epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 1e-3)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      };
      _proto.min = function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      };
      _proto.max = function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      };
      _proto.clamp = function clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      };
      _proto.clampScalar = function clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      };
      _proto.clampLength = function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      };
      _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      };
      _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      };
      _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      };
      _proto.roundToZero = function roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      };
      _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      };
      _proto.lengthSq = function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      };
      _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      };
      _proto.manhattanLength = function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      };
      _proto.normalize = function normalize() {
        return this.divideScalar(this.length() || 1);
      };
      _proto.setLength = function setLength(length) {
        return this.normalize().multiplyScalar(length);
      };
      _proto.lerp = function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      };
      _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      };
      _proto.equals = function equals3(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      };
      _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
      };
      _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      };
      _createClass(Vector43, [{
        key: "width",
        get: function get() {
          return this.z;
        },
        set: function set(value) {
          this.z = value;
        }
      }, {
        key: "height",
        get: function get() {
          return this.w;
        },
        set: function set(value) {
          this.w = value;
        }
      }]);
      return Vector43;
    }();
    Vector42.prototype.isVector4 = true;
    var WebGLRenderTarget2 = /* @__PURE__ */ function(_EventDispatcher) {
      _inheritsLoose(WebGLRenderTarget3, _EventDispatcher);
      function WebGLRenderTarget3(width, height, options) {
        var _this;
        _this = _EventDispatcher.call(this) || this;
        _this.width = width;
        _this.height = height;
        _this.depth = 1;
        _this.scissor = new Vector42(0, 0, width, height);
        _this.scissorTest = false;
        _this.viewport = new Vector42(0, 0, width, height);
        options = options || {};
        _this.texture = new Texture2(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        _this.texture.image = {};
        _this.texture.image.width = width;
        _this.texture.image.height = height;
        _this.texture.image.depth = 1;
        _this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        _this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter2;
        _this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
        _this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
        _this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
        return _this;
      }
      var _proto = WebGLRenderTarget3.prototype;
      _proto.setTexture = function setTexture(texture) {
        texture.image = {
          width: this.width,
          height: this.height,
          depth: this.depth
        };
        this.texture = texture;
      };
      _proto.setSize = function setSize(width, height, depth) {
        if (depth === void 0) {
          depth = 1;
        }
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          this.texture.image.width = width;
          this.texture.image.height = height;
          this.texture.image.depth = depth;
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.copy = function copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
      };
      _proto.dispose = function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      };
      return WebGLRenderTarget3;
    }(EventDispatcher2);
    WebGLRenderTarget2.prototype.isWebGLRenderTarget = true;
    var WebGLMultisampleRenderTarget2 = /* @__PURE__ */ function(_WebGLRenderTarget) {
      _inheritsLoose(WebGLMultisampleRenderTarget3, _WebGLRenderTarget);
      function WebGLMultisampleRenderTarget3(width, height, options) {
        var _this;
        _this = _WebGLRenderTarget.call(this, width, height, options) || this;
        _this.samples = 4;
        return _this;
      }
      var _proto = WebGLMultisampleRenderTarget3.prototype;
      _proto.copy = function copy(source) {
        _WebGLRenderTarget.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
      };
      return WebGLMultisampleRenderTarget3;
    }(WebGLRenderTarget2);
    WebGLMultisampleRenderTarget2.prototype.isWebGLMultisampleRenderTarget = true;
    var Quaternion2 = /* @__PURE__ */ function() {
      function Quaternion3(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (w === void 0) {
          w = 1;
        }
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      Quaternion3.slerp = function slerp(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
      };
      Quaternion3.slerpFlat = function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          var s = 1 - t;
          var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t = Math.sin(t * len) / sin;
          }
          var tDir = t * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir;
          if (s === 1 - t) {
            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      };
      Quaternion3.multiplyQuaternionsFlat = function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        var x0 = src0[srcOffset0];
        var y0 = src0[srcOffset0 + 1];
        var z0 = src0[srcOffset0 + 2];
        var w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1];
        var y1 = src1[srcOffset1 + 1];
        var z1 = src1[srcOffset1 + 2];
        var w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      };
      var _proto = Quaternion3.prototype;
      _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      };
      _proto.copy = function copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      };
      _proto.setFromEuler = function setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        var x = euler._x, y = euler._y, z = euler._z, order = euler._order;
        var cos = Math.cos;
        var sin = Math.sin;
        var c1 = cos(x / 2);
        var c2 = cos(y / 2);
        var c3 = cos(z / 2);
        var s1 = sin(x / 2);
        var s2 = sin(y / 2);
        var s3 = sin(z / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false)
          this._onChangeCallback();
        return this;
      };
      _proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      };
      _proto.setFromRotationMatrix = function setFromRotationMatrix(m) {
        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
          var s = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          var _s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / _s;
          this._x = 0.25 * _s;
          this._y = (m12 + m21) / _s;
          this._z = (m13 + m31) / _s;
        } else if (m22 > m33) {
          var _s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / _s2;
          this._x = (m12 + m21) / _s2;
          this._y = 0.25 * _s2;
          this._z = (m23 + m32) / _s2;
        } else {
          var _s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / _s3;
          this._x = (m13 + m31) / _s3;
          this._y = (m23 + m32) / _s3;
          this._z = 0.25 * _s3;
        }
        this._onChangeCallback();
        return this;
      };
      _proto.setFromUnitVectors = function setFromUnitVectors(vFrom, vTo) {
        var EPS = 1e-6;
        var r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
          r = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r;
        }
        return this.normalize();
      };
      _proto.angleTo = function angleTo(q) {
        return 2 * Math.acos(Math.abs(MathUtils2.clamp(this.dot(q), -1, 1)));
      };
      _proto.rotateTowards = function rotateTowards(q, step) {
        var angle = this.angleTo(q);
        if (angle === 0)
          return this;
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
      };
      _proto.identity = function identity() {
        return this.set(0, 0, 0, 1);
      };
      _proto.invert = function invert() {
        return this.conjugate();
      };
      _proto.conjugate = function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      };
      _proto.dot = function dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      };
      _proto.lengthSq = function lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      };
      _proto.length = function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      };
      _proto.normalize = function normalize() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      };
      _proto.multiply = function multiply(q, p) {
        if (p !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      };
      _proto.premultiply = function premultiply(q) {
        return this.multiplyQuaternions(q, this);
      };
      _proto.multiplyQuaternions = function multiplyQuaternions(a, b) {
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      };
      _proto.slerp = function slerp(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          var s = 1 - t;
          this._w = s * w + t * this._w;
          this._x = s * x + t * this._x;
          this._y = s * y + t * this._y;
          this._z = s * z + t * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      };
      _proto.equals = function equals3(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      };
      _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
      };
      _proto._onChange = function _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      };
      _proto._onChangeCallback = function _onChangeCallback() {
      };
      _createClass(Quaternion3, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onChangeCallback();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onChangeCallback();
        }
      }, {
        key: "z",
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value;
          this._onChangeCallback();
        }
      }, {
        key: "w",
        get: function get() {
          return this._w;
        },
        set: function set(value) {
          this._w = value;
          this._onChangeCallback();
        }
      }]);
      return Quaternion3;
    }();
    Quaternion2.prototype.isQuaternion = true;
    var Vector32 = /* @__PURE__ */ function() {
      function Vector33(x, y, z) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this.x = x;
        this.y = y;
        this.z = z;
      }
      var _proto = Vector33.prototype;
      _proto.set = function set(x, y, z) {
        if (z === void 0)
          z = this.z;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };
      _proto.setScalar = function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      };
      _proto.setX = function setX(x) {
        this.x = x;
        return this;
      };
      _proto.setY = function setY(y) {
        this.y = y;
        return this;
      };
      _proto.setZ = function setZ(z) {
        this.z = z;
        return this;
      };
      _proto.setComponent = function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      };
      _proto.getComponent = function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index);
        }
      };
      _proto.clone = function clone() {
        return new this.constructor(this.x, this.y, this.z);
      };
      _proto.copy = function copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      };
      _proto.add = function add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      };
      _proto.addScalar = function addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      };
      _proto.addVectors = function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      };
      _proto.addScaledVector = function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      };
      _proto.sub = function sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      };
      _proto.subScalar = function subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      };
      _proto.subVectors = function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      };
      _proto.multiply = function multiply(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      };
      _proto.multiplyVectors = function multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      };
      _proto.applyEuler = function applyEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion2.setFromEuler(euler));
      };
      _proto.applyAxisAngle = function applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion2.setFromAxisAngle(axis, angle));
      };
      _proto.applyMatrix3 = function applyMatrix3(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      };
      _proto.applyNormalMatrix = function applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      };
      _proto.applyMatrix4 = function applyMatrix4(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
      };
      _proto.applyQuaternion = function applyQuaternion(q) {
        var x = this.x, y = this.y, z = this.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      };
      _proto.project = function project(camera2) {
        return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
      };
      _proto.unproject = function unproject(camera2) {
        return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
      };
      _proto.transformDirection = function transformDirection(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      };
      _proto.divide = function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      };
      _proto.divideScalar = function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      };
      _proto.min = function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      };
      _proto.max = function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      };
      _proto.clamp = function clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      };
      _proto.clampScalar = function clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      };
      _proto.clampLength = function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      };
      _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      };
      _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      };
      _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      };
      _proto.roundToZero = function roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      };
      _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };
      _proto.lengthSq = function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      };
      _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };
      _proto.manhattanLength = function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      };
      _proto.normalize = function normalize() {
        return this.divideScalar(this.length() || 1);
      };
      _proto.setLength = function setLength(length) {
        return this.normalize().multiplyScalar(length);
      };
      _proto.lerp = function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      };
      _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      };
      _proto.cross = function cross(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
      };
      _proto.crossVectors = function crossVectors(a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      };
      _proto.projectOnVector = function projectOnVector(v) {
        var denominator = v.lengthSq();
        if (denominator === 0)
          return this.set(0, 0, 0);
        var scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
      };
      _proto.projectOnPlane = function projectOnPlane(planeNormal) {
        _vector3.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector3);
      };
      _proto.reflect = function reflect(normal) {
        return this.sub(_vector3.copy(normal).multiplyScalar(2 * this.dot(normal)));
      };
      _proto.angleTo = function angleTo(v) {
        var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0)
          return Math.PI / 2;
        var theta = this.dot(v) / denominator;
        return Math.acos(MathUtils2.clamp(theta, -1, 1));
      };
      _proto.distanceTo = function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      };
      _proto.distanceToSquared = function distanceToSquared(v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      };
      _proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      };
      _proto.setFromSpherical = function setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      };
      _proto.setFromSphericalCoords = function setFromSphericalCoords(radius, phi, theta) {
        var sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      };
      _proto.setFromCylindrical = function setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      };
      _proto.setFromCylindricalCoords = function setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
      };
      _proto.setFromMatrixPosition = function setFromMatrixPosition(m) {
        var e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      };
      _proto.setFromMatrixScale = function setFromMatrixScale(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      };
      _proto.setFromMatrixColumn = function setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      };
      _proto.setFromMatrix3Column = function setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
      };
      _proto.equals = function equals3(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      };
      _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
      };
      _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      };
      return Vector33;
    }();
    Vector32.prototype.isVector3 = true;
    var _vector3 = /* @__PURE__ */ new Vector32();
    var _quaternion2 = /* @__PURE__ */ new Quaternion2();
    var Box32 = /* @__PURE__ */ function() {
      function Box33(min, max) {
        if (min === void 0) {
          min = new Vector32(Infinity, Infinity, Infinity);
        }
        if (max === void 0) {
          max = new Vector32(-Infinity, -Infinity, -Infinity);
        }
        this.min = min;
        this.max = max;
      }
      var _proto = Box33.prototype;
      _proto.set = function set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      };
      _proto.setFromArray = function setFromArray(array) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i2 = 0, l = array.length; i2 < l; i2 += 3) {
          var x = array[i2];
          var y = array[i2 + 1];
          var z = array[i2 + 2];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      };
      _proto.setFromBufferAttribute = function setFromBufferAttribute(attribute) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i2 = 0, l = attribute.count; i2 < l; i2++) {
          var x = attribute.getX(i2);
          var y = attribute.getY(i2);
          var z = attribute.getZ(i2);
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      };
      _proto.setFromPoints = function setFromPoints(points) {
        this.makeEmpty();
        for (var i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      };
      _proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
        var halfSize = _vector$12.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
      _proto.setFromObject = function setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.copy = function copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      };
      _proto.makeEmpty = function makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      };
      _proto.isEmpty = function isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      };
      _proto.getCenter = function getCenter(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getCenter() target is now required");
          target = new Vector32();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      };
      _proto.getSize = function getSize(target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getSize() target is now required");
          target = new Vector32();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      };
      _proto.expandByPoint = function expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      };
      _proto.expandByVector = function expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      };
      _proto.expandByScalar = function expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      };
      _proto.expandByObject = function expandByObject(object) {
        object.updateWorldMatrix(false, false);
        var geometry = object.geometry;
        if (geometry !== void 0) {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box2.copy(geometry.boundingBox);
          _box2.applyMatrix4(object.matrixWorld);
          this.union(_box2);
        }
        var children = object.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          this.expandByObject(children[i2]);
        }
        return this;
      };
      _proto.containsPoint = function containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      };
      _proto.containsBox = function containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      };
      _proto.getParameter = function getParameter(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .getParameter() target is now required");
          target = new Vector32();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector$12);
        return _vector$12.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      };
      _proto.intersectsPlane = function intersectsPlane(plane) {
        var min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      };
      _proto.intersectsTriangle = function intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center2);
        _extents2.subVectors(this.max, _center2);
        _v02.subVectors(triangle.a, _center2);
        _v12.subVectors(triangle.b, _center2);
        _v22.subVectors(triangle.c, _center2);
        _f02.subVectors(_v12, _v02);
        _f12.subVectors(_v22, _v12);
        _f22.subVectors(_v02, _v22);
        var axes = [0, -_f02.z, _f02.y, 0, -_f12.z, _f12.y, 0, -_f22.z, _f22.y, _f02.z, 0, -_f02.x, _f12.z, 0, -_f12.x, _f22.z, 0, -_f22.x, -_f02.y, _f02.x, 0, -_f12.y, _f12.x, 0, -_f22.y, _f22.x, 0];
        if (!satForAxes2(axes, _v02, _v12, _v22, _extents2)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes2(axes, _v02, _v12, _v22, _extents2)) {
          return false;
        }
        _triangleNormal2.crossVectors(_f02, _f12);
        axes = [_triangleNormal2.x, _triangleNormal2.y, _triangleNormal2.z];
        return satForAxes2(axes, _v02, _v12, _v22, _extents2);
      };
      _proto.clampPoint = function clampPoint(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box3: .clampPoint() target is now required");
          target = new Vector32();
        }
        return target.copy(point).clamp(this.min, this.max);
      };
      _proto.distanceToPoint = function distanceToPoint(point) {
        var clampedPoint = _vector$12.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
      _proto.getBoundingSphere = function getBoundingSphere(target) {
        if (target === void 0) {
          console.error("THREE.Box3: .getBoundingSphere() target is now required");
        }
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$12).length() * 0.5;
        return target;
      };
      _proto.intersect = function intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      };
      _proto.union = function union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      };
      _proto.applyMatrix4 = function applyMatrix4(matrix) {
        if (this.isEmpty())
          return this;
        _points2[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points2[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points2[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points2[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points2[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points2[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points2[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points2[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points2);
        return this;
      };
      _proto.translate = function translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      };
      _proto.equals = function equals3(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      };
      return Box33;
    }();
    Box32.prototype.isBox3 = true;
    var _points2 = [/* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32()];
    var _vector$12 = /* @__PURE__ */ new Vector32();
    var _box2 = /* @__PURE__ */ new Box32();
    var _v02 = /* @__PURE__ */ new Vector32();
    var _v12 = /* @__PURE__ */ new Vector32();
    var _v22 = /* @__PURE__ */ new Vector32();
    var _f02 = /* @__PURE__ */ new Vector32();
    var _f12 = /* @__PURE__ */ new Vector32();
    var _f22 = /* @__PURE__ */ new Vector32();
    var _center2 = /* @__PURE__ */ new Vector32();
    var _extents2 = /* @__PURE__ */ new Vector32();
    var _triangleNormal2 = /* @__PURE__ */ new Vector32();
    var _testAxis2 = /* @__PURE__ */ new Vector32();
    function satForAxes2(axes, v0, v1, v2, extents) {
      for (var i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
        _testAxis2.fromArray(axes, i2);
        var r = extents.x * Math.abs(_testAxis2.x) + extents.y * Math.abs(_testAxis2.y) + extents.z * Math.abs(_testAxis2.z);
        var p0 = v0.dot(_testAxis2);
        var p1 = v1.dot(_testAxis2);
        var p2 = v2.dot(_testAxis2);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          return false;
        }
      }
      return true;
    }
    var _box$12 = /* @__PURE__ */ new Box32();
    var Sphere2 = /* @__PURE__ */ function() {
      function Sphere3(center, radius) {
        if (center === void 0) {
          center = new Vector32();
        }
        if (radius === void 0) {
          radius = -1;
        }
        this.center = center;
        this.radius = radius;
      }
      var _proto = Sphere3.prototype;
      _proto.set = function set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      };
      _proto.setFromPoints = function setFromPoints(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$12.setFromPoints(points).getCenter(center);
        }
        var maxRadiusSq = 0;
        for (var i2 = 0, il = points.length; i2 < il; i2++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      };
      _proto.copy = function copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      };
      _proto.isEmpty = function isEmpty() {
        return this.radius < 0;
      };
      _proto.makeEmpty = function makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      };
      _proto.containsPoint = function containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      };
      _proto.distanceToPoint = function distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return box.intersectsSphere(this);
      };
      _proto.intersectsPlane = function intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      };
      _proto.clampPoint = function clampPoint(point, target) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        if (target === void 0) {
          console.warn("THREE.Sphere: .clampPoint() target is now required");
          target = new Vector32();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      };
      _proto.getBoundingBox = function getBoundingBox(target) {
        if (target === void 0) {
          console.warn("THREE.Sphere: .getBoundingBox() target is now required");
          target = new Box32();
        }
        if (this.isEmpty()) {
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      };
      _proto.applyMatrix4 = function applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      };
      _proto.translate = function translate(offset) {
        this.center.add(offset);
        return this;
      };
      _proto.equals = function equals3(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Sphere3;
    }();
    var _vector$22 = /* @__PURE__ */ new Vector32();
    var _segCenter2 = /* @__PURE__ */ new Vector32();
    var _segDir2 = /* @__PURE__ */ new Vector32();
    var _diff2 = /* @__PURE__ */ new Vector32();
    var _edge12 = /* @__PURE__ */ new Vector32();
    var _edge22 = /* @__PURE__ */ new Vector32();
    var _normal2 = /* @__PURE__ */ new Vector32();
    var Ray2 = /* @__PURE__ */ function() {
      function Ray3(origin, direction) {
        if (origin === void 0) {
          origin = new Vector32();
        }
        if (direction === void 0) {
          direction = new Vector32(0, 0, -1);
        }
        this.origin = origin;
        this.direction = direction;
      }
      var _proto = Ray3.prototype;
      _proto.set = function set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      };
      _proto.copy = function copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      };
      _proto.at = function at(t, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .at() target is now required");
          target = new Vector32();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
      };
      _proto.lookAt = function lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      };
      _proto.recast = function recast(t) {
        this.origin.copy(this.at(t, _vector$22));
        return this;
      };
      _proto.closestPointToPoint = function closestPointToPoint(point, target) {
        if (target === void 0) {
          console.warn("THREE.Ray: .closestPointToPoint() target is now required");
          target = new Vector32();
        }
        target.subVectors(point, this.origin);
        var directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      };
      _proto.distanceToPoint = function distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      };
      _proto.distanceSqToPoint = function distanceSqToPoint(point) {
        var directionDistance = _vector$22.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$22.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$22.distanceToSquared(point);
      };
      _proto.distanceSqToSegment = function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter2.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir2.copy(v1).sub(v0).normalize();
        _diff2.copy(this.origin).sub(_segCenter2);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(_segDir2);
        var b0 = _diff2.dot(this.direction);
        var b1 = -_diff2.dot(_segDir2);
        var c = _diff2.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir2).multiplyScalar(s1).add(_segCenter2);
        }
        return sqrDist;
      };
      _proto.intersectSphere = function intersectSphere(sphere, target) {
        _vector$22.subVectors(sphere.center, this.origin);
        var tca = _vector$22.dot(this.direction);
        var d2 = _vector$22.dot(_vector$22) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        var thc = Math.sqrt(radius2 - d2);
        var t0 = tca - thc;
        var t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      };
      _proto.distanceToPlane = function distanceToPlane(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      };
      _proto.intersectPlane = function intersectPlane(plane, target) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, target);
      };
      _proto.intersectsPlane = function intersectsPlane(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      };
      _proto.intersectBox = function intersectBox(box, target) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return this.intersectBox(box, _vector$22) !== null;
      };
      _proto.intersectTriangle = function intersectTriangle(a, b, c, backfaceCulling, target) {
        _edge12.subVectors(b, a);
        _edge22.subVectors(c, a);
        _normal2.crossVectors(_edge12, _edge22);
        var DdN = this.direction.dot(_normal2);
        var sign3;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign3 = 1;
        } else if (DdN < 0) {
          sign3 = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff2.subVectors(this.origin, a);
        var DdQxE2 = sign3 * this.direction.dot(_edge22.crossVectors(_diff2, _edge22));
        if (DdQxE2 < 0) {
          return null;
        }
        var DdE1xQ = sign3 * this.direction.dot(_edge12.cross(_diff2));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        var QdN = -sign3 * _diff2.dot(_normal2);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      };
      _proto.applyMatrix4 = function applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      };
      _proto.equals = function equals3(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Ray3;
    }();
    var Matrix43 = /* @__PURE__ */ function() {
      function Matrix44() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        if (arguments.length > 0) {
          console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      var _proto = Matrix44.prototype;
      _proto.set = function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      };
      _proto.identity = function identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.clone = function clone() {
        return new Matrix44().fromArray(this.elements);
      };
      _proto.copy = function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      };
      _proto.copyPosition = function copyPosition(m) {
        var te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      };
      _proto.setFromMatrix3 = function setFromMatrix3(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
      };
      _proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      };
      _proto.makeBasis = function makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.extractRotation = function extractRotation(m) {
        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / _v1$12.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / _v1$12.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / _v1$12.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      };
      _proto.makeRotationFromEuler = function makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        var te = this.elements;
        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y), d = Math.sin(y);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
          var ae = a * e, af = a * f, be = b * e, bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          var ce = c * e, cf = c * f, de = d * e, df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          var _ce = c * e, _cf = c * f, _de = d * e, _df = d * f;
          te[0] = _ce - _df * b;
          te[4] = -a * f;
          te[8] = _de + _cf * b;
          te[1] = _cf + _de * b;
          te[5] = a * e;
          te[9] = _df - _ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          var _ae = a * e, _af = a * f, _be = b * e, _bf = b * f;
          te[0] = c * e;
          te[4] = _be * d - _af;
          te[8] = _ae * d + _bf;
          te[1] = c * f;
          te[5] = _bf * d + _ae;
          te[9] = _af * d - _be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
          var _ac = a * c, _ad = a * d, _bc = b * c, _bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = _ac * f + _bd;
          te[5] = a * e;
          te[9] = _ad * f - _bc;
          te[2] = _bc * f - _ad;
          te[6] = b * e;
          te[10] = _bd * f + _ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      };
      _proto.makeRotationFromQuaternion = function makeRotationFromQuaternion(q) {
        return this.compose(_zero2, q, _one2);
      };
      _proto.lookAt = function lookAt(eye, target, up) {
        var te = this.elements;
        _z2.subVectors(eye, target);
        if (_z2.lengthSq() === 0) {
          _z2.z = 1;
        }
        _z2.normalize();
        _x2.crossVectors(up, _z2);
        if (_x2.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z2.x += 1e-4;
          } else {
            _z2.z += 1e-4;
          }
          _z2.normalize();
          _x2.crossVectors(up, _z2);
        }
        _x2.normalize();
        _y2.crossVectors(_z2, _x2);
        te[0] = _x2.x;
        te[4] = _y2.x;
        te[8] = _z2.x;
        te[1] = _x2.y;
        te[5] = _y2.y;
        te[9] = _z2.y;
        te[2] = _x2.z;
        te[6] = _y2.z;
        te[10] = _z2.z;
        return this;
      };
      _proto.multiply = function multiply(m, n) {
        if (n !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      };
      _proto.premultiply = function premultiply(m) {
        return this.multiplyMatrices(m, this);
      };
      _proto.multiplyMatrices = function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      };
      _proto.determinant = function determinant() {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      };
      _proto.transpose = function transpose() {
        var te = this.elements;
        var tmp3;
        tmp3 = te[1];
        te[1] = te[4];
        te[4] = tmp3;
        tmp3 = te[2];
        te[2] = te[8];
        te[8] = tmp3;
        tmp3 = te[6];
        te[6] = te[9];
        te[9] = tmp3;
        tmp3 = te[3];
        te[3] = te[12];
        te[12] = tmp3;
        tmp3 = te[7];
        te[7] = te[13];
        te[13] = tmp3;
        tmp3 = te[11];
        te[11] = te[14];
        te[14] = tmp3;
        return this;
      };
      _proto.setPosition = function setPosition(x, y, z) {
        var te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y;
          te[14] = z;
        }
        return this;
      };
      _proto.invert = function invert() {
        var te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      };
      _proto.scale = function scale(v) {
        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      };
      _proto.getMaxScaleOnAxis = function getMaxScaleOnAxis() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      };
      _proto.makeTranslation = function makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      };
      _proto.makeRotationX = function makeRotationX(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.makeRotationY = function makeRotationY(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.makeRotationZ = function makeRotationZ(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.makeRotationAxis = function makeRotationAxis(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.makeScale = function makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.makeShear = function makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
      };
      _proto.compose = function compose(position, quaternion, scale) {
        var te = this.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        var sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      };
      _proto.decompose = function decompose(position, quaternion, scale) {
        var te = this.elements;
        var sx = _v1$12.set(te[0], te[1], te[2]).length();
        var sy = _v1$12.set(te[4], te[5], te[6]).length();
        var sz = _v1$12.set(te[8], te[9], te[10]).length();
        var det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m12.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        _m12.elements[0] *= invSX;
        _m12.elements[1] *= invSX;
        _m12.elements[2] *= invSX;
        _m12.elements[4] *= invSY;
        _m12.elements[5] *= invSY;
        _m12.elements[6] *= invSY;
        _m12.elements[8] *= invSZ;
        _m12.elements[9] *= invSZ;
        _m12.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m12);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      };
      _proto.makePerspective = function makePerspective(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      };
      _proto.makeOrthographic = function makeOrthographic(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1 / (right - left);
        var h = 1 / (top - bottom);
        var p = 1 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      };
      _proto.equals = function equals3(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i2 = 0; i2 < 16; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        for (var i2 = 0; i2 < 16; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      };
      return Matrix44;
    }();
    Matrix43.prototype.isMatrix4 = true;
    var _v1$12 = /* @__PURE__ */ new Vector32();
    var _m12 = /* @__PURE__ */ new Matrix43();
    var _zero2 = /* @__PURE__ */ new Vector32(0, 0, 0);
    var _one2 = /* @__PURE__ */ new Vector32(1, 1, 1);
    var _x2 = /* @__PURE__ */ new Vector32();
    var _y2 = /* @__PURE__ */ new Vector32();
    var _z2 = /* @__PURE__ */ new Vector32();
    var _matrix2 = /* @__PURE__ */ new Matrix43();
    var _quaternion$12 = /* @__PURE__ */ new Quaternion2();
    var Euler2 = /* @__PURE__ */ function() {
      function Euler3(x, y, z, order) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (order === void 0) {
          order = Euler3.DefaultOrder;
        }
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
      }
      var _proto = Euler3.prototype;
      _proto.set = function set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      };
      _proto.copy = function copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      };
      _proto.setFromRotationMatrix = function setFromRotationMatrix(m, order, update) {
        var clamp = MathUtils2.clamp;
        var te = m.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update !== false)
          this._onChangeCallback();
        return this;
      };
      _proto.setFromQuaternion = function setFromQuaternion(q, order, update) {
        _matrix2.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix2, order, update);
      };
      _proto.setFromVector3 = function setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      };
      _proto.reorder = function reorder(newOrder) {
        _quaternion$12.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$12, newOrder);
      };
      _proto.equals = function equals3(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      };
      _proto.fromArray = function fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0)
          this._order = array[3];
        this._onChangeCallback();
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      };
      _proto.toVector3 = function toVector3(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new Vector32(this._x, this._y, this._z);
        }
      };
      _proto._onChange = function _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      };
      _proto._onChangeCallback = function _onChangeCallback() {
      };
      _createClass(Euler3, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this._x = value;
          this._onChangeCallback();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this._y = value;
          this._onChangeCallback();
        }
      }, {
        key: "z",
        get: function get() {
          return this._z;
        },
        set: function set(value) {
          this._z = value;
          this._onChangeCallback();
        }
      }, {
        key: "order",
        get: function get() {
          return this._order;
        },
        set: function set(value) {
          this._order = value;
          this._onChangeCallback();
        }
      }]);
      return Euler3;
    }();
    Euler2.prototype.isEuler = true;
    Euler2.DefaultOrder = "XYZ";
    Euler2.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    var Layers2 = /* @__PURE__ */ function() {
      function Layers3() {
        this.mask = 1 | 0;
      }
      var _proto = Layers3.prototype;
      _proto.set = function set(channel) {
        this.mask = 1 << channel | 0;
      };
      _proto.enable = function enable(channel) {
        this.mask |= 1 << channel | 0;
      };
      _proto.enableAll = function enableAll() {
        this.mask = 4294967295 | 0;
      };
      _proto.toggle = function toggle(channel) {
        this.mask ^= 1 << channel | 0;
      };
      _proto.disable = function disable(channel) {
        this.mask &= ~(1 << channel | 0);
      };
      _proto.disableAll = function disableAll() {
        this.mask = 0;
      };
      _proto.test = function test(layers) {
        return (this.mask & layers.mask) !== 0;
      };
      return Layers3;
    }();
    var _object3DId2 = 0;
    var _v1$22 = new Vector32();
    var _q12 = new Quaternion2();
    var _m1$12 = new Matrix43();
    var _target2 = new Vector32();
    var _position2 = new Vector32();
    var _scale2 = new Vector32();
    var _quaternion$22 = new Quaternion2();
    var _xAxis2 = new Vector32(1, 0, 0);
    var _yAxis2 = new Vector32(0, 1, 0);
    var _zAxis2 = new Vector32(0, 0, 1);
    var _addedEvent2 = {
      type: "added"
    };
    var _removedEvent2 = {
      type: "removed"
    };
    function Object3D2() {
      Object.defineProperty(this, "id", {
        value: _object3DId2++
      });
      this.uuid = MathUtils2.generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D2.DefaultUp.clone();
      var position = new Vector32();
      var rotation = new Euler2();
      var quaternion = new Quaternion2();
      var scale = new Vector32(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix43()
        },
        normalMatrix: {
          value: new Matrix32()
        }
      });
      this.matrix = new Matrix43();
      this.matrixWorld = new Matrix43();
      this.matrixAutoUpdate = Object3D2.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers2();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    Object3D2.DefaultUp = new Vector32(0, 1, 0);
    Object3D2.DefaultMatrixAutoUpdate = true;
    Object3D2.prototype = Object.assign(Object.create(EventDispatcher2.prototype), {
      constructor: Object3D2,
      isObject3D: true,
      onBeforeRender: function onBeforeRender() {
      },
      onAfterRender: function onAfterRender() {
      },
      applyMatrix4: function applyMatrix4(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
      },
      setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
      },
      setRotationFromQuaternion: function setRotationFromQuaternion(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function rotateOnAxis(axis, angle) {
        _q12.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q12);
        return this;
      },
      rotateOnWorldAxis: function rotateOnWorldAxis(axis, angle) {
        _q12.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q12);
        return this;
      },
      rotateX: function rotateX(angle) {
        return this.rotateOnAxis(_xAxis2, angle);
      },
      rotateY: function rotateY(angle) {
        return this.rotateOnAxis(_yAxis2, angle);
      },
      rotateZ: function rotateZ(angle) {
        return this.rotateOnAxis(_zAxis2, angle);
      },
      translateOnAxis: function translateOnAxis(axis, distance) {
        _v1$22.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$22.multiplyScalar(distance));
        return this;
      },
      translateX: function translateX(distance) {
        return this.translateOnAxis(_xAxis2, distance);
      },
      translateY: function translateY(distance) {
        return this.translateOnAxis(_yAxis2, distance);
      },
      translateZ: function translateZ(distance) {
        return this.translateOnAxis(_zAxis2, distance);
      },
      localToWorld: function localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function worldToLocal(vector) {
        return vector.applyMatrix4(_m1$12.copy(this.matrixWorld).invert());
      },
      lookAt: function lookAt(x, y, z) {
        if (x.isVector3) {
          _target2.copy(x);
        } else {
          _target2.set(x, y, z);
        }
        var parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position2.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$12.lookAt(_position2, _target2, this.up);
        } else {
          _m1$12.lookAt(_target2, _position2, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$12);
        if (parent) {
          _m1$12.extractRotation(parent.matrixWorld);
          _q12.setFromRotationMatrix(_m1$12);
          this.quaternion.premultiply(_q12.invert());
        }
      },
      add: function add(object) {
        if (arguments.length > 1) {
          for (var i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent2);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function remove(object) {
        if (arguments.length > 1) {
          for (var i2 = 0; i2 < arguments.length; i2++) {
            this.remove(arguments[i2]);
          }
          return this;
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          this.children.splice(index, 1);
          object.dispatchEvent(_removedEvent2);
        }
        return this;
      },
      clear: function clear() {
        for (var i2 = 0; i2 < this.children.length; i2++) {
          var object = this.children[i2];
          object.parent = null;
          object.dispatchEvent(_removedEvent2);
        }
        this.children.length = 0;
        return this;
      },
      attach: function attach(object) {
        this.updateWorldMatrix(true, false);
        _m1$12.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$12.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$12);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
      },
      getObjectById: function getObjectById(id) {
        return this.getObjectByProperty("id", id);
      },
      getObjectByName: function getObjectByName(name2) {
        return this.getObjectByProperty("name", name2);
      },
      getObjectByProperty: function getObjectByProperty(name2, value) {
        if (this[name2] === value)
          return this;
        for (var i2 = 0, l = this.children.length; i2 < l; i2++) {
          var child = this.children[i2];
          var object = child.getObjectByProperty(name2, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      },
      getWorldPosition: function getWorldPosition(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldPosition() target is now required");
          target = new Vector32();
        }
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function getWorldQuaternion(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
          target = new Quaternion2();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position2, target, _scale2);
        return target;
      },
      getWorldScale: function getWorldScale(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldScale() target is now required");
          target = new Vector32();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position2, _quaternion$22, target);
        return target;
      },
      getWorldDirection: function getWorldDirection(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldDirection() target is now required");
          target = new Vector32();
        }
        this.updateWorldMatrix(true, false);
        var e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
      },
      raycast: function raycast() {
      },
      traverse: function traverse(callback) {
        callback(this);
        var children = this.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverse(callback);
        }
      },
      traverseVisible: function traverseVisible(callback) {
        if (this.visible === false)
          return;
        callback(this);
        var children = this.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverseVisible(callback);
        }
      },
      traverseAncestors: function traverseAncestors(callback) {
        var parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function updateMatrixWorld(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        var children = this.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].updateMatrixWorld(force);
        }
      },
      updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
        var parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          var children = this.children;
          for (var i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateWorldMatrix(false, true);
          }
        }
      },
      toJSON: function toJSON2(meta) {
        var isRootObject = meta === void 0 || typeof meta === "string";
        var output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        function serialize(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          var parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            var shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (var i2 = 0, l = shapes.length; i2 < l; i2++) {
                var shape = shapes[i2];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== void 0) {
            serialize(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            var uuids = [];
            for (var _i = 0, _l = this.material.length; _i < _l; _i++) {
              uuids.push(serialize(meta.materials, this.material[_i]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (var _i2 = 0; _i2 < this.children.length; _i2++) {
            object.children.push(this.children[_i2].toJSON(meta).object);
          }
        }
        if (this.animations.length > 0) {
          object.animations = [];
          for (var _i3 = 0; _i3 < this.animations.length; _i3++) {
            var animation = this.animations[_i3];
            object.animations.push(serialize(meta.animations, animation));
          }
        }
        if (isRootObject) {
          var geometries = extractFromCache(meta.geometries);
          var materials = extractFromCache(meta.materials);
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          var _shapes = extractFromCache(meta.shapes);
          var skeletons = extractFromCache(meta.skeletons);
          var animations = extractFromCache(meta.animations);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (_shapes.length > 0)
            output.shapes = _shapes;
          if (skeletons.length > 0)
            output.skeletons = skeletons;
          if (animations.length > 0)
            output.animations = animations;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      },
      clone: function clone(recursive) {
        return new this.constructor().copy(this, recursive);
      },
      copy: function copy(source, recursive) {
        if (recursive === void 0) {
          recursive = true;
        }
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (var i2 = 0; i2 < source.children.length; i2++) {
            var child = source.children[i2];
            this.add(child.clone());
          }
        }
        return this;
      }
    });
    var _vector12 = /* @__PURE__ */ new Vector32();
    var _vector22 = /* @__PURE__ */ new Vector32();
    var _normalMatrix2 = /* @__PURE__ */ new Matrix32();
    var Plane2 = /* @__PURE__ */ function() {
      function Plane3(normal, constant) {
        if (normal === void 0) {
          normal = new Vector32(1, 0, 0);
        }
        if (constant === void 0) {
          constant = 0;
        }
        this.normal = normal;
        this.constant = constant;
      }
      var _proto = Plane3.prototype;
      _proto.set = function set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      };
      _proto.setComponents = function setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      };
      _proto.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      };
      _proto.setFromCoplanarPoints = function setFromCoplanarPoints(a, b, c) {
        var normal = _vector12.subVectors(c, b).cross(_vector22.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      };
      _proto.copy = function copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      };
      _proto.normalize = function normalize() {
        var inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      };
      _proto.negate = function negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      };
      _proto.distanceToPoint = function distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      };
      _proto.distanceToSphere = function distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      };
      _proto.projectPoint = function projectPoint(point, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .projectPoint() target is now required");
          target = new Vector32();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      };
      _proto.intersectLine = function intersectLine(line, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .intersectLine() target is now required");
          target = new Vector32();
        }
        var direction = line.delta(_vector12);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return void 0;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return void 0;
        }
        return target.copy(direction).multiplyScalar(t).add(line.start);
      };
      _proto.intersectsLine = function intersectsLine(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return box.intersectsPlane(this);
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      };
      _proto.coplanarPoint = function coplanarPoint(target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .coplanarPoint() target is now required");
          target = new Vector32();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
      };
      _proto.applyMatrix4 = function applyMatrix4(matrix, optionalNormalMatrix) {
        var normalMatrix = optionalNormalMatrix || _normalMatrix2.getNormalMatrix(matrix);
        var referencePoint = this.coplanarPoint(_vector12).applyMatrix4(matrix);
        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      };
      _proto.translate = function translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      };
      _proto.equals = function equals3(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Plane3;
    }();
    Plane2.prototype.isPlane = true;
    var _v0$12 = /* @__PURE__ */ new Vector32();
    var _v1$32 = /* @__PURE__ */ new Vector32();
    var _v2$12 = /* @__PURE__ */ new Vector32();
    var _v32 = /* @__PURE__ */ new Vector32();
    var _vab2 = /* @__PURE__ */ new Vector32();
    var _vac2 = /* @__PURE__ */ new Vector32();
    var _vbc2 = /* @__PURE__ */ new Vector32();
    var _vap2 = /* @__PURE__ */ new Vector32();
    var _vbp2 = /* @__PURE__ */ new Vector32();
    var _vcp2 = /* @__PURE__ */ new Vector32();
    var Triangle2 = /* @__PURE__ */ function() {
      function Triangle3(a, b, c) {
        if (a === void 0) {
          a = new Vector32();
        }
        if (b === void 0) {
          b = new Vector32();
        }
        if (c === void 0) {
          c = new Vector32();
        }
        this.a = a;
        this.b = b;
        this.c = c;
      }
      Triangle3.getNormal = function getNormal(a, b, c, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getNormal() target is now required");
          target = new Vector32();
        }
        target.subVectors(c, b);
        _v0$12.subVectors(a, b);
        target.cross(_v0$12);
        var targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      };
      Triangle3.getBarycoord = function getBarycoord(point, a, b, c, target) {
        _v0$12.subVectors(c, a);
        _v1$32.subVectors(b, a);
        _v2$12.subVectors(point, a);
        var dot00 = _v0$12.dot(_v0$12);
        var dot01 = _v0$12.dot(_v1$32);
        var dot02 = _v0$12.dot(_v2$12);
        var dot11 = _v1$32.dot(_v1$32);
        var dot12 = _v1$32.dot(_v2$12);
        var denom = dot00 * dot11 - dot01 * dot01;
        if (target === void 0) {
          console.warn("THREE.Triangle: .getBarycoord() target is now required");
          target = new Vector32();
        }
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      };
      Triangle3.containsPoint = function containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, _v32);
        return _v32.x >= 0 && _v32.y >= 0 && _v32.x + _v32.y <= 1;
      };
      Triangle3.getUV = function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v32);
        target.set(0, 0);
        target.addScaledVector(uv1, _v32.x);
        target.addScaledVector(uv2, _v32.y);
        target.addScaledVector(uv3, _v32.z);
        return target;
      };
      Triangle3.isFrontFacing = function isFrontFacing(a, b, c, direction) {
        _v0$12.subVectors(c, b);
        _v1$32.subVectors(a, b);
        return _v0$12.cross(_v1$32).dot(direction) < 0 ? true : false;
      };
      var _proto = Triangle3.prototype;
      _proto.set = function set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      };
      _proto.setFromPointsAndIndices = function setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.copy = function copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      };
      _proto.getArea = function getArea() {
        _v0$12.subVectors(this.c, this.b);
        _v1$32.subVectors(this.a, this.b);
        return _v0$12.cross(_v1$32).length() * 0.5;
      };
      _proto.getMidpoint = function getMidpoint(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getMidpoint() target is now required");
          target = new Vector32();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      };
      _proto.getNormal = function getNormal(target) {
        return Triangle3.getNormal(this.a, this.b, this.c, target);
      };
      _proto.getPlane = function getPlane(target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getPlane() target is now required");
          target = new Plane2();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      };
      _proto.getBarycoord = function getBarycoord(point, target) {
        return Triangle3.getBarycoord(point, this.a, this.b, this.c, target);
      };
      _proto.getUV = function getUV(point, uv1, uv2, uv3, target) {
        return Triangle3.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      };
      _proto.containsPoint = function containsPoint(point) {
        return Triangle3.containsPoint(point, this.a, this.b, this.c);
      };
      _proto.isFrontFacing = function isFrontFacing(direction) {
        return Triangle3.isFrontFacing(this.a, this.b, this.c, direction);
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return box.intersectsTriangle(this);
      };
      _proto.closestPointToPoint = function closestPointToPoint(p, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
          target = new Vector32();
        }
        var a = this.a, b = this.b, c = this.c;
        var v, w;
        _vab2.subVectors(b, a);
        _vac2.subVectors(c, a);
        _vap2.subVectors(p, a);
        var d1 = _vab2.dot(_vap2);
        var d2 = _vac2.dot(_vap2);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        _vbp2.subVectors(p, b);
        var d3 = _vab2.dot(_vbp2);
        var d4 = _vac2.dot(_vbp2);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b);
        }
        var vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(_vab2, v);
        }
        _vcp2.subVectors(p, c);
        var d5 = _vab2.dot(_vcp2);
        var d6 = _vac2.dot(_vcp2);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        var vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(_vac2, w);
        }
        var va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc2.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b).addScaledVector(_vbc2, w);
        }
        var denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab2, v).addScaledVector(_vac2, w);
      };
      _proto.equals = function equals3(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      };
      return Triangle3;
    }();
    var materialId2 = 0;
    function Material2() {
      Object.defineProperty(this, "id", {
        value: materialId2++
      });
      this.uuid = MathUtils2.generateUUID();
      this.name = "";
      this.type = "Material";
      this.fog = true;
      this.blending = NormalBlending2;
      this.side = FrontSide2;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.blendSrc = SrcAlphaFactor2;
      this.blendDst = OneMinusSrcAlphaFactor2;
      this.blendEquation = AddEquation2;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = LessEqualDepth2;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc2;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp2;
      this.stencilZFail = KeepStencilOp2;
      this.stencilZPass = KeepStencilOp2;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaTest = 0;
      this.premultipliedAlpha = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
    }
    Material2.prototype = Object.assign(Object.create(EventDispatcher2.prototype), {
      constructor: Material2,
      isMaterial: true,
      onBeforeCompile: function onBeforeCompile() {
      },
      customProgramCacheKey: function customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      },
      setValues: function setValues(values) {
        if (values === void 0)
          return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading2 ? true : false;
            continue;
          }
          var currentValue = this[key];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      },
      toJSON: function toJSON2(meta) {
        var isRoot = meta === void 0 || typeof meta === "string";
        if (isRoot) {
          meta = {
            textures: {},
            images: {}
          };
        }
        var data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor)
          data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          data.reflectivity = this.reflectivity;
          data.refractionRatio = this.refractionRatio;
          if (this.combine !== void 0)
            data.combine = this.combine;
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.size !== void 0)
          data.size = this.size;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending2)
          data.blending = this.blending;
        if (this.side !== FrontSide2)
          data.side = this.side;
        if (this.vertexColors)
          data.vertexColors = true;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true)
          data.morphTargets = true;
        if (this.morphNormals === true)
          data.morphNormals = true;
        if (this.skinning === true)
          data.skinning = true;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var _data = cache[key];
            delete _data.metadata;
            values.push(_data);
          }
          return values;
        }
        if (isRoot) {
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      },
      clone: function clone() {
        return new this.constructor().copy(this);
      },
      copy: function copy(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        var srcPlanes = source.clippingPlanes;
        var dstPlanes = null;
        if (srcPlanes !== null) {
          var n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (var i2 = 0; i2 !== n; ++i2) {
            dstPlanes[i2] = srcPlanes[i2].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      },
      dispose: function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    Object.defineProperty(Material2.prototype, "needsUpdate", {
      set: function set(value) {
        if (value === true)
          this.version++;
      }
    });
    var _colorKeywords2 = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    var _hslA2 = {
      h: 0,
      s: 0,
      l: 0
    };
    var _hslB2 = {
      h: 0,
      s: 0,
      l: 0
    };
    function hue2rgb2(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }
    function SRGBToLinear2(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB2(c) {
      return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }
    var Color5 = /* @__PURE__ */ function() {
      function Color6(r, g, b) {
        if (g === void 0 && b === void 0) {
          return this.set(r);
        }
        return this.setRGB(r, g, b);
      }
      var _proto = Color6.prototype;
      _proto.set = function set(value) {
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
        return this;
      };
      _proto.setScalar = function setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      };
      _proto.setHex = function setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      };
      _proto.setRGB = function setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      };
      _proto.setHSL = function setHSL(h, s, l) {
        h = MathUtils2.euclideanModulo(h, 1);
        s = MathUtils2.clamp(s, 0, 1);
        l = MathUtils2.clamp(l, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          var q = 2 * l - p;
          this.r = hue2rgb2(q, p, h + 1 / 3);
          this.g = hue2rgb2(q, p, h);
          this.b = hue2rgb2(q, p, h - 1 / 3);
        }
        return this;
      };
      _proto.setStyle = function setStyle(style) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
          var color;
          var name2 = m[1];
          var components = m[2];
          switch (name2) {
            case "rgb":
            case "rgba":
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[4]);
                return this;
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[4]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                var h = parseFloat(color[1]) / 360;
                var s = parseInt(color[2], 10) / 100;
                var l = parseInt(color[3], 10) / 100;
                handleAlpha(color[4]);
                return this.setHSL(h, s, l);
              }
              break;
          }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          var hex = m[1];
          var size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style);
        }
        return this;
      };
      _proto.setColorName = function setColorName(style) {
        var hex = _colorKeywords2[style];
        if (hex !== void 0) {
          this.setHex(hex);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor(this.r, this.g, this.b);
      };
      _proto.copy = function copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      };
      _proto.copyGammaToLinear = function copyGammaToLinear(color, gammaFactor) {
        if (gammaFactor === void 0) {
          gammaFactor = 2;
        }
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      };
      _proto.copyLinearToGamma = function copyLinearToGamma(color, gammaFactor) {
        if (gammaFactor === void 0) {
          gammaFactor = 2;
        }
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      };
      _proto.convertGammaToLinear = function convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
      };
      _proto.convertLinearToGamma = function convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
      };
      _proto.copySRGBToLinear = function copySRGBToLinear(color) {
        this.r = SRGBToLinear2(color.r);
        this.g = SRGBToLinear2(color.g);
        this.b = SRGBToLinear2(color.b);
        return this;
      };
      _proto.copyLinearToSRGB = function copyLinearToSRGB(color) {
        this.r = LinearToSRGB2(color.r);
        this.g = LinearToSRGB2(color.g);
        this.b = LinearToSRGB2(color.b);
        return this;
      };
      _proto.convertSRGBToLinear = function convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      };
      _proto.convertLinearToSRGB = function convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      };
      _proto.getHex = function getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
      };
      _proto.getHexString = function getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      };
      _proto.getHSL = function getHSL(target) {
        if (target === void 0) {
          console.warn("THREE.Color: .getHSL() target is now required");
          target = {
            h: 0,
            s: 0,
            l: 0
          };
        }
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      };
      _proto.getStyle = function getStyle() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
      };
      _proto.offsetHSL = function offsetHSL(h, s, l) {
        this.getHSL(_hslA2);
        _hslA2.h += h;
        _hslA2.s += s;
        _hslA2.l += l;
        this.setHSL(_hslA2.h, _hslA2.s, _hslA2.l);
        return this;
      };
      _proto.add = function add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      };
      _proto.addColors = function addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      };
      _proto.addScalar = function addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      };
      _proto.sub = function sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      };
      _proto.multiply = function multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      };
      _proto.lerp = function lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      };
      _proto.lerpColors = function lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      };
      _proto.lerpHSL = function lerpHSL(color, alpha) {
        this.getHSL(_hslA2);
        color.getHSL(_hslB2);
        var h = MathUtils2.lerp(_hslA2.h, _hslB2.h, alpha);
        var s = MathUtils2.lerp(_hslA2.s, _hslB2.s, alpha);
        var l = MathUtils2.lerp(_hslA2.l, _hslB2.l, alpha);
        this.setHSL(h, s, l);
        return this;
      };
      _proto.equals = function equals3(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      };
      _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
          this.r /= 255;
          this.g /= 255;
          this.b /= 255;
        }
        return this;
      };
      _proto.toJSON = function toJSON2() {
        return this.getHex();
      };
      return Color6;
    }();
    Color5.NAMES = _colorKeywords2;
    Color5.prototype.isColor = true;
    Color5.prototype.r = 1;
    Color5.prototype.g = 1;
    Color5.prototype.b = 1;
    var MeshBasicMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshBasicMaterial3, _Material);
      function MeshBasicMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshBasicMaterial";
        _this.color = new Color5(16777215);
        _this.map = null;
        _this.lightMap = null;
        _this.lightMapIntensity = 1;
        _this.aoMap = null;
        _this.aoMapIntensity = 1;
        _this.specularMap = null;
        _this.alphaMap = null;
        _this.envMap = null;
        _this.combine = MultiplyOperation2;
        _this.reflectivity = 1;
        _this.refractionRatio = 0.98;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.wireframeLinecap = "round";
        _this.wireframeLinejoin = "round";
        _this.skinning = false;
        _this.morphTargets = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshBasicMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
      };
      return MeshBasicMaterial3;
    }(Material2);
    MeshBasicMaterial2.prototype.isMeshBasicMaterial = true;
    var _vector$32 = new Vector32();
    var _vector2$12 = new Vector22();
    function BufferAttribute3(array, itemSize, normalized) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized === true;
      this.usage = StaticDrawUsage2;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    }
    Object.defineProperty(BufferAttribute3.prototype, "needsUpdate", {
      set: function set(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.assign(BufferAttribute3.prototype, {
      isBufferAttribute: true,
      onUploadCallback: function onUploadCallback() {
      },
      setUsage: function setUsage(value) {
        this.usage = value;
        return this;
      },
      copy: function copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      },
      copyAt: function copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i2 = 0, l = this.itemSize; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      },
      copyArray: function copyArray3(array) {
        this.array.set(array);
        return this;
      },
      copyColorsArray: function copyColorsArray(colors) {
        var array = this.array;
        var offset = 0;
        for (var i2 = 0, l = colors.length; i2 < l; i2++) {
          var color = colors[i2];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
            color = new Color5();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      },
      copyVector2sArray: function copyVector2sArray(vectors) {
        var array = this.array;
        var offset = 0;
        for (var i2 = 0, l = vectors.length; i2 < l; i2++) {
          var vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
            vector = new Vector22();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      },
      copyVector3sArray: function copyVector3sArray(vectors) {
        var array = this.array;
        var offset = 0;
        for (var i2 = 0, l = vectors.length; i2 < l; i2++) {
          var vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
            vector = new Vector32();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      },
      copyVector4sArray: function copyVector4sArray(vectors) {
        var array = this.array;
        var offset = 0;
        for (var i2 = 0, l = vectors.length; i2 < l; i2++) {
          var vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
            vector = new Vector42();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      },
      applyMatrix3: function applyMatrix3(m) {
        if (this.itemSize === 2) {
          for (var i2 = 0, l = this.count; i2 < l; i2++) {
            _vector2$12.fromBufferAttribute(this, i2);
            _vector2$12.applyMatrix3(m);
            this.setXY(i2, _vector2$12.x, _vector2$12.y);
          }
        } else if (this.itemSize === 3) {
          for (var _i = 0, _l = this.count; _i < _l; _i++) {
            _vector$32.fromBufferAttribute(this, _i);
            _vector$32.applyMatrix3(m);
            this.setXYZ(_i, _vector$32.x, _vector$32.y, _vector$32.z);
          }
        }
        return this;
      },
      applyMatrix4: function applyMatrix4(m) {
        for (var i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$32.x = this.getX(i2);
          _vector$32.y = this.getY(i2);
          _vector$32.z = this.getZ(i2);
          _vector$32.applyMatrix4(m);
          this.setXYZ(i2, _vector$32.x, _vector$32.y, _vector$32.z);
        }
        return this;
      },
      applyNormalMatrix: function applyNormalMatrix(m) {
        for (var i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$32.x = this.getX(i2);
          _vector$32.y = this.getY(i2);
          _vector$32.z = this.getZ(i2);
          _vector$32.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$32.x, _vector$32.y, _vector$32.z);
        }
        return this;
      },
      transformDirection: function transformDirection(m) {
        for (var i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$32.x = this.getX(i2);
          _vector$32.y = this.getY(i2);
          _vector$32.z = this.getZ(i2);
          _vector$32.transformDirection(m);
          this.setXYZ(i2, _vector$32.x, _vector$32.y, _vector$32.z);
        }
        return this;
      },
      set: function set(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.array.set(value, offset);
        return this;
      },
      getX: function getX(index) {
        return this.array[index * this.itemSize];
      },
      setX: function setX(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      },
      getY: function getY(index) {
        return this.array[index * this.itemSize + 1];
      },
      setY: function setY(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      getZ: function getZ(index) {
        return this.array[index * this.itemSize + 2];
      },
      setZ: function setZ(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      getW: function getW(index) {
        return this.array[index * this.itemSize + 3];
      },
      setW: function setW(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
      },
      setXY: function setXY(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function setXYZ(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      onUpload: function onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      },
      clone: function clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
      toJSON: function toJSON2() {
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
      }
    });
    function Int8BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Int8Array(array), itemSize, normalized);
    }
    Int8BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Int8BufferAttribute2.prototype.constructor = Int8BufferAttribute2;
    function Uint8BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Uint8Array(array), itemSize, normalized);
    }
    Uint8BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Uint8BufferAttribute2.prototype.constructor = Uint8BufferAttribute2;
    function Uint8ClampedBufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    Uint8ClampedBufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Uint8ClampedBufferAttribute2.prototype.constructor = Uint8ClampedBufferAttribute2;
    function Int16BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Int16Array(array), itemSize, normalized);
    }
    Int16BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Int16BufferAttribute2.prototype.constructor = Int16BufferAttribute2;
    function Uint16BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Uint16BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Uint16BufferAttribute2.prototype.constructor = Uint16BufferAttribute2;
    function Int32BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Int32Array(array), itemSize, normalized);
    }
    Int32BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Int32BufferAttribute2.prototype.constructor = Int32BufferAttribute2;
    function Uint32BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Uint32Array(array), itemSize, normalized);
    }
    Uint32BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Uint32BufferAttribute2.prototype.constructor = Uint32BufferAttribute2;
    function Float16BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Float16BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Float16BufferAttribute2.prototype.constructor = Float16BufferAttribute2;
    Float16BufferAttribute2.prototype.isFloat16BufferAttribute = true;
    function Float32BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Float32Array(array), itemSize, normalized);
    }
    Float32BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Float32BufferAttribute2.prototype.constructor = Float32BufferAttribute2;
    function Float64BufferAttribute2(array, itemSize, normalized) {
      BufferAttribute3.call(this, new Float64Array(array), itemSize, normalized);
    }
    Float64BufferAttribute2.prototype = Object.create(BufferAttribute3.prototype);
    Float64BufferAttribute2.prototype.constructor = Float64BufferAttribute2;
    function arrayMax2(array) {
      if (array.length === 0)
        return -Infinity;
      var max = array[0];
      for (var i2 = 1, l = array.length; i2 < l; ++i2) {
        if (array[i2] > max)
          max = array[i2];
      }
      return max;
    }
    var TYPED_ARRAYS = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    };
    function getTypedArray(type, buffer) {
      return new TYPED_ARRAYS[type](buffer);
    }
    var _id2 = 0;
    var _m1$22 = new Matrix43();
    var _obj2 = new Object3D2();
    var _offset2 = new Vector32();
    var _box$22 = new Box32();
    var _boxMorphTargets2 = new Box32();
    var _vector$42 = new Vector32();
    function BufferGeometry3() {
      Object.defineProperty(this, "id", {
        value: _id2++
      });
      this.uuid = MathUtils2.generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = {
        start: 0,
        count: Infinity
      };
      this.userData = {};
    }
    BufferGeometry3.prototype = Object.assign(Object.create(EventDispatcher2.prototype), {
      constructor: BufferGeometry3,
      isBufferGeometry: true,
      getIndex: function getIndex() {
        return this.index;
      },
      setIndex: function setIndex(index) {
        if (Array.isArray(index)) {
          this.index = new (arrayMax2(index) > 65535 ? Uint32BufferAttribute2 : Uint16BufferAttribute2)(index, 1);
        } else {
          this.index = index;
        }
        return this;
      },
      getAttribute: function getAttribute(name2) {
        return this.attributes[name2];
      },
      setAttribute: function setAttribute(name2, attribute) {
        this.attributes[name2] = attribute;
        return this;
      },
      deleteAttribute: function deleteAttribute(name2) {
        delete this.attributes[name2];
        return this;
      },
      hasAttribute: function hasAttribute(name2) {
        return this.attributes[name2] !== void 0;
      },
      addGroup: function addGroup(start, count, materialIndex) {
        if (materialIndex === void 0) {
          materialIndex = 0;
        }
        this.groups.push({
          start,
          count,
          materialIndex
        });
      },
      clearGroups: function clearGroups() {
        this.groups = [];
      },
      setDrawRange: function setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      },
      applyMatrix4: function applyMatrix4(matrix) {
        var position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== void 0) {
          var normalMatrix = new Matrix32().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        var tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      },
      rotateX: function rotateX(angle) {
        _m1$22.makeRotationX(angle);
        this.applyMatrix4(_m1$22);
        return this;
      },
      rotateY: function rotateY(angle) {
        _m1$22.makeRotationY(angle);
        this.applyMatrix4(_m1$22);
        return this;
      },
      rotateZ: function rotateZ(angle) {
        _m1$22.makeRotationZ(angle);
        this.applyMatrix4(_m1$22);
        return this;
      },
      translate: function translate(x, y, z) {
        _m1$22.makeTranslation(x, y, z);
        this.applyMatrix4(_m1$22);
        return this;
      },
      scale: function scale(x, y, z) {
        _m1$22.makeScale(x, y, z);
        this.applyMatrix4(_m1$22);
        return this;
      },
      lookAt: function lookAt(vector) {
        _obj2.lookAt(vector);
        _obj2.updateMatrix();
        this.applyMatrix4(_obj2.matrix);
        return this;
      },
      center: function center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset2).negate();
        this.translate(_offset2.x, _offset2.y, _offset2.z);
        return this;
      },
      setFromPoints: function setFromPoints(points) {
        var position = [];
        for (var i2 = 0, l = points.length; i2 < l; i2++) {
          var point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute2(position, 3));
        return this;
      },
      computeBoundingBox: function computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box32();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingBox.set(new Vector32(-Infinity, -Infinity, -Infinity), new Vector32(Infinity, Infinity, Infinity));
          return;
        }
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              var morphAttribute = morphAttributesPosition[i2];
              _box$22.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$42.addVectors(this.boundingBox.min, _box$22.min);
                this.boundingBox.expandByPoint(_vector$42);
                _vector$42.addVectors(this.boundingBox.max, _box$22.max);
                this.boundingBox.expandByPoint(_vector$42);
              } else {
                this.boundingBox.expandByPoint(_box$22.min);
                this.boundingBox.expandByPoint(_box$22.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      },
      computeBoundingSphere: function computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere2();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingSphere.set(new Vector32(), Infinity);
          return;
        }
        if (position) {
          var center = this.boundingSphere.center;
          _box$22.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              var morphAttribute = morphAttributesPosition[i2];
              _boxMorphTargets2.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$42.addVectors(_box$22.min, _boxMorphTargets2.min);
                _box$22.expandByPoint(_vector$42);
                _vector$42.addVectors(_box$22.max, _boxMorphTargets2.max);
                _box$22.expandByPoint(_vector$42);
              } else {
                _box$22.expandByPoint(_boxMorphTargets2.min);
                _box$22.expandByPoint(_boxMorphTargets2.max);
              }
            }
          }
          _box$22.getCenter(center);
          var maxRadiusSq = 0;
          for (var _i = 0, _il = position.count; _i < _il; _i++) {
            _vector$42.fromBufferAttribute(position, _i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$42));
          }
          if (morphAttributesPosition) {
            for (var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++) {
              var _morphAttribute = morphAttributesPosition[_i2];
              var morphTargetsRelative = this.morphTargetsRelative;
              for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
                _vector$42.fromBufferAttribute(_morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset2.fromBufferAttribute(position, j);
                  _vector$42.add(_offset2);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$42));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      },
      computeFaceNormals: function computeFaceNormals() {
      },
      computeTangents: function computeTangents() {
        var index = this.index;
        var attributes = this.attributes;
        if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        var indices = index.array;
        var positions = attributes.position.array;
        var normals = attributes.normal.array;
        var uvs = attributes.uv.array;
        var nVertices = positions.length / 3;
        if (attributes.tangent === void 0) {
          this.setAttribute("tangent", new BufferAttribute3(new Float32Array(4 * nVertices), 4));
        }
        var tangents = attributes.tangent.array;
        var tan1 = [], tan2 = [];
        for (var i2 = 0; i2 < nVertices; i2++) {
          tan1[i2] = new Vector32();
          tan2[i2] = new Vector32();
        }
        var vA = new Vector32(), vB = new Vector32(), vC = new Vector32(), uvA = new Vector22(), uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector32(), tdir = new Vector32();
        function handleTriangle(a, b, c) {
          vA.fromArray(positions, a * 3);
          vB.fromArray(positions, b * 3);
          vC.fromArray(positions, c * 3);
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b * 2);
          uvC.fromArray(uvs, c * 2);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          var r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
          if (!isFinite(r))
            return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        var groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.length
          }];
        }
        for (var _i3 = 0, il = groups.length; _i3 < il; ++_i3) {
          var group = groups[_i3];
          var start = group.start;
          var count = group.count;
          for (var j = start, jl = start + count; j < jl; j += 3) {
            handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
          }
        }
        var tmp3 = new Vector32(), tmp22 = new Vector32();
        var n = new Vector32(), n2 = new Vector32();
        function handleVertex(v) {
          n.fromArray(normals, v * 3);
          n2.copy(n);
          var t = tan1[v];
          tmp3.copy(t);
          tmp3.sub(n.multiplyScalar(n.dot(t))).normalize();
          tmp22.crossVectors(n2, t);
          var test = tmp22.dot(tan2[v]);
          var w = test < 0 ? -1 : 1;
          tangents[v * 4] = tmp3.x;
          tangents[v * 4 + 1] = tmp3.y;
          tangents[v * 4 + 2] = tmp3.z;
          tangents[v * 4 + 3] = w;
        }
        for (var _i4 = 0, _il3 = groups.length; _i4 < _il3; ++_i4) {
          var _group = groups[_i4];
          var _start3 = _group.start;
          var _count = _group.count;
          for (var _j = _start3, _jl = _start3 + _count; _j < _jl; _j += 3) {
            handleVertex(indices[_j + 0]);
            handleVertex(indices[_j + 1]);
            handleVertex(indices[_j + 2]);
          }
        }
      },
      computeVertexNormals: function computeVertexNormals() {
        var index = this.index;
        var positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          var normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute3(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (var i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
              normalAttribute.setXYZ(i2, 0, 0, 0);
            }
          }
          var pA = new Vector32(), pB = new Vector32(), pC = new Vector32();
          var nA = new Vector32(), nB = new Vector32(), nC = new Vector32();
          var cb = new Vector32(), ab = new Vector32();
          if (index) {
            for (var _i5 = 0, _il4 = index.count; _i5 < _il4; _i5 += 3) {
              var vA = index.getX(_i5 + 0);
              var vB = index.getX(_i5 + 1);
              var vC = index.getX(_i5 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (var _i6 = 0, _il5 = positionAttribute.count; _i6 < _il5; _i6 += 3) {
              pA.fromBufferAttribute(positionAttribute, _i6 + 0);
              pB.fromBufferAttribute(positionAttribute, _i6 + 1);
              pC.fromBufferAttribute(positionAttribute, _i6 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(_i6 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(_i6 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(_i6 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      },
      merge: function merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset === void 0) {
          offset = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === void 0)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeOffset = attribute2.itemSize * offset;
          var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (var i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
            attributeArray1[j] = attributeArray2[i2];
          }
        }
        return this;
      },
      normalizeNormals: function normalizeNormals() {
        var normals = this.attributes.normal;
        for (var i2 = 0, il = normals.count; i2 < il; i2++) {
          _vector$42.fromBufferAttribute(normals, i2);
          _vector$42.normalize();
          normals.setXYZ(i2, _vector$42.x, _vector$42.y, _vector$42.z);
        }
      },
      toNonIndexed: function toNonIndexed() {
        function convertBufferAttribute(attribute2, indices2) {
          var array = attribute2.array;
          var itemSize = attribute2.itemSize;
          var normalized = attribute2.normalized;
          var array2 = new array.constructor(indices2.length * itemSize);
          var index = 0, index2 = 0;
          for (var i3 = 0, l2 = indices2.length; i3 < l2; i3++) {
            index = indices2[i3] * itemSize;
            for (var j = 0; j < itemSize; j++) {
              array2[index2++] = array[index++];
            }
          }
          return new BufferAttribute3(array2, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
          return this;
        }
        var geometry2 = new BufferGeometry3();
        var indices = this.index.array;
        var attributes = this.attributes;
        for (var name2 in attributes) {
          var attribute = attributes[name2];
          var newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name2, newAttribute);
        }
        var morphAttributes = this.morphAttributes;
        for (var _name in morphAttributes) {
          var morphArray = [];
          var morphAttribute = morphAttributes[_name];
          for (var i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
            var _attribute = morphAttribute[i2];
            var _newAttribute = convertBufferAttribute(_attribute, indices);
            morphArray.push(_newAttribute);
          }
          geometry2.morphAttributes[_name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        var groups = this.groups;
        for (var _i7 = 0, l = groups.length; _i7 < l; _i7++) {
          var group = groups[_i7];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      },
      toJSON: function toJSON2() {
        var data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = {
          attributes: {}
        };
        var index = this.index;
        if (index !== null) {
          data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
          };
        }
        var attributes = this.attributes;
        for (var _key in attributes) {
          var attribute = attributes[_key];
          var attributeData = attribute.toJSON(data.data);
          if (attribute.name !== "")
            attributeData.name = attribute.name;
          data.data.attributes[_key] = attributeData;
        }
        var morphAttributes = {};
        var hasMorphAttributes = false;
        for (var _key2 in this.morphAttributes) {
          var attributeArray = this.morphAttributes[_key2];
          var array = [];
          for (var i2 = 0, il = attributeArray.length; i2 < il; i2++) {
            var _attribute2 = attributeArray[i2];
            var _attributeData = _attribute2.toJSON(data.data);
            if (_attribute2.name !== "")
              _attributeData.name = _attribute2.name;
            array.push(_attributeData);
          }
          if (array.length > 0) {
            morphAttributes[_key2] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        var groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      },
      clone: function clone() {
        return new BufferGeometry3().copy(this);
      },
      copy: function copy(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        var data = {};
        this.name = source.name;
        var index = source.index;
        if (index !== null) {
          this.setIndex(index.clone(data));
        }
        var attributes = source.attributes;
        for (var name2 in attributes) {
          var attribute = attributes[name2];
          this.setAttribute(name2, attribute.clone(data));
        }
        var morphAttributes = source.morphAttributes;
        for (var _name2 in morphAttributes) {
          var array = [];
          var morphAttribute = morphAttributes[_name2];
          for (var i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
            array.push(morphAttribute[i2].clone(data));
          }
          this.morphAttributes[_name2] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        var groups = source.groups;
        for (var _i8 = 0, _l = groups.length; _i8 < _l; _i8++) {
          var group = groups[_i8];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        var boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
      },
      dispose: function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    var _inverseMatrix2 = new Matrix43();
    var _ray2 = new Ray2();
    var _sphere2 = new Sphere2();
    var _vA2 = new Vector32();
    var _vB2 = new Vector32();
    var _vC2 = new Vector32();
    var _tempA2 = new Vector32();
    var _tempB2 = new Vector32();
    var _tempC2 = new Vector32();
    var _morphA2 = new Vector32();
    var _morphB2 = new Vector32();
    var _morphC2 = new Vector32();
    var _uvA2 = new Vector22();
    var _uvB2 = new Vector22();
    var _uvC2 = new Vector22();
    var _intersectionPoint2 = new Vector32();
    var _intersectionPointWorld2 = new Vector32();
    function Mesh3(geometry, material) {
      if (geometry === void 0) {
        geometry = new BufferGeometry3();
      }
      if (material === void 0) {
        material = new MeshBasicMaterial2();
      }
      Object3D2.call(this);
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    Mesh3.prototype = Object.assign(Object.create(Object3D2.prototype), {
      constructor: Mesh3,
      isMesh: true,
      copy: function copy(source) {
        Object3D2.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      updateMorphTargets: function updateMorphTargets() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          var morphAttributes = geometry.morphAttributes;
          var keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            var morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                var name2 = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m;
              }
            }
          }
        } else {
          var morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      },
      raycast: function raycast(raycaster, intersects3) {
        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere2.copy(geometry.boundingSphere);
        _sphere2.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere2) === false)
          return;
        _inverseMatrix2.copy(matrixWorld).invert();
        _ray2.copy(raycaster.ray).applyMatrix4(_inverseMatrix2);
        if (geometry.boundingBox !== null) {
          if (_ray2.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        var intersection;
        if (geometry.isBufferGeometry) {
          var index = geometry.index;
          var position = geometry.attributes.position;
          var morphPosition = geometry.morphAttributes.position;
          var morphTargetsRelative = geometry.morphTargetsRelative;
          var uv = geometry.attributes.uv;
          var uv2 = geometry.attributes.uv2;
          var groups = geometry.groups;
          var drawRange = geometry.drawRange;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (var i2 = 0, il = groups.length; i2 < il; i2++) {
                var group = groups[i2];
                var groupMaterial = material[group.materialIndex];
                var start = Math.max(group.start, drawRange.start);
                var end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (var j = start, jl = end; j < jl; j += 3) {
                  var a = index.getX(j);
                  var b = index.getX(j + 1);
                  var c = index.getX(j + 2);
                  intersection = checkBufferGeometryIntersection2(this, groupMaterial, raycaster, _ray2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects3.push(intersection);
                  }
                }
              }
            } else {
              var _start3 = Math.max(0, drawRange.start);
              var _end3 = Math.min(index.count, drawRange.start + drawRange.count);
              for (var _i = _start3, _il = _end3; _i < _il; _i += 3) {
                var _a = index.getX(_i);
                var _b = index.getX(_i + 1);
                var _c = index.getX(_i + 2);
                intersection = checkBufferGeometryIntersection2(this, material, raycaster, _ray2, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(_i / 3);
                  intersects3.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {
                var _group = groups[_i2];
                var _groupMaterial = material[_group.materialIndex];
                var _start22 = Math.max(_group.start, drawRange.start);
                var _end22 = Math.min(_group.start + _group.count, drawRange.start + drawRange.count);
                for (var _j = _start22, _jl = _end22; _j < _jl; _j += 3) {
                  var _a2 = _j;
                  var _b2 = _j + 1;
                  var _c2 = _j + 2;
                  intersection = checkBufferGeometryIntersection2(this, _groupMaterial, raycaster, _ray2, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(_j / 3);
                    intersection.face.materialIndex = _group.materialIndex;
                    intersects3.push(intersection);
                  }
                }
              }
            } else {
              var _start32 = Math.max(0, drawRange.start);
              var _end32 = Math.min(position.count, drawRange.start + drawRange.count);
              for (var _i3 = _start32, _il3 = _end32; _i3 < _il3; _i3 += 3) {
                var _a3 = _i3;
                var _b3 = _i3 + 1;
                var _c3 = _i3 + 2;
                intersection = checkBufferGeometryIntersection2(this, material, raycaster, _ray2, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);
                if (intersection) {
                  intersection.faceIndex = Math.floor(_i3 / 3);
                  intersects3.push(intersection);
                }
              }
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    });
    function checkIntersection2(object, material, raycaster, ray, pA, pB, pC, point) {
      var intersect;
      if (material.side === BackSide2) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide3, point);
      }
      if (intersect === null)
        return null;
      _intersectionPointWorld2.copy(point);
      _intersectionPointWorld2.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld2);
      if (distance < raycaster.near || distance > raycaster.far)
        return null;
      return {
        distance,
        point: _intersectionPointWorld2.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection2(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
      _vA2.fromBufferAttribute(position, a);
      _vB2.fromBufferAttribute(position, b);
      _vC2.fromBufferAttribute(position, c);
      var morphInfluences = object.morphTargetInfluences;
      if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA2.set(0, 0, 0);
        _morphB2.set(0, 0, 0);
        _morphC2.set(0, 0, 0);
        for (var i2 = 0, il = morphPosition.length; i2 < il; i2++) {
          var influence = morphInfluences[i2];
          var morphAttribute = morphPosition[i2];
          if (influence === 0)
            continue;
          _tempA2.fromBufferAttribute(morphAttribute, a);
          _tempB2.fromBufferAttribute(morphAttribute, b);
          _tempC2.fromBufferAttribute(morphAttribute, c);
          if (morphTargetsRelative) {
            _morphA2.addScaledVector(_tempA2, influence);
            _morphB2.addScaledVector(_tempB2, influence);
            _morphC2.addScaledVector(_tempC2, influence);
          } else {
            _morphA2.addScaledVector(_tempA2.sub(_vA2), influence);
            _morphB2.addScaledVector(_tempB2.sub(_vB2), influence);
            _morphC2.addScaledVector(_tempC2.sub(_vC2), influence);
          }
        }
        _vA2.add(_morphA2);
        _vB2.add(_morphB2);
        _vC2.add(_morphC2);
      }
      if (object.isSkinnedMesh && material.skinning) {
        object.boneTransform(a, _vA2);
        object.boneTransform(b, _vB2);
        object.boneTransform(c, _vC2);
      }
      var intersection = checkIntersection2(object, material, raycaster, ray, _vA2, _vB2, _vC2, _intersectionPoint2);
      if (intersection) {
        if (uv) {
          _uvA2.fromBufferAttribute(uv, a);
          _uvB2.fromBufferAttribute(uv, b);
          _uvC2.fromBufferAttribute(uv, c);
          intersection.uv = Triangle2.getUV(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector22());
        }
        if (uv2) {
          _uvA2.fromBufferAttribute(uv2, a);
          _uvB2.fromBufferAttribute(uv2, b);
          _uvC2.fromBufferAttribute(uv2, c);
          intersection.uv2 = Triangle2.getUV(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector22());
        }
        var face = {
          a,
          b: a,
          c,
          normal: new Vector32(),
          materialIndex: 0
        };
        Triangle2.getNormal(_vA2, _vB2, _vC2, face.normal);
        intersection.face = face;
      }
      return intersection;
    }
    var BoxGeometry2 = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(BoxGeometry3, _BufferGeometry);
      function BoxGeometry3(width, height, depth, widthSegments, heightSegments, depthSegments) {
        var _this;
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (depth === void 0) {
          depth = 1;
        }
        if (widthSegments === void 0) {
          widthSegments = 1;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (depthSegments === void 0) {
          depthSegments = 1;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "BoxGeometry";
        _this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        var scope = _assertThisInitialized(_this);
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var numberOfVertices = 0;
        var groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          var segmentWidth = width2 / gridX;
          var segmentHeight = height2 / gridY;
          var widthHalf = width2 / 2;
          var heightHalf = height2 / 2;
          var depthHalf = depth2 / 2;
          var gridX1 = gridX + 1;
          var gridY1 = gridY + 1;
          var vertexCounter = 0;
          var groupCount = 0;
          var vector = new Vector32();
          for (var iy = 0; iy < gridY1; iy++) {
            var y = iy * segmentHeight - heightHalf;
            for (var ix = 0; ix < gridX1; ix++) {
              var x = ix * segmentWidth - widthHalf;
              vector[u] = x * udir;
              vector[v] = y * vdir;
              vector[w] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u] = 0;
              vector[v] = 0;
              vector[w] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (var _iy = 0; _iy < gridY; _iy++) {
            for (var _ix = 0; _ix < gridX; _ix++) {
              var a = numberOfVertices + _ix + gridX1 * _iy;
              var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
              var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
              var d = numberOfVertices + (_ix + 1) + gridX1 * _iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
        return _this;
      }
      return BoxGeometry3;
    }(BufferGeometry3);
    function cloneUniforms2(src) {
      var dst = {};
      for (var u in src) {
        dst[u] = {};
        for (var p in src[u]) {
          var property = src[u][p];
          if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
            dst[u][p] = property.clone();
          } else if (Array.isArray(property)) {
            dst[u][p] = property.slice();
          } else {
            dst[u][p] = property;
          }
        }
      }
      return dst;
    }
    function mergeUniforms2(uniforms) {
      var merged = {};
      for (var u = 0; u < uniforms.length; u++) {
        var tmp3 = cloneUniforms2(uniforms[u]);
        for (var p in tmp3) {
          merged[p] = tmp3[p];
        }
      }
      return merged;
    }
    var UniformsUtils2 = {
      clone: cloneUniforms2,
      merge: mergeUniforms2
    };
    var default_vertex2 = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment2 = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    function ShaderMaterial2(parameters) {
      Material2.call(this);
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = default_vertex2;
      this.fragmentShader = default_fragment2;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
      };
      this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        if (parameters.attributes !== void 0) {
          console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
      }
    }
    ShaderMaterial2.prototype = Object.create(Material2.prototype);
    ShaderMaterial2.prototype.constructor = ShaderMaterial2;
    ShaderMaterial2.prototype.isShaderMaterial = true;
    ShaderMaterial2.prototype.copy = function(source) {
      Material2.prototype.copy.call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms2(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    };
    ShaderMaterial2.prototype.toJSON = function(meta) {
      var data = Material2.prototype.toJSON.call(this, meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (var name2 in this.uniforms) {
        var uniform = this.uniforms[name2];
        var value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name2] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name2] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name2] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name2] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name2] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name2] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name2] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name2] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      var extensions = {};
      for (var key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    };
    function Camera2() {
      Object3D2.call(this);
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix43();
      this.projectionMatrix = new Matrix43();
      this.projectionMatrixInverse = new Matrix43();
    }
    Camera2.prototype = Object.assign(Object.create(Object3D2.prototype), {
      constructor: Camera2,
      isCamera: true,
      copy: function copy(source, recursive) {
        Object3D2.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      },
      getWorldDirection: function getWorldDirection(target) {
        if (target === void 0) {
          console.warn("THREE.Camera: .getWorldDirection() target is now required");
          target = new Vector32();
        }
        this.updateWorldMatrix(true, false);
        var e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
      },
      updateMatrixWorld: function updateMatrixWorld(force) {
        Object3D2.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      },
      updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
        Object3D2.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      },
      clone: function clone() {
        return new this.constructor().copy(this);
      }
    });
    function PerspectiveCamera3(fov3, aspect3, near, far) {
      if (fov3 === void 0) {
        fov3 = 50;
      }
      if (aspect3 === void 0) {
        aspect3 = 1;
      }
      if (near === void 0) {
        near = 0.1;
      }
      if (far === void 0) {
        far = 2e3;
      }
      Camera2.call(this);
      this.type = "PerspectiveCamera";
      this.fov = fov3;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect3;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    PerspectiveCamera3.prototype = Object.assign(Object.create(Camera2.prototype), {
      constructor: PerspectiveCamera3,
      isPerspectiveCamera: true,
      copy: function copy(source, recursive) {
        Camera2.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      },
      setFocalLength: function setFocalLength(focalLength) {
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils2.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      },
      getFocalLength: function getFocalLength() {
        var vExtentSlope = Math.tan(MathUtils2.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      },
      getEffectiveFOV: function getEffectiveFOV() {
        return MathUtils2.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils2.DEG2RAD * 0.5 * this.fov) / this.zoom);
      },
      getFilmWidth: function getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      },
      clearViewOffset: function clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function updateProjectionMatrix() {
        var near = this.near;
        var top = near * Math.tan(MathUtils2.DEG2RAD * 0.5 * this.fov) / this.zoom;
        var height = 2 * top;
        var width = this.aspect * height;
        var left = -0.5 * width;
        var view = this.view;
        if (this.view !== null && this.view.enabled) {
          var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      },
      toJSON: function toJSON2(meta) {
        var data = Object3D2.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    });
    var fov2 = 90, aspect2 = 1;
    var CubeCamera2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(CubeCamera3, _Object3D);
      function CubeCamera3(near, far, renderTarget) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "CubeCamera";
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
          console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          return _assertThisInitialized(_this);
        }
        _this.renderTarget = renderTarget;
        var cameraPX = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraPX.layers = _this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector32(1, 0, 0));
        _this.add(cameraPX);
        var cameraNX = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraNX.layers = _this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector32(-1, 0, 0));
        _this.add(cameraNX);
        var cameraPY = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraPY.layers = _this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector32(0, 1, 0));
        _this.add(cameraPY);
        var cameraNY = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraNY.layers = _this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector32(0, -1, 0));
        _this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraPZ.layers = _this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector32(0, 0, 1));
        _this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera3(fov2, aspect2, near, far);
        cameraNZ.layers = _this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector32(0, 0, -1));
        _this.add(cameraNZ);
        return _this;
      }
      var _proto = CubeCamera3.prototype;
      _proto.update = function update(renderer2, scene2) {
        if (this.parent === null)
          this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var _this$children = this.children, cameraPX = _this$children[0], cameraNX = _this$children[1], cameraPY = _this$children[2], cameraNY = _this$children[3], cameraPZ = _this$children[4], cameraNZ = _this$children[5];
        var currentXrEnabled = renderer2.xr.enabled;
        var currentRenderTarget = renderer2.getRenderTarget();
        renderer2.xr.enabled = false;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer2.setRenderTarget(renderTarget, 0);
        renderer2.render(scene2, cameraPX);
        renderer2.setRenderTarget(renderTarget, 1);
        renderer2.render(scene2, cameraNX);
        renderer2.setRenderTarget(renderTarget, 2);
        renderer2.render(scene2, cameraPY);
        renderer2.setRenderTarget(renderTarget, 3);
        renderer2.render(scene2, cameraNY);
        renderer2.setRenderTarget(renderTarget, 4);
        renderer2.render(scene2, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer2.setRenderTarget(renderTarget, 5);
        renderer2.render(scene2, cameraNZ);
        renderer2.setRenderTarget(currentRenderTarget);
        renderer2.xr.enabled = currentXrEnabled;
      };
      return CubeCamera3;
    }(Object3D2);
    var CubeTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(CubeTexture3, _Texture);
      function CubeTexture3(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        var _this;
        images = images !== void 0 ? images : [];
        mapping = mapping !== void 0 ? mapping : CubeReflectionMapping2;
        format = format !== void 0 ? format : RGBFormat2;
        _this = _Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
        _this._needsFlipEnvMap = true;
        _this.flipY = false;
        return _this;
      }
      _createClass(CubeTexture3, [{
        key: "images",
        get: function get() {
          return this.image;
        },
        set: function set(value) {
          this.image = value;
        }
      }]);
      return CubeTexture3;
    }(Texture2);
    CubeTexture2.prototype.isCubeTexture = true;
    var WebGLCubeRenderTarget2 = /* @__PURE__ */ function(_WebGLRenderTarget) {
      _inheritsLoose(WebGLCubeRenderTarget3, _WebGLRenderTarget);
      function WebGLCubeRenderTarget3(size, options, dummy) {
        var _this;
        if (Number.isInteger(options)) {
          console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
          options = dummy;
        }
        _this = _WebGLRenderTarget.call(this, size, size, options) || this;
        options = options || {};
        _this.texture = new CubeTexture2(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        _this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        _this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter2;
        _this.texture._needsFlipEnvMap = false;
        return _this;
      }
      var _proto = WebGLCubeRenderTarget3.prototype;
      _proto.fromEquirectangularTexture = function fromEquirectangularTexture(renderer2, texture) {
        this.texture.type = texture.type;
        this.texture.format = RGBAFormat2;
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        var shader = {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			",
          fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			"
        };
        var geometry = new BoxGeometry2(5, 5, 5);
        var material = new ShaderMaterial2({
          name: "CubemapFromEquirect",
          uniforms: cloneUniforms2(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide2,
          blending: NoBlending2
        });
        material.uniforms.tEquirect.value = texture;
        var mesh = new Mesh3(geometry, material);
        var currentMinFilter = texture.minFilter;
        if (texture.minFilter === LinearMipmapLinearFilter2)
          texture.minFilter = LinearFilter2;
        var camera2 = new CubeCamera2(1, 10, this);
        camera2.update(renderer2, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      };
      _proto.clear = function clear(renderer2, color, depth, stencil) {
        var currentRenderTarget = renderer2.getRenderTarget();
        for (var i2 = 0; i2 < 6; i2++) {
          renderer2.setRenderTarget(this, i2);
          renderer2.clear(color, depth, stencil);
        }
        renderer2.setRenderTarget(currentRenderTarget);
      };
      return WebGLCubeRenderTarget3;
    }(WebGLRenderTarget2);
    WebGLCubeRenderTarget2.prototype.isWebGLCubeRenderTarget = true;
    var DataTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(DataTexture3, _Texture);
      function DataTexture3(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        var _this;
        _this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
        _this.image = {
          data: data || null,
          width: width || 1,
          height: height || 1
        };
        _this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter2;
        _this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter2;
        _this.generateMipmaps = false;
        _this.flipY = false;
        _this.unpackAlignment = 1;
        _this.needsUpdate = true;
        return _this;
      }
      return DataTexture3;
    }(Texture2);
    DataTexture2.prototype.isDataTexture = true;
    var _sphere$12 = /* @__PURE__ */ new Sphere2();
    var _vector$52 = /* @__PURE__ */ new Vector32();
    var Frustum2 = /* @__PURE__ */ function() {
      function Frustum3(p0, p1, p2, p3, p4, p5) {
        if (p0 === void 0) {
          p0 = new Plane2();
        }
        if (p1 === void 0) {
          p1 = new Plane2();
        }
        if (p2 === void 0) {
          p2 = new Plane2();
        }
        if (p3 === void 0) {
          p3 = new Plane2();
        }
        if (p4 === void 0) {
          p4 = new Plane2();
        }
        if (p5 === void 0) {
          p5 = new Plane2();
        }
        this.planes = [p0, p1, p2, p3, p4, p5];
      }
      var _proto = Frustum3.prototype;
      _proto.set = function set(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      };
      _proto.copy = function copy(frustum) {
        var planes = this.planes;
        for (var i2 = 0; i2 < 6; i2++) {
          planes[i2].copy(frustum.planes[i2]);
        }
        return this;
      };
      _proto.setFromProjectionMatrix = function setFromProjectionMatrix(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      };
      _proto.intersectsObject = function intersectsObject(object) {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$12.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$12);
      };
      _proto.intersectsSprite = function intersectsSprite(sprite) {
        _sphere$12.center.set(0, 0, 0);
        _sphere$12.radius = 0.7071067811865476;
        _sphere$12.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$12);
      };
      _proto.intersectsSphere = function intersectsSphere(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i2 = 0; i2 < 6; i2++) {
          var distance = planes[i2].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      };
      _proto.intersectsBox = function intersectsBox(box) {
        var planes = this.planes;
        for (var i2 = 0; i2 < 6; i2++) {
          var plane = planes[i2];
          _vector$52.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$52.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$52.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$52) < 0) {
            return false;
          }
        }
        return true;
      };
      _proto.containsPoint = function containsPoint(point) {
        var planes = this.planes;
        for (var i2 = 0; i2 < 6; i2++) {
          if (planes[i2].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Frustum3;
    }();
    function WebGLAnimation2() {
      var context = null;
      var isAnimating = false;
      var animationLoop = null;
      var requestId = null;
      function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
      }
      return {
        start: function start() {
          if (isAnimating === true)
            return;
          if (animationLoop === null)
            return;
          requestId = context.requestAnimationFrame(onAnimationFrame);
          isAnimating = true;
        },
        stop: function stop() {
          context.cancelAnimationFrame(requestId);
          isAnimating = false;
        },
        setAnimationLoop: function setAnimationLoop(callback) {
          animationLoop = callback;
        },
        setContext: function setContext(value) {
          context = value;
        }
      };
    }
    function WebGLAttributes2(gl, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      var buffers = new WeakMap();
      function createBuffer(attribute, bufferType) {
        var array = attribute.array;
        var usage = attribute.usage;
        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        var type = 5126;
        if (array instanceof Float32Array) {
          type = 5126;
        } else if (array instanceof Float64Array) {
          console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
        } else if (array instanceof Uint16Array) {
          if (attribute.isFloat16BufferAttribute) {
            if (isWebGL2) {
              type = 5131;
            } else {
              console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            }
          } else {
            type = 5123;
          }
        } else if (array instanceof Int16Array) {
          type = 5122;
        } else if (array instanceof Uint32Array) {
          type = 5125;
        } else if (array instanceof Int32Array) {
          type = 5124;
        } else if (array instanceof Int8Array) {
          type = 5120;
        } else if (array instanceof Uint8Array) {
          type = 5121;
        }
        return {
          buffer,
          type,
          bytesPerElement: array.BYTES_PER_ELEMENT,
          version: attribute.version
        };
      }
      function updateBuffer(buffer, attribute, bufferType) {
        var array = attribute.array;
        var updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) {
          gl.bufferSubData(bufferType, 0, array);
        } else {
          if (isWebGL2) {
            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
          } else {
            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
          }
          updateRange.count = -1;
        }
      }
      function get(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        return buffers.get(attribute);
      }
      function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data) {
          gl.deleteBuffer(data.buffer);
          buffers.delete(attribute);
        }
      }
      function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
          var cached = buffers.get(attribute);
          if (!cached || cached.version < attribute.version) {
            buffers.set(attribute, {
              buffer: attribute.buffer,
              type: attribute.type,
              bytesPerElement: attribute.elementSize,
              version: attribute.version
            });
          }
          return;
        }
        if (attribute.isInterleavedBufferAttribute)
          attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data === void 0) {
          buffers.set(attribute, createBuffer(attribute, bufferType));
        } else if (data.version < attribute.version) {
          updateBuffer(data.buffer, attribute, bufferType);
          data.version = attribute.version;
        }
      }
      return {
        get,
        remove,
        update
      };
    }
    var PlaneGeometry2 = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(PlaneGeometry3, _BufferGeometry);
      function PlaneGeometry3(width, height, widthSegments, heightSegments) {
        var _this;
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (widthSegments === void 0) {
          widthSegments = 1;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "PlaneGeometry";
        _this.parameters = {
          width,
          height,
          widthSegments,
          heightSegments
        };
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments);
        var gridY = Math.floor(heightSegments);
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (var iy = 0; iy < gridY1; iy++) {
          var y = iy * segment_height - height_half;
          for (var ix = 0; ix < gridX1; ix++) {
            var x = ix * segment_width - width_half;
            vertices.push(x, -y, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
          }
        }
        for (var _iy = 0; _iy < gridY; _iy++) {
          for (var _ix = 0; _ix < gridX; _ix++) {
            var a = _ix + gridX1 * _iy;
            var b = _ix + gridX1 * (_iy + 1);
            var c = _ix + 1 + gridX1 * (_iy + 1);
            var d = _ix + 1 + gridX1 * _iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        return _this;
      }
      return PlaneGeometry3;
    }(BufferGeometry3);
    var alphamap_fragment2 = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    var alphamap_pars_fragment2 = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var alphatest_fragment2 = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
    var aomap_fragment2 = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
    var aomap_pars_fragment2 = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    var begin_vertex2 = "vec3 transformed = vec3( position );";
    var beginnormal_vertex2 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    var bsdfs2 = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
    var bumpmap_pars_fragment2 = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    var clipping_planes_fragment2 = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
    var clipping_planes_pars_fragment2 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    var clipping_planes_pars_vertex2 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
    var clipping_planes_vertex2 = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
    var color_fragment2 = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment2 = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
    var color_pars_vertex2 = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
    var color_vertex2 = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
    var common2 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
    var cube_uv_reflection_fragment2 = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
    var defaultnormal_vertex2 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    var displacementmap_pars_vertex2 = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    var displacementmap_vertex2 = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    var emissivemap_fragment2 = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    var emissivemap_pars_fragment2 = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    var encodings_fragment2 = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    var encodings_pars_fragment2 = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
    var envmap_fragment2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    var envmap_common_pars_fragment2 = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    var envmap_pars_fragment2 = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    var envmap_pars_vertex2 = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    var envmap_vertex2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    var fog_vertex2 = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
    var fog_pars_vertex2 = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
    var fog_fragment2 = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    var fog_pars_fragment2 = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    var gradientmap_pars_fragment2 = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
    var lightmap_fragment2 = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
    var lightmap_pars_fragment2 = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex2 = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
    var lights_pars_begin2 = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
    var envmap_physical_pars_fragment2 = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
    var lights_toon_fragment2 = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    var lights_toon_pars_fragment2 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
    var lights_phong_fragment2 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_phong_pars_fragment2 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
    var lights_physical_fragment2 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
    var lights_physical_pars_fragment2 = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    var lights_fragment_begin2 = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    var lights_fragment_maps2 = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
    var lights_fragment_end2 = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    var logdepthbuf_fragment2 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment2 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    var logdepthbuf_pars_vertex2 = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
    var logdepthbuf_vertex2 = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
    var map_fragment2 = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
    var map_pars_fragment2 = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    var map_particle_fragment2 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    var map_particle_pars_fragment2 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    var metalnessmap_fragment2 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    var metalnessmap_pars_fragment2 = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex2 = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
    var morphtarget_pars_vertex2 = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
    var morphtarget_vertex2 = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
    var normal_fragment_begin2 = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
    var normal_fragment_maps2 = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    var normalmap_pars_fragment2 = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
    var clearcoat_normal_fragment_begin2 = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
    var clearcoat_normal_fragment_maps2 = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
    var clearcoat_pars_fragment2 = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
    var packing2 = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    var premultiplied_alpha_fragment2 = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    var project_vertex2 = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    var dithering_fragment2 = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    var dithering_pars_fragment2 = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    var roughnessmap_fragment2 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    var roughnessmap_pars_fragment2 = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
    var shadowmap_pars_vertex2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    var shadowmap_vertex2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
    var shadowmask_pars_fragment2 = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
    var skinbase_vertex2 = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex2 = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
    var skinning_vertex2 = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    var skinnormal_vertex2 = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    var specularmap_fragment2 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment2 = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment2 = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    var tonemapping_pars_fragment2 = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    var transmissionmap_fragment2 = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
    var transmissionmap_pars_fragment2 = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
    var uv_pars_fragment2 = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
    var uv_pars_vertex2 = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    var uv_vertex2 = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    var uv2_pars_vertex2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
    var uv2_vertex2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    var worldpos_vertex2 = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    var background_frag2 = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var background_vert2 = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    var cube_frag2 = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var cube_vert2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    var depth_frag2 = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
    var depth_vert2 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
    var distanceRGBA_frag2 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    var distanceRGBA_vert2 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    var equirect_frag2 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    var equirect_vert2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    var linedashed_frag2 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    var linedashed_vert2 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var meshbasic_frag2 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshbasic_vert2 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    var meshlambert_frag2 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshlambert_vert2 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshmatcap_frag2 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshmatcap_vert2 = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    var meshtoon_frag2 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshtoon_vert2 = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshphong_frag2 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshphong_vert2 = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var meshphysical_frag2 = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    var meshphysical_vert2 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var normal_frag2 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
    var normal_vert2 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    var points_frag2 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    var points_vert2 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    var shadow_frag2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var shadow_vert2 = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    var sprite_frag2 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    var sprite_vert2 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    var ShaderChunk2 = {
      alphamap_fragment: alphamap_fragment2,
      alphamap_pars_fragment: alphamap_pars_fragment2,
      alphatest_fragment: alphatest_fragment2,
      aomap_fragment: aomap_fragment2,
      aomap_pars_fragment: aomap_pars_fragment2,
      begin_vertex: begin_vertex2,
      beginnormal_vertex: beginnormal_vertex2,
      bsdfs: bsdfs2,
      bumpmap_pars_fragment: bumpmap_pars_fragment2,
      clipping_planes_fragment: clipping_planes_fragment2,
      clipping_planes_pars_fragment: clipping_planes_pars_fragment2,
      clipping_planes_pars_vertex: clipping_planes_pars_vertex2,
      clipping_planes_vertex: clipping_planes_vertex2,
      color_fragment: color_fragment2,
      color_pars_fragment: color_pars_fragment2,
      color_pars_vertex: color_pars_vertex2,
      color_vertex: color_vertex2,
      common: common2,
      cube_uv_reflection_fragment: cube_uv_reflection_fragment2,
      defaultnormal_vertex: defaultnormal_vertex2,
      displacementmap_pars_vertex: displacementmap_pars_vertex2,
      displacementmap_vertex: displacementmap_vertex2,
      emissivemap_fragment: emissivemap_fragment2,
      emissivemap_pars_fragment: emissivemap_pars_fragment2,
      encodings_fragment: encodings_fragment2,
      encodings_pars_fragment: encodings_pars_fragment2,
      envmap_fragment: envmap_fragment2,
      envmap_common_pars_fragment: envmap_common_pars_fragment2,
      envmap_pars_fragment: envmap_pars_fragment2,
      envmap_pars_vertex: envmap_pars_vertex2,
      envmap_physical_pars_fragment: envmap_physical_pars_fragment2,
      envmap_vertex: envmap_vertex2,
      fog_vertex: fog_vertex2,
      fog_pars_vertex: fog_pars_vertex2,
      fog_fragment: fog_fragment2,
      fog_pars_fragment: fog_pars_fragment2,
      gradientmap_pars_fragment: gradientmap_pars_fragment2,
      lightmap_fragment: lightmap_fragment2,
      lightmap_pars_fragment: lightmap_pars_fragment2,
      lights_lambert_vertex: lights_lambert_vertex2,
      lights_pars_begin: lights_pars_begin2,
      lights_toon_fragment: lights_toon_fragment2,
      lights_toon_pars_fragment: lights_toon_pars_fragment2,
      lights_phong_fragment: lights_phong_fragment2,
      lights_phong_pars_fragment: lights_phong_pars_fragment2,
      lights_physical_fragment: lights_physical_fragment2,
      lights_physical_pars_fragment: lights_physical_pars_fragment2,
      lights_fragment_begin: lights_fragment_begin2,
      lights_fragment_maps: lights_fragment_maps2,
      lights_fragment_end: lights_fragment_end2,
      logdepthbuf_fragment: logdepthbuf_fragment2,
      logdepthbuf_pars_fragment: logdepthbuf_pars_fragment2,
      logdepthbuf_pars_vertex: logdepthbuf_pars_vertex2,
      logdepthbuf_vertex: logdepthbuf_vertex2,
      map_fragment: map_fragment2,
      map_pars_fragment: map_pars_fragment2,
      map_particle_fragment: map_particle_fragment2,
      map_particle_pars_fragment: map_particle_pars_fragment2,
      metalnessmap_fragment: metalnessmap_fragment2,
      metalnessmap_pars_fragment: metalnessmap_pars_fragment2,
      morphnormal_vertex: morphnormal_vertex2,
      morphtarget_pars_vertex: morphtarget_pars_vertex2,
      morphtarget_vertex: morphtarget_vertex2,
      normal_fragment_begin: normal_fragment_begin2,
      normal_fragment_maps: normal_fragment_maps2,
      normalmap_pars_fragment: normalmap_pars_fragment2,
      clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin2,
      clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps2,
      clearcoat_pars_fragment: clearcoat_pars_fragment2,
      packing: packing2,
      premultiplied_alpha_fragment: premultiplied_alpha_fragment2,
      project_vertex: project_vertex2,
      dithering_fragment: dithering_fragment2,
      dithering_pars_fragment: dithering_pars_fragment2,
      roughnessmap_fragment: roughnessmap_fragment2,
      roughnessmap_pars_fragment: roughnessmap_pars_fragment2,
      shadowmap_pars_fragment: shadowmap_pars_fragment2,
      shadowmap_pars_vertex: shadowmap_pars_vertex2,
      shadowmap_vertex: shadowmap_vertex2,
      shadowmask_pars_fragment: shadowmask_pars_fragment2,
      skinbase_vertex: skinbase_vertex2,
      skinning_pars_vertex: skinning_pars_vertex2,
      skinning_vertex: skinning_vertex2,
      skinnormal_vertex: skinnormal_vertex2,
      specularmap_fragment: specularmap_fragment2,
      specularmap_pars_fragment: specularmap_pars_fragment2,
      tonemapping_fragment: tonemapping_fragment2,
      tonemapping_pars_fragment: tonemapping_pars_fragment2,
      transmissionmap_fragment: transmissionmap_fragment2,
      transmissionmap_pars_fragment: transmissionmap_pars_fragment2,
      uv_pars_fragment: uv_pars_fragment2,
      uv_pars_vertex: uv_pars_vertex2,
      uv_vertex: uv_vertex2,
      uv2_pars_fragment: uv2_pars_fragment2,
      uv2_pars_vertex: uv2_pars_vertex2,
      uv2_vertex: uv2_vertex2,
      worldpos_vertex: worldpos_vertex2,
      background_frag: background_frag2,
      background_vert: background_vert2,
      cube_frag: cube_frag2,
      cube_vert: cube_vert2,
      depth_frag: depth_frag2,
      depth_vert: depth_vert2,
      distanceRGBA_frag: distanceRGBA_frag2,
      distanceRGBA_vert: distanceRGBA_vert2,
      equirect_frag: equirect_frag2,
      equirect_vert: equirect_vert2,
      linedashed_frag: linedashed_frag2,
      linedashed_vert: linedashed_vert2,
      meshbasic_frag: meshbasic_frag2,
      meshbasic_vert: meshbasic_vert2,
      meshlambert_frag: meshlambert_frag2,
      meshlambert_vert: meshlambert_vert2,
      meshmatcap_frag: meshmatcap_frag2,
      meshmatcap_vert: meshmatcap_vert2,
      meshtoon_frag: meshtoon_frag2,
      meshtoon_vert: meshtoon_vert2,
      meshphong_frag: meshphong_frag2,
      meshphong_vert: meshphong_vert2,
      meshphysical_frag: meshphysical_frag2,
      meshphysical_vert: meshphysical_vert2,
      normal_frag: normal_frag2,
      normal_vert: normal_vert2,
      points_frag: points_frag2,
      points_vert: points_vert2,
      shadow_frag: shadow_frag2,
      shadow_vert: shadow_vert2,
      sprite_frag: sprite_frag2,
      sprite_vert: sprite_vert2
    };
    var UniformsLib2 = {
      common: {
        diffuse: {
          value: new Color5(15658734)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        uvTransform: {
          value: new Matrix32()
        },
        uv2Transform: {
          value: new Matrix32()
        },
        alphaMap: {
          value: null
        }
      },
      specularmap: {
        specularMap: {
          value: null
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        refractionRatio: {
          value: 0.98
        },
        maxMipLevel: {
          value: 0
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalScale: {
          value: new Vector22(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 25e-5
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2e3
        },
        fogColor: {
          value: new Color5(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {}
          }
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          }
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: {
          value: []
        },
        spotShadowMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          }
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        },
        ltc_1: {
          value: null
        },
        ltc_2: {
          value: null
        }
      },
      points: {
        diffuse: {
          value: new Color5(15658734)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new Matrix32()
        }
      },
      sprite: {
        diffuse: {
          value: new Color5(15658734)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new Vector22(0.5, 0.5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new Matrix32()
        }
      }
    };
    var ShaderLib2 = {
      basic: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.fog]),
        vertexShader: ShaderChunk2.meshbasic_vert,
        fragmentShader: ShaderChunk2.meshbasic_frag
      },
      lambert: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.fog, UniformsLib2.lights, {
          emissive: {
            value: new Color5(0)
          }
        }]),
        vertexShader: ShaderChunk2.meshlambert_vert,
        fragmentShader: ShaderChunk2.meshlambert_frag
      },
      phong: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.fog, UniformsLib2.lights, {
          emissive: {
            value: new Color5(0)
          },
          specular: {
            value: new Color5(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: ShaderChunk2.meshphong_vert,
        fragmentShader: ShaderChunk2.meshphong_frag
      },
      standard: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.roughnessmap, UniformsLib2.metalnessmap, UniformsLib2.fog, UniformsLib2.lights, {
          emissive: {
            value: new Color5(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk2.meshphysical_vert,
        fragmentShader: ShaderChunk2.meshphysical_frag
      },
      toon: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.gradientmap, UniformsLib2.fog, UniformsLib2.lights, {
          emissive: {
            value: new Color5(0)
          }
        }]),
        vertexShader: ShaderChunk2.meshtoon_vert,
        fragmentShader: ShaderChunk2.meshtoon_frag
      },
      matcap: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.fog, {
          matcap: {
            value: null
          }
        }]),
        vertexShader: ShaderChunk2.meshmatcap_vert,
        fragmentShader: ShaderChunk2.meshmatcap_frag
      },
      points: {
        uniforms: mergeUniforms2([UniformsLib2.points, UniformsLib2.fog]),
        vertexShader: ShaderChunk2.points_vert,
        fragmentShader: ShaderChunk2.points_frag
      },
      dashed: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.fog, {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }]),
        vertexShader: ShaderChunk2.linedashed_vert,
        fragmentShader: ShaderChunk2.linedashed_frag
      },
      depth: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.displacementmap]),
        vertexShader: ShaderChunk2.depth_vert,
        fragmentShader: ShaderChunk2.depth_frag
      },
      normal: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk2.normal_vert,
        fragmentShader: ShaderChunk2.normal_frag
      },
      sprite: {
        uniforms: mergeUniforms2([UniformsLib2.sprite, UniformsLib2.fog]),
        vertexShader: ShaderChunk2.sprite_vert,
        fragmentShader: ShaderChunk2.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new Matrix32()
          },
          t2D: {
            value: null
          }
        },
        vertexShader: ShaderChunk2.background_vert,
        fragmentShader: ShaderChunk2.background_frag
      },
      cube: {
        uniforms: mergeUniforms2([UniformsLib2.envmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk2.cube_vert,
        fragmentShader: ShaderChunk2.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: ShaderChunk2.equirect_vert,
        fragmentShader: ShaderChunk2.equirect_frag
      },
      distanceRGBA: {
        uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.displacementmap, {
          referencePosition: {
            value: new Vector32()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }]),
        vertexShader: ShaderChunk2.distanceRGBA_vert,
        fragmentShader: ShaderChunk2.distanceRGBA_frag
      },
      shadow: {
        uniforms: mergeUniforms2([UniformsLib2.lights, UniformsLib2.fog, {
          color: {
            value: new Color5(0)
          },
          opacity: {
            value: 1
          }
        }]),
        vertexShader: ShaderChunk2.shadow_vert,
        fragmentShader: ShaderChunk2.shadow_frag
      }
    };
    ShaderLib2.physical = {
      uniforms: mergeUniforms2([ShaderLib2.standard.uniforms, {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatNormalScale: {
          value: new Vector22(1, 1)
        },
        clearcoatNormalMap: {
          value: null
        },
        sheen: {
          value: new Color5(0)
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        }
      }]),
      vertexShader: ShaderChunk2.meshphysical_vert,
      fragmentShader: ShaderChunk2.meshphysical_frag
    };
    function WebGLBackground2(renderer2, cubemaps, state, objects, premultipliedAlpha) {
      var clearColor = new Color5(0);
      var clearAlpha = 0;
      var planeMesh;
      var boxMesh;
      var currentBackground = null;
      var currentBackgroundVersion = 0;
      var currentTonemapping = null;
      function render(renderList, scene2, camera2, forceClear) {
        var background = scene2.isScene === true ? scene2.background : null;
        if (background && background.isTexture) {
          background = cubemaps.get(background);
        }
        var xr = renderer2.xr;
        var session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === "additive") {
          background = null;
        }
        if (background === null) {
          setClear(clearColor, clearAlpha);
        } else if (background && background.isColor) {
          setClear(background, 1);
          forceClear = true;
        }
        if (renderer2.autoClear || forceClear) {
          renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
        }
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping2)) {
          if (boxMesh === void 0) {
            boxMesh = new Mesh3(new BoxGeometry2(1, 1, 1), new ShaderMaterial2({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms2(ShaderLib2.cube.uniforms),
              vertexShader: ShaderLib2.cube.vertexShader,
              fragmentShader: ShaderLib2.cube.fragmentShader,
              side: BackSide2,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            boxMesh.geometry.deleteAttribute("normal");
            boxMesh.geometry.deleteAttribute("uv");
            boxMesh.onBeforeRender = function(renderer3, scene3, camera3) {
              this.matrixWorld.copyPosition(camera3.matrixWorld);
            };
            Object.defineProperty(boxMesh.material, "envMap", {
              get: function get() {
                return this.uniforms.envMap.value;
              }
            });
            objects.update(boxMesh);
          }
          if (background.isWebGLCubeRenderTarget) {
            background = background.texture;
          }
          boxMesh.material.uniforms.envMap.value = background;
          boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
          if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
            boxMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = background.version;
            currentTonemapping = renderer2.toneMapping;
          }
          renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
          if (planeMesh === void 0) {
            planeMesh = new Mesh3(new PlaneGeometry2(2, 2), new ShaderMaterial2({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms2(ShaderLib2.background.uniforms),
              vertexShader: ShaderLib2.background.vertexShader,
              fragmentShader: ShaderLib2.background.fragmentShader,
              side: FrontSide2,
              depthTest: false,
              depthWrite: false,
              fog: false
            }));
            planeMesh.geometry.deleteAttribute("normal");
            Object.defineProperty(planeMesh.material, "map", {
              get: function get() {
                return this.uniforms.t2D.value;
              }
            });
            objects.update(planeMesh);
          }
          planeMesh.material.uniforms.t2D.value = background;
          if (background.matrixAutoUpdate === true) {
            background.updateMatrix();
          }
          planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
          if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
            planeMesh.material.needsUpdate = true;
            currentBackground = background;
            currentBackgroundVersion = background.version;
            currentTonemapping = renderer2.toneMapping;
          }
          renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
      }
      function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
      }
      return {
        getClearColor: function getClearColor() {
          return clearColor;
        },
        setClearColor: function setClearColor(color, alpha) {
          if (alpha === void 0) {
            alpha = 1;
          }
          clearColor.set(color);
          clearAlpha = alpha;
          setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function getClearAlpha() {
          return clearAlpha;
        },
        setClearAlpha: function setClearAlpha(alpha) {
          clearAlpha = alpha;
          setClear(clearColor, clearAlpha);
        },
        render
      };
    }
    function WebGLBindingStates2(gl, extensions, attributes, capabilities) {
      var maxVertexAttributes = gl.getParameter(34921);
      var extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
      var vaoAvailable = capabilities.isWebGL2 || extension !== null;
      var bindingStates = {};
      var defaultState = createBindingState(null);
      var currentState = defaultState;
      function setup(object, material, program, geometry, index) {
        var updateBuffers = false;
        if (vaoAvailable) {
          var state = getBindingState(geometry, program, material);
          if (currentState !== state) {
            currentState = state;
            bindVertexArrayObject(currentState.object);
          }
          updateBuffers = needsUpdate(geometry, index);
          if (updateBuffers)
            saveCache(geometry, index);
        } else {
          var wireframe = material.wireframe === true;
          if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
            currentState.geometry = geometry.id;
            currentState.program = program.id;
            currentState.wireframe = wireframe;
            updateBuffers = true;
          }
        }
        if (object.isInstancedMesh === true) {
          updateBuffers = true;
        }
        if (index !== null) {
          attributes.update(index, 34963);
        }
        if (updateBuffers) {
          setupVertexAttributes(object, material, program, geometry);
          if (index !== null) {
            gl.bindBuffer(34963, attributes.get(index).buffer);
          }
        }
      }
      function createVertexArrayObject() {
        if (capabilities.isWebGL2)
          return gl.createVertexArray();
        return extension.createVertexArrayOES();
      }
      function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2)
          return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
      }
      function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2)
          return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
      }
      function getBindingState(geometry, program, material) {
        var wireframe = material.wireframe === true;
        var programMap = bindingStates[geometry.id];
        if (programMap === void 0) {
          programMap = {};
          bindingStates[geometry.id] = programMap;
        }
        var stateMap = programMap[program.id];
        if (stateMap === void 0) {
          stateMap = {};
          programMap[program.id] = stateMap;
        }
        var state = stateMap[wireframe];
        if (state === void 0) {
          state = createBindingState(createVertexArrayObject());
          stateMap[wireframe] = state;
        }
        return state;
      }
      function createBindingState(vao) {
        var newAttributes = [];
        var enabledAttributes = [];
        var attributeDivisors = [];
        for (var i2 = 0; i2 < maxVertexAttributes; i2++) {
          newAttributes[i2] = 0;
          enabledAttributes[i2] = 0;
          attributeDivisors[i2] = 0;
        }
        return {
          geometry: null,
          program: null,
          wireframe: false,
          newAttributes,
          enabledAttributes,
          attributeDivisors,
          object: vao,
          attributes: {},
          index: null
        };
      }
      function needsUpdate(geometry, index) {
        var cachedAttributes = currentState.attributes;
        var geometryAttributes = geometry.attributes;
        var attributesNum = 0;
        for (var key in geometryAttributes) {
          var cachedAttribute = cachedAttributes[key];
          var geometryAttribute = geometryAttributes[key];
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
        if (currentState.attributesNum !== attributesNum)
          return true;
        if (currentState.index !== index)
          return true;
        return false;
      }
      function saveCache(geometry, index) {
        var cache = {};
        var attributes2 = geometry.attributes;
        var attributesNum = 0;
        for (var key in attributes2) {
          var attribute = attributes2[key];
          var data = {};
          data.attribute = attribute;
          if (attribute.data) {
            data.data = attribute.data;
          }
          cache[key] = data;
          attributesNum++;
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index;
      }
      function initAttributes() {
        var newAttributes = currentState.newAttributes;
        for (var i2 = 0, il = newAttributes.length; i2 < il; i2++) {
          newAttributes[i2] = 0;
        }
      }
      function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
      }
      function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        var newAttributes = currentState.newAttributes;
        var enabledAttributes = currentState.enabledAttributes;
        var attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
          var _extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
          _extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
          attributeDivisors[attribute] = meshPerAttribute;
        }
      }
      function disableUnusedAttributes() {
        var newAttributes = currentState.newAttributes;
        var enabledAttributes = currentState.enabledAttributes;
        for (var i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
          if (enabledAttributes[i2] !== newAttributes[i2]) {
            gl.disableVertexAttribArray(i2);
            enabledAttributes[i2] = 0;
          }
        }
      }
      function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
          gl.vertexAttribIPointer(index, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
        }
      }
      function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
          if (extensions.get("ANGLE_instanced_arrays") === null)
            return;
        }
        initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for (var name2 in programAttributes) {
          var programAttribute = programAttributes[name2];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[name2];
            if (geometryAttribute !== void 0) {
              var normalized = geometryAttribute.normalized;
              var size = geometryAttribute.itemSize;
              var attribute = attributes.get(geometryAttribute);
              if (attribute === void 0)
                continue;
              var buffer = attribute.buffer;
              var type = attribute.type;
              var bytesPerElement = attribute.bytesPerElement;
              if (geometryAttribute.isInterleavedBufferAttribute) {
                var data = geometryAttribute.data;
                var stride = data.stride;
                var offset = geometryAttribute.offset;
                if (data && data.isInstancedInterleavedBuffer) {
                  enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                  if (geometry._maxInstanceCount === void 0) {
                    geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                  }
                } else {
                  enableAttribute(programAttribute);
                }
                gl.bindBuffer(34962, buffer);
                vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
              } else {
                if (geometryAttribute.isInstancedBufferAttribute) {
                  enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                  if (geometry._maxInstanceCount === void 0) {
                    geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                  }
                } else {
                  enableAttribute(programAttribute);
                }
                gl.bindBuffer(34962, buffer);
                vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
              }
            } else if (name2 === "instanceMatrix") {
              var _attribute = attributes.get(object.instanceMatrix);
              if (_attribute === void 0)
                continue;
              var _buffer = _attribute.buffer;
              var _type = _attribute.type;
              enableAttributeAndDivisor(programAttribute + 0, 1);
              enableAttributeAndDivisor(programAttribute + 1, 1);
              enableAttributeAndDivisor(programAttribute + 2, 1);
              enableAttributeAndDivisor(programAttribute + 3, 1);
              gl.bindBuffer(34962, _buffer);
              gl.vertexAttribPointer(programAttribute + 0, 4, _type, false, 64, 0);
              gl.vertexAttribPointer(programAttribute + 1, 4, _type, false, 64, 16);
              gl.vertexAttribPointer(programAttribute + 2, 4, _type, false, 64, 32);
              gl.vertexAttribPointer(programAttribute + 3, 4, _type, false, 64, 48);
            } else if (name2 === "instanceColor") {
              var _attribute2 = attributes.get(object.instanceColor);
              if (_attribute2 === void 0)
                continue;
              var _buffer2 = _attribute2.buffer;
              var _type2 = _attribute2.type;
              enableAttributeAndDivisor(programAttribute, 1);
              gl.bindBuffer(34962, _buffer2);
              gl.vertexAttribPointer(programAttribute, 3, _type2, false, 12, 0);
            } else if (materialDefaultAttributeValues !== void 0) {
              var value = materialDefaultAttributeValues[name2];
              if (value !== void 0) {
                switch (value.length) {
                  case 2:
                    gl.vertexAttrib2fv(programAttribute, value);
                    break;
                  case 3:
                    gl.vertexAttrib3fv(programAttribute, value);
                    break;
                  case 4:
                    gl.vertexAttrib4fv(programAttribute, value);
                    break;
                  default:
                    gl.vertexAttrib1fv(programAttribute, value);
                }
              }
            }
          }
        }
        disableUnusedAttributes();
      }
      function dispose() {
        reset();
        for (var geometryId in bindingStates) {
          var programMap = bindingStates[geometryId];
          for (var programId in programMap) {
            var stateMap = programMap[programId];
            for (var wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometryId];
        }
      }
      function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === void 0)
          return;
        var programMap = bindingStates[geometry.id];
        for (var programId in programMap) {
          var stateMap = programMap[programId];
          for (var wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometry.id];
      }
      function releaseStatesOfProgram(program) {
        for (var geometryId in bindingStates) {
          var programMap = bindingStates[geometryId];
          if (programMap[program.id] === void 0)
            continue;
          var stateMap = programMap[program.id];
          for (var wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[program.id];
        }
      }
      function reset() {
        resetDefaultState();
        if (currentState === defaultState)
          return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
      }
      function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
      }
      return {
        setup,
        reset,
        resetDefaultState,
        dispose,
        releaseStatesOfGeometry,
        releaseStatesOfProgram,
        initAttributes,
        enableAttribute,
        disableUnusedAttributes
      };
    }
    function WebGLBufferRenderer2(gl, extensions, info, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      var mode;
      function setMode(value) {
        mode = value;
      }
      function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
      }
      function renderInstances(start, count, primcount) {
        if (primcount === 0)
          return;
        var extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawArraysInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawArraysInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.render = render;
      this.renderInstances = renderInstances;
    }
    function WebGLCapabilities2(gl, extensions, parameters) {
      var maxAnisotropy;
      function getMaxAnisotropy() {
        if (maxAnisotropy !== void 0)
          return maxAnisotropy;
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
          var extension = extensions.get("EXT_texture_filter_anisotropic");
          maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
          maxAnisotropy = 0;
        }
        return maxAnisotropy;
      }
      function getMaxPrecision(precision2) {
        if (precision2 === "highp") {
          if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
            return "highp";
          }
          precision2 = "mediump";
        }
        if (precision2 === "mediump") {
          if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
            return "mediump";
          }
        }
        return "lowp";
      }
      var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
      var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
      var maxPrecision = getMaxPrecision(precision);
      if (maxPrecision !== precision) {
        console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
        precision = maxPrecision;
      }
      var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
      var maxTextures = gl.getParameter(34930);
      var maxVertexTextures = gl.getParameter(35660);
      var maxTextureSize = gl.getParameter(3379);
      var maxCubemapSize = gl.getParameter(34076);
      var maxAttributes = gl.getParameter(34921);
      var maxVertexUniforms = gl.getParameter(36347);
      var maxVaryings = gl.getParameter(36348);
      var maxFragmentUniforms = gl.getParameter(36349);
      var vertexTextures = maxVertexTextures > 0;
      var floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
      var floatVertexTextures = vertexTextures && floatFragmentTextures;
      var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
      return {
        isWebGL2,
        getMaxAnisotropy,
        getMaxPrecision,
        precision,
        logarithmicDepthBuffer,
        maxTextures,
        maxVertexTextures,
        maxTextureSize,
        maxCubemapSize,
        maxAttributes,
        maxVertexUniforms,
        maxVaryings,
        maxFragmentUniforms,
        vertexTextures,
        floatFragmentTextures,
        floatVertexTextures,
        maxSamples
      };
    }
    function WebGLClipping2(properties) {
      var scope = this;
      var globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
      var plane = new Plane2(), viewNormalMatrix = new Matrix32(), uniform = {
        value: null,
        needsUpdate: false
      };
      this.uniform = uniform;
      this.numPlanes = 0;
      this.numIntersection = 0;
      this.init = function(planes, enableLocalClipping, camera2) {
        var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera2, 0);
        numGlobalPlanes = planes.length;
        return enabled;
      };
      this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
      };
      this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
      };
      this.setState = function(material, camera2, useCache) {
        var planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        var materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
          if (renderingShadows) {
            projectPlanes(null);
          } else {
            resetGlobalState();
          }
        } else {
          var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
          var dstArray = materialProperties.clippingState || null;
          uniform.value = dstArray;
          dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
          for (var i2 = 0; i2 !== lGlobal; ++i2) {
            dstArray[i2] = globalState[i2];
          }
          materialProperties.clippingState = dstArray;
          this.numIntersection = clipIntersection ? this.numPlanes : 0;
          this.numPlanes += nGlobal;
        }
      };
      function resetGlobalState() {
        if (uniform.value !== globalState) {
          uniform.value = globalState;
          uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
      }
      function projectPlanes(planes, camera2, dstOffset, skipTransform) {
        var nPlanes = planes !== null ? planes.length : 0;
        var dstArray = null;
        if (nPlanes !== 0) {
          dstArray = uniform.value;
          if (skipTransform !== true || dstArray === null) {
            var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
            viewNormalMatrix.getNormalMatrix(viewMatrix);
            if (dstArray === null || dstArray.length < flatSize) {
              dstArray = new Float32Array(flatSize);
            }
            for (var i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
              plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
              plane.normal.toArray(dstArray, i4);
              dstArray[i4 + 3] = plane.constant;
            }
          }
          uniform.value = dstArray;
          uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
      }
    }
    function WebGLCubeMaps2(renderer2) {
      var cubemaps = new WeakMap();
      function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping2) {
          texture.mapping = CubeReflectionMapping2;
        } else if (mapping === EquirectangularRefractionMapping2) {
          texture.mapping = CubeRefractionMapping2;
        }
        return texture;
      }
      function get(texture) {
        if (texture && texture.isTexture) {
          var mapping = texture.mapping;
          if (mapping === EquirectangularReflectionMapping2 || mapping === EquirectangularRefractionMapping2) {
            if (cubemaps.has(texture)) {
              var cubemap = cubemaps.get(texture).texture;
              return mapTextureMapping(cubemap, texture.mapping);
            } else {
              var image = texture.image;
              if (image && image.height > 0) {
                var currentRenderTarget = renderer2.getRenderTarget();
                var renderTarget = new WebGLCubeRenderTarget2(image.height / 2);
                renderTarget.fromEquirectangularTexture(renderer2, texture);
                cubemaps.set(texture, renderTarget);
                renderer2.setRenderTarget(currentRenderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return mapTextureMapping(renderTarget.texture, texture.mapping);
              } else {
                return null;
              }
            }
          }
        }
        return texture;
      }
      function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        var cubemap = cubemaps.get(texture);
        if (cubemap !== void 0) {
          cubemaps.delete(texture);
          cubemap.dispose();
        }
      }
      function dispose() {
        cubemaps = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    function WebGLExtensions2(gl) {
      var extensions = {};
      function getExtension(name2) {
        if (extensions[name2] !== void 0) {
          return extensions[name2];
        }
        var extension;
        switch (name2) {
          case "WEBGL_depth_texture":
            extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            extension = gl.getExtension(name2);
        }
        extensions[name2] = extension;
        return extension;
      }
      return {
        has: function has(name2) {
          return getExtension(name2) !== null;
        },
        init: function init(capabilities) {
          if (capabilities.isWebGL2) {
            getExtension("EXT_color_buffer_float");
          } else {
            getExtension("WEBGL_depth_texture");
            getExtension("OES_texture_float");
            getExtension("OES_texture_half_float");
            getExtension("OES_texture_half_float_linear");
            getExtension("OES_standard_derivatives");
            getExtension("OES_element_index_uint");
            getExtension("OES_vertex_array_object");
            getExtension("ANGLE_instanced_arrays");
          }
          getExtension("OES_texture_float_linear");
          getExtension("EXT_color_buffer_half_float");
        },
        get: function get(name2) {
          var extension = getExtension(name2);
          if (extension === null) {
            console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
          }
          return extension;
        }
      };
    }
    function WebGLGeometries2(gl, attributes, info, bindingStates) {
      var geometries = {};
      var wireframeAttributes = new WeakMap();
      function onGeometryDispose(event) {
        var geometry = event.target;
        if (geometry.index !== null) {
          attributes.remove(geometry.index);
        }
        for (var name2 in geometry.attributes) {
          attributes.remove(geometry.attributes[name2]);
        }
        geometry.removeEventListener("dispose", onGeometryDispose);
        delete geometries[geometry.id];
        var attribute = wireframeAttributes.get(geometry);
        if (attribute) {
          attributes.remove(attribute);
          wireframeAttributes.delete(geometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) {
          delete geometry._maxInstanceCount;
        }
        info.memory.geometries--;
      }
      function get(object, geometry) {
        if (geometries[geometry.id] === true)
          return geometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        geometries[geometry.id] = true;
        info.memory.geometries++;
        return geometry;
      }
      function update(geometry) {
        var geometryAttributes = geometry.attributes;
        for (var name2 in geometryAttributes) {
          attributes.update(geometryAttributes[name2], 34962);
        }
        var morphAttributes = geometry.morphAttributes;
        for (var _name in morphAttributes) {
          var array = morphAttributes[_name];
          for (var i2 = 0, l = array.length; i2 < l; i2++) {
            attributes.update(array[i2], 34962);
          }
        }
      }
      function updateWireframeAttribute(geometry) {
        var indices = [];
        var geometryIndex = geometry.index;
        var geometryPosition = geometry.attributes.position;
        var version = 0;
        if (geometryIndex !== null) {
          var array = geometryIndex.array;
          version = geometryIndex.version;
          for (var i2 = 0, l = array.length; i2 < l; i2 += 3) {
            var a = array[i2 + 0];
            var b = array[i2 + 1];
            var c = array[i2 + 2];
            indices.push(a, b, b, c, c, a);
          }
        } else {
          var _array = geometryPosition.array;
          version = geometryPosition.version;
          for (var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3) {
            var _a = _i + 0;
            var _b = _i + 1;
            var _c = _i + 2;
            indices.push(_a, _b, _b, _c, _c, _a);
          }
        }
        var attribute = new (arrayMax2(indices) > 65535 ? Uint32BufferAttribute2 : Uint16BufferAttribute2)(indices, 1);
        attribute.version = version;
        var previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute)
          attributes.remove(previousAttribute);
        wireframeAttributes.set(geometry, attribute);
      }
      function getWireframeAttribute(geometry) {
        var currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
          var geometryIndex = geometry.index;
          if (geometryIndex !== null) {
            if (currentAttribute.version < geometryIndex.version) {
              updateWireframeAttribute(geometry);
            }
          }
        } else {
          updateWireframeAttribute(geometry);
        }
        return wireframeAttributes.get(geometry);
      }
      return {
        get,
        update,
        getWireframeAttribute
      };
    }
    function WebGLIndexedBufferRenderer2(gl, extensions, info, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      var mode;
      function setMode(value) {
        mode = value;
      }
      var type, bytesPerElement;
      function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
      }
      function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
      }
      function renderInstances(start, count, primcount) {
        if (primcount === 0)
          return;
        var extension, methodName;
        if (isWebGL2) {
          extension = gl;
          methodName = "drawElementsInstanced";
        } else {
          extension = extensions.get("ANGLE_instanced_arrays");
          methodName = "drawElementsInstancedANGLE";
          if (extension === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
          }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
      }
      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render;
      this.renderInstances = renderInstances;
    }
    function WebGLInfo2(gl) {
      var memory = {
        geometries: 0,
        textures: 0
      };
      var render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      function update(count, mode, instanceCount) {
        render.calls++;
        switch (mode) {
          case 4:
            render.triangles += instanceCount * (count / 3);
            break;
          case 1:
            render.lines += instanceCount * (count / 2);
            break;
          case 3:
            render.lines += instanceCount * (count - 1);
            break;
          case 2:
            render.lines += instanceCount * count;
            break;
          case 0:
            render.points += instanceCount * count;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
            break;
        }
      }
      function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
      }
      return {
        memory,
        render,
        programs: null,
        autoReset: true,
        reset,
        update
      };
    }
    function numericalSort2(a, b) {
      return a[0] - b[0];
    }
    function absNumericalSort2(a, b) {
      return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets2(gl) {
      var influencesList = {};
      var morphInfluences = new Float32Array(8);
      var workInfluences = [];
      for (var i2 = 0; i2 < 8; i2++) {
        workInfluences[i2] = [i2, 0];
      }
      function update(object, geometry, material, program) {
        var objectInfluences = object.morphTargetInfluences;
        var length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        var influences = influencesList[geometry.id];
        if (influences === void 0) {
          influences = [];
          for (var _i = 0; _i < length; _i++) {
            influences[_i] = [_i, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (var _i2 = 0; _i2 < length; _i2++) {
          var influence = influences[_i2];
          influence[0] = _i2;
          influence[1] = objectInfluences[_i2];
        }
        influences.sort(absNumericalSort2);
        for (var _i3 = 0; _i3 < 8; _i3++) {
          if (_i3 < length && influences[_i3][1]) {
            workInfluences[_i3][0] = influences[_i3][0];
            workInfluences[_i3][1] = influences[_i3][1];
          } else {
            workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[_i3][1] = 0;
          }
        }
        workInfluences.sort(numericalSort2);
        var morphTargets = material.morphTargets && geometry.morphAttributes.position;
        var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        var morphInfluencesSum = 0;
        for (var _i4 = 0; _i4 < 8; _i4++) {
          var _influence = workInfluences[_i4];
          var index = _influence[0];
          var value = _influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + _i4) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + _i4, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + _i4) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + _i4, morphNormals[index]);
            }
            morphInfluences[_i4] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + _i4) === true) {
              geometry.deleteAttribute("morphTarget" + _i4);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + _i4) === true) {
              geometry.deleteAttribute("morphNormal" + _i4);
            }
            morphInfluences[_i4] = 0;
          }
        }
        var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
      return {
        update
      };
    }
    function WebGLObjects2(gl, geometries, attributes, info) {
      var updateMap = new WeakMap();
      function update(object) {
        var frame = info.render.frame;
        var geometry = object.geometry;
        var buffergeometry = geometries.get(object, geometry);
        if (updateMap.get(buffergeometry) !== frame) {
          geometries.update(buffergeometry);
          updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
          if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
            object.addEventListener("dispose", onInstancedMeshDispose);
          }
          attributes.update(object.instanceMatrix, 34962);
          if (object.instanceColor !== null) {
            attributes.update(object.instanceColor, 34962);
          }
        }
        return buffergeometry;
      }
      function dispose() {
        updateMap = new WeakMap();
      }
      function onInstancedMeshDispose(event) {
        var instancedMesh = event.target;
        instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null)
          attributes.remove(instancedMesh.instanceColor);
      }
      return {
        update,
        dispose
      };
    }
    var DataTexture2DArray2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(DataTexture2DArray3, _Texture);
      function DataTexture2DArray3(data, width, height, depth) {
        var _this;
        if (data === void 0) {
          data = null;
        }
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (depth === void 0) {
          depth = 1;
        }
        _this = _Texture.call(this, null) || this;
        _this.image = {
          data,
          width,
          height,
          depth
        };
        _this.magFilter = NearestFilter2;
        _this.minFilter = NearestFilter2;
        _this.wrapR = ClampToEdgeWrapping2;
        _this.generateMipmaps = false;
        _this.flipY = false;
        _this.needsUpdate = true;
        return _this;
      }
      return DataTexture2DArray3;
    }(Texture2);
    DataTexture2DArray2.prototype.isDataTexture2DArray = true;
    var DataTexture3D2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(DataTexture3D3, _Texture);
      function DataTexture3D3(data, width, height, depth) {
        var _this;
        if (data === void 0) {
          data = null;
        }
        if (width === void 0) {
          width = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (depth === void 0) {
          depth = 1;
        }
        _this = _Texture.call(this, null) || this;
        _this.image = {
          data,
          width,
          height,
          depth
        };
        _this.magFilter = NearestFilter2;
        _this.minFilter = NearestFilter2;
        _this.wrapR = ClampToEdgeWrapping2;
        _this.generateMipmaps = false;
        _this.flipY = false;
        _this.needsUpdate = true;
        return _this;
      }
      return DataTexture3D3;
    }(Texture2);
    DataTexture3D2.prototype.isDataTexture3D = true;
    var emptyTexture2 = new Texture2();
    var emptyTexture2dArray2 = new DataTexture2DArray2();
    var emptyTexture3d2 = new DataTexture3D2();
    var emptyCubeTexture2 = new CubeTexture2();
    var arrayCacheF322 = [];
    var arrayCacheI322 = [];
    var mat4array2 = new Float32Array(16);
    var mat3array2 = new Float32Array(9);
    var mat2array2 = new Float32Array(4);
    function flatten2(array, nBlocks, blockSize) {
      var firstElem = array[0];
      if (firstElem <= 0 || firstElem > 0)
        return array;
      var n = nBlocks * blockSize;
      var r = arrayCacheF322[n];
      if (r === void 0) {
        r = new Float32Array(n);
        arrayCacheF322[n] = r;
      }
      if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for (var i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
          offset += blockSize;
          array[i2].toArray(r, offset);
        }
      }
      return r;
    }
    function arraysEqual2(a, b) {
      if (a.length !== b.length)
        return false;
      for (var i2 = 0, l = a.length; i2 < l; i2++) {
        if (a[i2] !== b[i2])
          return false;
      }
      return true;
    }
    function copyArray2(a, b) {
      for (var i2 = 0, l = b.length; i2 < l; i2++) {
        a[i2] = b[i2];
      }
    }
    function allocTexUnits2(textures, n) {
      var r = arrayCacheI322[n];
      if (r === void 0) {
        r = new Int32Array(n);
        arrayCacheI322[n] = r;
      }
      for (var i2 = 0; i2 !== n; ++i2) {
        r[i2] = textures.allocateTextureUnit();
      }
      return r;
    }
    function setValueV1f2(gl, v) {
      var cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1f(this.addr, v);
      cache[0] = v;
    }
    function setValueV2f2(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
          gl.uniform2f(this.addr, v.x, v.y);
          cache[0] = v.x;
          cache[1] = v.y;
        }
      } else {
        if (arraysEqual2(cache, v))
          return;
        gl.uniform2fv(this.addr, v);
        copyArray2(cache, v);
      }
    }
    function setValueV3f2(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
          gl.uniform3f(this.addr, v.x, v.y, v.z);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
        }
      } else if (v.r !== void 0) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
          gl.uniform3f(this.addr, v.r, v.g, v.b);
          cache[0] = v.r;
          cache[1] = v.g;
          cache[2] = v.b;
        }
      } else {
        if (arraysEqual2(cache, v))
          return;
        gl.uniform3fv(this.addr, v);
        copyArray2(cache, v);
      }
    }
    function setValueV4f2(gl, v) {
      var cache = this.cache;
      if (v.x !== void 0) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
          gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
          cache[0] = v.x;
          cache[1] = v.y;
          cache[2] = v.z;
          cache[3] = v.w;
        }
      } else {
        if (arraysEqual2(cache, v))
          return;
        gl.uniform4fv(this.addr, v);
        copyArray2(cache, v);
      }
    }
    function setValueM22(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual2(cache, v))
          return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray2(cache, v);
      } else {
        if (arraysEqual2(cache, elements))
          return;
        mat2array2.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array2);
        copyArray2(cache, elements);
      }
    }
    function setValueM32(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual2(cache, v))
          return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray2(cache, v);
      } else {
        if (arraysEqual2(cache, elements))
          return;
        mat3array2.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array2);
        copyArray2(cache, elements);
      }
    }
    function setValueM42(gl, v) {
      var cache = this.cache;
      var elements = v.elements;
      if (elements === void 0) {
        if (arraysEqual2(cache, v))
          return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray2(cache, v);
      } else {
        if (arraysEqual2(cache, elements))
          return;
        mat4array2.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array2);
        copyArray2(cache, elements);
      }
    }
    function setValueT12(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTexture2D(v || emptyTexture2, unit);
    }
    function setValueT2DArray12(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture2DArray(v || emptyTexture2dArray2, unit);
    }
    function setValueT3D12(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.setTexture3D(v || emptyTexture3d2, unit);
    }
    function setValueT62(gl, v, textures) {
      var cache = this.cache;
      var unit = textures.allocateTextureUnit();
      if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
      }
      textures.safeSetTextureCube(v || emptyCubeTexture2, unit);
    }
    function setValueV1i2(gl, v) {
      var cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1i(this.addr, v);
      cache[0] = v;
    }
    function setValueV2i2(gl, v) {
      var cache = this.cache;
      if (arraysEqual2(cache, v))
        return;
      gl.uniform2iv(this.addr, v);
      copyArray2(cache, v);
    }
    function setValueV3i2(gl, v) {
      var cache = this.cache;
      if (arraysEqual2(cache, v))
        return;
      gl.uniform3iv(this.addr, v);
      copyArray2(cache, v);
    }
    function setValueV4i2(gl, v) {
      var cache = this.cache;
      if (arraysEqual2(cache, v))
        return;
      gl.uniform4iv(this.addr, v);
      copyArray2(cache, v);
    }
    function setValueV1ui2(gl, v) {
      var cache = this.cache;
      if (cache[0] === v)
        return;
      gl.uniform1ui(this.addr, v);
      cache[0] = v;
    }
    function getSingularSetter2(type) {
      switch (type) {
        case 5126:
          return setValueV1f2;
        case 35664:
          return setValueV2f2;
        case 35665:
          return setValueV3f2;
        case 35666:
          return setValueV4f2;
        case 35674:
          return setValueM22;
        case 35675:
          return setValueM32;
        case 35676:
          return setValueM42;
        case 5124:
        case 35670:
          return setValueV1i2;
        case 35667:
        case 35671:
          return setValueV2i2;
        case 35668:
        case 35672:
          return setValueV3i2;
        case 35669:
        case 35673:
          return setValueV4i2;
        case 5125:
          return setValueV1ui2;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return setValueT12;
        case 35679:
        case 36299:
        case 36307:
          return setValueT3D12;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return setValueT62;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return setValueT2DArray12;
      }
    }
    function setValueV1fArray2(gl, v) {
      gl.uniform1fv(this.addr, v);
    }
    function setValueV1iArray2(gl, v) {
      gl.uniform1iv(this.addr, v);
    }
    function setValueV2iArray2(gl, v) {
      gl.uniform2iv(this.addr, v);
    }
    function setValueV3iArray2(gl, v) {
      gl.uniform3iv(this.addr, v);
    }
    function setValueV4iArray2(gl, v) {
      gl.uniform4iv(this.addr, v);
    }
    function setValueV2fArray2(gl, v) {
      var data = flatten2(v, this.size, 2);
      gl.uniform2fv(this.addr, data);
    }
    function setValueV3fArray2(gl, v) {
      var data = flatten2(v, this.size, 3);
      gl.uniform3fv(this.addr, data);
    }
    function setValueV4fArray2(gl, v) {
      var data = flatten2(v, this.size, 4);
      gl.uniform4fv(this.addr, data);
    }
    function setValueM2Array2(gl, v) {
      var data = flatten2(v, this.size, 4);
      gl.uniformMatrix2fv(this.addr, false, data);
    }
    function setValueM3Array2(gl, v) {
      var data = flatten2(v, this.size, 9);
      gl.uniformMatrix3fv(this.addr, false, data);
    }
    function setValueM4Array2(gl, v) {
      var data = flatten2(v, this.size, 16);
      gl.uniformMatrix4fv(this.addr, false, data);
    }
    function setValueT1Array2(gl, v, textures) {
      var n = v.length;
      var units = allocTexUnits2(textures, n);
      gl.uniform1iv(this.addr, units);
      for (var i2 = 0; i2 !== n; ++i2) {
        textures.safeSetTexture2D(v[i2] || emptyTexture2, units[i2]);
      }
    }
    function setValueT6Array2(gl, v, textures) {
      var n = v.length;
      var units = allocTexUnits2(textures, n);
      gl.uniform1iv(this.addr, units);
      for (var i2 = 0; i2 !== n; ++i2) {
        textures.safeSetTextureCube(v[i2] || emptyCubeTexture2, units[i2]);
      }
    }
    function getPureArraySetter2(type) {
      switch (type) {
        case 5126:
          return setValueV1fArray2;
        case 35664:
          return setValueV2fArray2;
        case 35665:
          return setValueV3fArray2;
        case 35666:
          return setValueV4fArray2;
        case 35674:
          return setValueM2Array2;
        case 35675:
          return setValueM3Array2;
        case 35676:
          return setValueM4Array2;
        case 5124:
        case 35670:
          return setValueV1iArray2;
        case 35667:
        case 35671:
          return setValueV2iArray2;
        case 35668:
        case 35672:
          return setValueV3iArray2;
        case 35669:
        case 35673:
          return setValueV4iArray2;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return setValueT1Array2;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return setValueT6Array2;
      }
    }
    function SingleUniform2(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.setValue = getSingularSetter2(activeInfo.type);
    }
    function PureArrayUniform2(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter2(activeInfo.type);
    }
    PureArrayUniform2.prototype.updateCache = function(data) {
      var cache = this.cache;
      if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
      }
      copyArray2(cache, data);
    };
    function StructuredUniform2(id) {
      this.id = id;
      this.seq = [];
      this.map = {};
    }
    StructuredUniform2.prototype.setValue = function(gl, value, textures) {
      var seq = this.seq;
      for (var i2 = 0, n = seq.length; i2 !== n; ++i2) {
        var u = seq[i2];
        u.setValue(gl, value[u.id], textures);
      }
    };
    var RePathPart2 = /(\w+)(\])?(\[|\.)?/g;
    function addUniform2(container, uniformObject) {
      container.seq.push(uniformObject);
      container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform2(activeInfo, addr, container) {
      var path = activeInfo.name, pathLength = path.length;
      RePathPart2.lastIndex = 0;
      while (true) {
        var match = RePathPart2.exec(path), matchEnd = RePathPart2.lastIndex;
        var id = match[1];
        var idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex)
          id = id | 0;
        if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
          addUniform2(container, subscript === void 0 ? new SingleUniform2(id, activeInfo, addr) : new PureArrayUniform2(id, activeInfo, addr));
          break;
        } else {
          var map = container.map;
          var next = map[id];
          if (next === void 0) {
            next = new StructuredUniform2(id);
            addUniform2(container, next);
          }
          container = next;
        }
      }
    }
    function WebGLUniforms2(gl, program) {
      this.seq = [];
      this.map = {};
      var n = gl.getProgramParameter(program, 35718);
      for (var i2 = 0; i2 < n; ++i2) {
        var info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
        parseUniform2(info, addr, this);
      }
    }
    WebGLUniforms2.prototype.setValue = function(gl, name2, value, textures) {
      var u = this.map[name2];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    };
    WebGLUniforms2.prototype.setOptional = function(gl, object, name2) {
      var v = object[name2];
      if (v !== void 0)
        this.setValue(gl, name2, v);
    };
    WebGLUniforms2.upload = function(gl, seq, values, textures) {
      for (var i2 = 0, n = seq.length; i2 !== n; ++i2) {
        var u = seq[i2], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    };
    WebGLUniforms2.seqWithValue = function(seq, values) {
      var r = [];
      for (var i2 = 0, n = seq.length; i2 !== n; ++i2) {
        var u = seq[i2];
        if (u.id in values)
          r.push(u);
      }
      return r;
    };
    function WebGLShader2(gl, type, string) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, string);
      gl.compileShader(shader);
      return shader;
    }
    var programIdCount2 = 0;
    function addLineNumbers2(string) {
      var lines = string.split("\n");
      for (var i2 = 0; i2 < lines.length; i2++) {
        lines[i2] = i2 + 1 + ": " + lines[i2];
      }
      return lines.join("\n");
    }
    function getEncodingComponents2(encoding) {
      switch (encoding) {
        case LinearEncoding2:
          return ["Linear", "( value )"];
        case sRGBEncoding2:
          return ["sRGB", "( value )"];
        case RGBEEncoding2:
          return ["RGBE", "( value )"];
        case RGBM7Encoding2:
          return ["RGBM", "( value, 7.0 )"];
        case RGBM16Encoding2:
          return ["RGBM", "( value, 16.0 )"];
        case RGBDEncoding2:
          return ["RGBD", "( value, 256.0 )"];
        case GammaEncoding2:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case LogLuvEncoding2:
          return ["LogLuv", "( value )"];
        default:
          console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
          return ["Linear", "( value )"];
      }
    }
    function getShaderErrors2(gl, shader, type) {
      var status = gl.getShaderParameter(shader, 35713);
      var log = gl.getShaderInfoLog(shader).trim();
      if (status && log === "")
        return "";
      var source = gl.getShaderSource(shader);
      return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers2(source);
    }
    function getTexelDecodingFunction2(functionName, encoding) {
      var components = getEncodingComponents2(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction2(functionName, encoding) {
      var components = getEncodingComponents2(encoding);
      return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction2(functionName, toneMapping) {
      var toneMappingName;
      switch (toneMapping) {
        case LinearToneMapping2:
          toneMappingName = "Linear";
          break;
        case ReinhardToneMapping2:
          toneMappingName = "Reinhard";
          break;
        case CineonToneMapping2:
          toneMappingName = "OptimizedCineon";
          break;
        case ACESFilmicToneMapping2:
          toneMappingName = "ACESFilmic";
          break;
        case CustomToneMapping2:
          toneMappingName = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
          toneMappingName = "Linear";
      }
      return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions2(parameters) {
      var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
      return chunks.filter(filterEmptyLine2).join("\n");
    }
    function generateDefines2(defines) {
      var chunks = [];
      for (var name2 in defines) {
        var value = defines[name2];
        if (value === false)
          continue;
        chunks.push("#define " + name2 + " " + value);
      }
      return chunks.join("\n");
    }
    function fetchAttributeLocations2(gl, program) {
      var attributes = {};
      var n = gl.getProgramParameter(program, 35721);
      for (var i2 = 0; i2 < n; i2++) {
        var info = gl.getActiveAttrib(program, i2);
        var name2 = info.name;
        attributes[name2] = gl.getAttribLocation(program, name2);
      }
      return attributes;
    }
    function filterEmptyLine2(string) {
      return string !== "";
    }
    function replaceLightNums2(string, parameters) {
      return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
    }
    function replaceClippingPlaneNums2(string, parameters) {
      return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
    }
    var includePattern2 = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function resolveIncludes2(string) {
      return string.replace(includePattern2, includeReplacer2);
    }
    function includeReplacer2(match, include) {
      var string = ShaderChunk2[include];
      if (string === void 0) {
        throw new Error("Can not resolve #include <" + include + ">");
      }
      return resolveIncludes2(string);
    }
    var deprecatedUnrollLoopPattern2 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    var unrollLoopPattern2 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function unrollLoops2(string) {
      return string.replace(unrollLoopPattern2, loopReplacer2).replace(deprecatedUnrollLoopPattern2, deprecatedLoopReplacer2);
    }
    function deprecatedLoopReplacer2(match, start, end, snippet) {
      console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
      return loopReplacer2(match, start, end, snippet);
    }
    function loopReplacer2(match, start, end, snippet) {
      var string = "";
      for (var i2 = parseInt(start); i2 < parseInt(end); i2++) {
        string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
      }
      return string;
    }
    function generatePrecision2(parameters) {
      var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
      if (parameters.precision === "highp") {
        precisionstring += "\n#define HIGH_PRECISION";
      } else if (parameters.precision === "mediump") {
        precisionstring += "\n#define MEDIUM_PRECISION";
      } else if (parameters.precision === "lowp") {
        precisionstring += "\n#define LOW_PRECISION";
      }
      return precisionstring;
    }
    function generateShadowMapTypeDefine2(parameters) {
      var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
      if (parameters.shadowMapType === PCFShadowMap2) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
      } else if (parameters.shadowMapType === PCFSoftShadowMap2) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
      } else if (parameters.shadowMapType === VSMShadowMap2) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
      }
      return shadowMapTypeDefine;
    }
    function generateEnvMapTypeDefine2(parameters) {
      var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeReflectionMapping2:
          case CubeRefractionMapping2:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            break;
          case CubeUVReflectionMapping2:
          case CubeUVRefractionMapping2:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
      }
      return envMapTypeDefine;
    }
    function generateEnvMapModeDefine2(parameters) {
      var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
      if (parameters.envMap) {
        switch (parameters.envMapMode) {
          case CubeRefractionMapping2:
          case CubeUVRefractionMapping2:
            envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            break;
        }
      }
      return envMapModeDefine;
    }
    function generateEnvMapBlendingDefine2(parameters) {
      var envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
      if (parameters.envMap) {
        switch (parameters.combine) {
          case MultiplyOperation2:
            envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case MixOperation2:
            envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
            break;
          case AddOperation2:
            envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            break;
        }
      }
      return envMapBlendingDefine;
    }
    function WebGLProgram2(renderer2, cacheKey, parameters, bindingStates) {
      var gl = renderer2.getContext();
      var defines = parameters.defines;
      var vertexShader = parameters.vertexShader;
      var fragmentShader = parameters.fragmentShader;
      var shadowMapTypeDefine = generateShadowMapTypeDefine2(parameters);
      var envMapTypeDefine = generateEnvMapTypeDefine2(parameters);
      var envMapModeDefine = generateEnvMapModeDefine2(parameters);
      var envMapBlendingDefine = generateEnvMapBlendingDefine2(parameters);
      var gammaFactorDefine = renderer2.gammaFactor > 0 ? renderer2.gammaFactor : 1;
      var customExtensions = parameters.isWebGL2 ? "" : generateExtensions2(parameters);
      var customDefines = generateDefines2(defines);
      var program = gl.createProgram();
      var prefixVertex, prefixFragment;
      var versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
      if (parameters.isRawShaderMaterial) {
        prefixVertex = [customDefines].filter(filterEmptyLine2).join("\n");
        if (prefixVertex.length > 0) {
          prefixVertex += "\n";
        }
        prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine2).join("\n");
        if (prefixFragment.length > 0) {
          prefixFragment += "\n";
        }
      } else {
        prefixVertex = [generatePrecision2(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine2).join("\n");
        prefixFragment = [
          customExtensions,
          generatePrecision2(parameters),
          "#define SHADER_NAME " + parameters.shaderName,
          customDefines,
          parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
          "#define GAMMA_FACTOR " + gammaFactorDefine,
          parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
          parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
          parameters.map ? "#define USE_MAP" : "",
          parameters.matcap ? "#define USE_MATCAP" : "",
          parameters.envMap ? "#define USE_ENVMAP" : "",
          parameters.envMap ? "#define " + envMapTypeDefine : "",
          parameters.envMap ? "#define " + envMapModeDefine : "",
          parameters.envMap ? "#define " + envMapBlendingDefine : "",
          parameters.lightMap ? "#define USE_LIGHTMAP" : "",
          parameters.aoMap ? "#define USE_AOMAP" : "",
          parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          parameters.bumpMap ? "#define USE_BUMPMAP" : "",
          parameters.normalMap ? "#define USE_NORMALMAP" : "",
          parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
          parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
          parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          parameters.specularMap ? "#define USE_SPECULARMAP" : "",
          parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
          parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
          parameters.sheen ? "#define USE_SHEEN" : "",
          parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          parameters.vertexTangents ? "#define USE_TANGENT" : "",
          parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
          parameters.vertexUvs ? "#define USE_UV" : "",
          parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
          parameters.flatShading ? "#define FLAT_SHADED" : "",
          parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
          parameters.flipSided ? "#define FLIP_SIDED" : "",
          parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
          parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
          (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          parameters.toneMapping !== NoToneMapping2 ? "#define TONE_MAPPING" : "",
          parameters.toneMapping !== NoToneMapping2 ? ShaderChunk2["tonemapping_pars_fragment"] : "",
          parameters.toneMapping !== NoToneMapping2 ? getToneMappingFunction2("toneMapping", parameters.toneMapping) : "",
          parameters.dithering ? "#define DITHERING" : "",
          ShaderChunk2["encodings_pars_fragment"],
          parameters.map ? getTexelDecodingFunction2("mapTexelToLinear", parameters.mapEncoding) : "",
          parameters.matcap ? getTexelDecodingFunction2("matcapTexelToLinear", parameters.matcapEncoding) : "",
          parameters.envMap ? getTexelDecodingFunction2("envMapTexelToLinear", parameters.envMapEncoding) : "",
          parameters.emissiveMap ? getTexelDecodingFunction2("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
          parameters.lightMap ? getTexelDecodingFunction2("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
          getTexelEncodingFunction2("linearToOutputTexel", parameters.outputEncoding),
          parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
          "\n"
        ].filter(filterEmptyLine2).join("\n");
      }
      vertexShader = resolveIncludes2(vertexShader);
      vertexShader = replaceLightNums2(vertexShader, parameters);
      vertexShader = replaceClippingPlaneNums2(vertexShader, parameters);
      fragmentShader = resolveIncludes2(fragmentShader);
      fragmentShader = replaceLightNums2(fragmentShader, parameters);
      fragmentShader = replaceClippingPlaneNums2(fragmentShader, parameters);
      vertexShader = unrollLoops2(vertexShader);
      fragmentShader = unrollLoops2(fragmentShader);
      if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        versionString = "#version 300 es\n";
        prefixVertex = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
        prefixFragment = ["#define varying in", parameters.glslVersion === GLSL32 ? "" : "out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL32 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
      }
      var vertexGlsl = versionString + prefixVertex + vertexShader;
      var fragmentGlsl = versionString + prefixFragment + fragmentShader;
      var glVertexShader = WebGLShader2(gl, 35633, vertexGlsl);
      var glFragmentShader = WebGLShader2(gl, 35632, fragmentGlsl);
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      if (parameters.index0AttributeName !== void 0) {
        gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
      } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, "position");
      }
      gl.linkProgram(program);
      if (renderer2.debug.checkShaderErrors) {
        var programLog = gl.getProgramInfoLog(program).trim();
        var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
          runnable = false;
          var vertexErrors = getShaderErrors2(gl, glVertexShader, "vertex");
          var fragmentErrors = getShaderErrors2(gl, glFragmentShader, "fragment");
          console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          this.diagnostics = {
            runnable,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      var cachedUniforms;
      this.getUniforms = function() {
        if (cachedUniforms === void 0) {
          cachedUniforms = new WebGLUniforms2(gl, program);
        }
        return cachedUniforms;
      };
      var cachedAttributes;
      this.getAttributes = function() {
        if (cachedAttributes === void 0) {
          cachedAttributes = fetchAttributeLocations2(gl, program);
        }
        return cachedAttributes;
      };
      this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = void 0;
      };
      this.name = parameters.shaderName;
      this.id = programIdCount2++;
      this.cacheKey = cacheKey;
      this.usedTimes = 1;
      this.program = program;
      this.vertexShader = glVertexShader;
      this.fragmentShader = glFragmentShader;
      return this;
    }
    function WebGLPrograms2(renderer2, cubemaps, extensions, capabilities, bindingStates, clipping) {
      var programs = [];
      var isWebGL2 = capabilities.isWebGL2;
      var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
      var floatVertexTextures = capabilities.floatVertexTextures;
      var maxVertexUniforms = capabilities.maxVertexUniforms;
      var vertexTextures = capabilities.vertexTextures;
      var precision = capabilities.precision;
      var shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      };
      var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
      function getMaxBones(object) {
        var skeleton = object.skeleton;
        var bones = skeleton.bones;
        if (floatVertexTextures) {
          return 1024;
        } else {
          var nVertexUniforms = maxVertexUniforms;
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = Math.min(nVertexMatrices, bones.length);
          if (maxBones < bones.length) {
            console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
            return 0;
          }
          return maxBones;
        }
      }
      function getTextureEncodingFromMap(map) {
        var encoding;
        if (map && map.isTexture) {
          encoding = map.encoding;
        } else if (map && map.isWebGLRenderTarget) {
          console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
          encoding = map.texture.encoding;
        } else {
          encoding = LinearEncoding2;
        }
        return encoding;
      }
      function getParameters(material, lights, shadows, scene2, object) {
        var fog = scene2.fog;
        var environment = material.isMeshStandardMaterial ? scene2.environment : null;
        var envMap = cubemaps.get(material.envMap || environment);
        var shaderID = shaderIDs[material.type];
        var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material.precision !== null) {
          precision = capabilities.getMaxPrecision(material.precision);
          if (precision !== material.precision) {
            console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
          }
        }
        var vertexShader, fragmentShader;
        if (shaderID) {
          var shader = ShaderLib2[shaderID];
          vertexShader = shader.vertexShader;
          fragmentShader = shader.fragmentShader;
        } else {
          vertexShader = material.vertexShader;
          fragmentShader = material.fragmentShader;
        }
        var currentRenderTarget = renderer2.getRenderTarget();
        var parameters = {
          isWebGL2,
          shaderID,
          shaderName: material.type,
          vertexShader,
          fragmentShader,
          defines: material.defines,
          isRawShaderMaterial: material.isRawShaderMaterial === true,
          glslVersion: material.glslVersion,
          precision,
          instancing: object.isInstancedMesh === true,
          instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
          supportsVertexTextures: vertexTextures,
          outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer2.outputEncoding,
          map: !!material.map,
          mapEncoding: getTextureEncodingFromMap(material.map),
          matcap: !!material.matcap,
          matcapEncoding: getTextureEncodingFromMap(material.matcap),
          envMap: !!envMap,
          envMapMode: envMap && envMap.mapping,
          envMapEncoding: getTextureEncodingFromMap(envMap),
          envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping2 || envMap.mapping === CubeUVRefractionMapping2),
          lightMap: !!material.lightMap,
          lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
          aoMap: !!material.aoMap,
          emissiveMap: !!material.emissiveMap,
          emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap2,
          tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap2,
          clearcoatMap: !!material.clearcoatMap,
          clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
          clearcoatNormalMap: !!material.clearcoatNormalMap,
          displacementMap: !!material.displacementMap,
          roughnessMap: !!material.roughnessMap,
          metalnessMap: !!material.metalnessMap,
          specularMap: !!material.specularMap,
          alphaMap: !!material.alphaMap,
          gradientMap: !!material.gradientMap,
          sheen: !!material.sheen,
          transmissionMap: !!material.transmissionMap,
          combine: material.combine,
          vertexTangents: material.normalMap && material.vertexTangents,
          vertexColors: material.vertexColors,
          vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
          uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
          fog: !!fog,
          useFog: material.fog,
          fogExp2: fog && fog.isFogExp2,
          flatShading: !!material.flatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer,
          skinning: material.skinning && maxBones > 0,
          maxBones,
          useVertexTexture: floatVertexTextures,
          morphTargets: material.morphTargets,
          morphNormals: material.morphNormals,
          maxMorphTargets: renderer2.maxMorphTargets,
          maxMorphNormals: renderer2.maxMorphNormals,
          numDirLights: lights.directional.length,
          numPointLights: lights.point.length,
          numSpotLights: lights.spot.length,
          numRectAreaLights: lights.rectArea.length,
          numHemiLights: lights.hemi.length,
          numDirLightShadows: lights.directionalShadowMap.length,
          numPointLightShadows: lights.pointShadowMap.length,
          numSpotLightShadows: lights.spotShadowMap.length,
          numClippingPlanes: clipping.numPlanes,
          numClipIntersection: clipping.numIntersection,
          dithering: material.dithering,
          shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
          shadowMapType: renderer2.shadowMap.type,
          toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping2,
          physicallyCorrectLights: renderer2.physicallyCorrectLights,
          premultipliedAlpha: material.premultipliedAlpha,
          alphaTest: material.alphaTest,
          doubleSided: material.side === DoubleSide3,
          flipSided: material.side === BackSide2,
          depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
          index0AttributeName: material.index0AttributeName,
          extensionDerivatives: material.extensions && material.extensions.derivatives,
          extensionFragDepth: material.extensions && material.extensions.fragDepth,
          extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
          extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
          customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
      }
      function getProgramCacheKey(parameters) {
        var array = [];
        if (parameters.shaderID) {
          array.push(parameters.shaderID);
        } else {
          array.push(parameters.fragmentShader);
          array.push(parameters.vertexShader);
        }
        if (parameters.defines !== void 0) {
          for (var name2 in parameters.defines) {
            array.push(name2);
            array.push(parameters.defines[name2]);
          }
        }
        if (parameters.isRawShaderMaterial === false) {
          for (var i2 = 0; i2 < parameterNames.length; i2++) {
            array.push(parameters[parameterNames[i2]]);
          }
          array.push(renderer2.outputEncoding);
          array.push(renderer2.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
      }
      function getUniforms(material) {
        var shaderID = shaderIDs[material.type];
        var uniforms;
        if (shaderID) {
          var shader = ShaderLib2[shaderID];
          uniforms = UniformsUtils2.clone(shader.uniforms);
        } else {
          uniforms = material.uniforms;
        }
        return uniforms;
      }
      function acquireProgram(parameters, cacheKey) {
        var program;
        for (var p = 0, pl = programs.length; p < pl; p++) {
          var preexistingProgram = programs[p];
          if (preexistingProgram.cacheKey === cacheKey) {
            program = preexistingProgram;
            ++program.usedTimes;
            break;
          }
        }
        if (program === void 0) {
          program = new WebGLProgram2(renderer2, cacheKey, parameters, bindingStates);
          programs.push(program);
        }
        return program;
      }
      function releaseProgram(program) {
        if (--program.usedTimes === 0) {
          var i2 = programs.indexOf(program);
          programs[i2] = programs[programs.length - 1];
          programs.pop();
          program.destroy();
        }
      }
      return {
        getParameters,
        getProgramCacheKey,
        getUniforms,
        acquireProgram,
        releaseProgram,
        programs
      };
    }
    function WebGLProperties2() {
      var properties = new WeakMap();
      function get(object) {
        var map = properties.get(object);
        if (map === void 0) {
          map = {};
          properties.set(object, map);
        }
        return map;
      }
      function remove(object) {
        properties.delete(object);
      }
      function update(object, key, value) {
        properties.get(object)[key] = value;
      }
      function dispose() {
        properties = new WeakMap();
      }
      return {
        get,
        remove,
        update,
        dispose
      };
    }
    function painterSortStable2(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.program !== b.program) {
        return a.program.id - b.program.id;
      } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
      } else if (a.z !== b.z) {
        return a.z - b.z;
      } else {
        return a.id - b.id;
      }
    }
    function reversePainterSortStable2(a, b) {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.z !== b.z) {
        return b.z - a.z;
      } else {
        return a.id - b.id;
      }
    }
    function WebGLRenderList2(properties) {
      var renderItems = [];
      var renderItemsIndex = 0;
      var opaque = [];
      var transparent = [];
      var defaultProgram = {
        id: -1
      };
      function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
      }
      function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        var renderItem = renderItems[renderItemsIndex];
        var materialProperties = properties.get(material);
        if (renderItem === void 0) {
          renderItem = {
            id: object.id,
            object,
            geometry,
            material,
            program: materialProperties.program || defaultProgram,
            groupOrder,
            renderOrder: object.renderOrder,
            z,
            group
          };
          renderItems[renderItemsIndex] = renderItem;
        } else {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material;
          renderItem.program = materialProperties.program || defaultProgram;
          renderItem.groupOrder = groupOrder;
          renderItem.renderOrder = object.renderOrder;
          renderItem.z = z;
          renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
      }
      function push(object, geometry, material, groupOrder, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
      }
      function unshift(object, geometry, material, groupOrder, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
      }
      function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1)
          opaque.sort(customOpaqueSort || painterSortStable2);
        if (transparent.length > 1)
          transparent.sort(customTransparentSort || reversePainterSortStable2);
      }
      function finish() {
        for (var i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
          var renderItem = renderItems[i2];
          if (renderItem.id === null)
            break;
          renderItem.id = null;
          renderItem.object = null;
          renderItem.geometry = null;
          renderItem.material = null;
          renderItem.program = null;
          renderItem.group = null;
        }
      }
      return {
        opaque,
        transparent,
        init,
        push,
        unshift,
        finish,
        sort
      };
    }
    function WebGLRenderLists2(properties) {
      var lists = new WeakMap();
      function get(scene2, renderCallDepth) {
        var list;
        if (lists.has(scene2) === false) {
          list = new WebGLRenderList2(properties);
          lists.set(scene2, [list]);
        } else {
          if (renderCallDepth >= lists.get(scene2).length) {
            list = new WebGLRenderList2(properties);
            lists.get(scene2).push(list);
          } else {
            list = lists.get(scene2)[renderCallDepth];
          }
        }
        return list;
      }
      function dispose() {
        lists = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    function UniformsCache2() {
      var lights = {};
      return {
        get: function get(light) {
          if (lights[light.id] !== void 0) {
            return lights[light.id];
          }
          var uniforms;
          switch (light.type) {
            case "DirectionalLight":
              uniforms = {
                direction: new Vector32(),
                color: new Color5()
              };
              break;
            case "SpotLight":
              uniforms = {
                position: new Vector32(),
                direction: new Vector32(),
                color: new Color5(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0
              };
              break;
            case "PointLight":
              uniforms = {
                position: new Vector32(),
                color: new Color5(),
                distance: 0,
                decay: 0
              };
              break;
            case "HemisphereLight":
              uniforms = {
                direction: new Vector32(),
                skyColor: new Color5(),
                groundColor: new Color5()
              };
              break;
            case "RectAreaLight":
              uniforms = {
                color: new Color5(),
                position: new Vector32(),
                halfWidth: new Vector32(),
                halfHeight: new Vector32()
              };
              break;
          }
          lights[light.id] = uniforms;
          return uniforms;
        }
      };
    }
    function ShadowUniformsCache2() {
      var lights = {};
      return {
        get: function get(light) {
          if (lights[light.id] !== void 0) {
            return lights[light.id];
          }
          var uniforms;
          switch (light.type) {
            case "DirectionalLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector22()
              };
              break;
            case "SpotLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector22()
              };
              break;
            case "PointLight":
              uniforms = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector22(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              };
              break;
          }
          lights[light.id] = uniforms;
          return uniforms;
        }
      };
    }
    var nextVersion2 = 0;
    function shadowCastingLightsFirst2(lightA, lightB) {
      return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
    }
    function WebGLLights2(extensions, capabilities) {
      var cache = new UniformsCache2();
      var shadowCache = ShadowUniformsCache2();
      var state = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
      };
      for (var i2 = 0; i2 < 9; i2++) {
        state.probe.push(new Vector32());
      }
      var vector3 = new Vector32();
      var matrix4 = new Matrix43();
      var matrix42 = new Matrix43();
      function setup(lights) {
        var r = 0, g = 0, b = 0;
        for (var _i = 0; _i < 9; _i++) {
          state.probe[_i].set(0, 0, 0);
        }
        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var rectAreaLength = 0;
        var hemiLength = 0;
        var numDirectionalShadows = 0;
        var numPointShadows = 0;
        var numSpotShadows = 0;
        lights.sort(shadowCastingLightsFirst2);
        for (var _i2 = 0, l = lights.length; _i2 < l; _i2++) {
          var light = lights[_i2];
          var color = light.color;
          var intensity = light.intensity;
          var distance = light.distance;
          var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
          if (light.isAmbientLight) {
            r += color.r * intensity;
            g += color.g * intensity;
            b += color.b * intensity;
          } else if (light.isLightProbe) {
            for (var j = 0; j < 9; j++) {
              state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            }
          } else if (light.isDirectionalLight) {
            var uniforms = cache.get(light);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
            if (light.castShadow) {
              var shadow = light.shadow;
              var shadowUniforms = shadowCache.get(light);
              shadowUniforms.shadowBias = shadow.bias;
              shadowUniforms.shadowNormalBias = shadow.normalBias;
              shadowUniforms.shadowRadius = shadow.radius;
              shadowUniforms.shadowMapSize = shadow.mapSize;
              state.directionalShadow[directionalLength] = shadowUniforms;
              state.directionalShadowMap[directionalLength] = shadowMap;
              state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
              numDirectionalShadows++;
            }
            state.directional[directionalLength] = uniforms;
            directionalLength++;
          } else if (light.isSpotLight) {
            var _uniforms = cache.get(light);
            _uniforms.position.setFromMatrixPosition(light.matrixWorld);
            _uniforms.color.copy(color).multiplyScalar(intensity);
            _uniforms.distance = distance;
            _uniforms.coneCos = Math.cos(light.angle);
            _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
            _uniforms.decay = light.decay;
            if (light.castShadow) {
              var _shadow = light.shadow;
              var _shadowUniforms = shadowCache.get(light);
              _shadowUniforms.shadowBias = _shadow.bias;
              _shadowUniforms.shadowNormalBias = _shadow.normalBias;
              _shadowUniforms.shadowRadius = _shadow.radius;
              _shadowUniforms.shadowMapSize = _shadow.mapSize;
              state.spotShadow[spotLength] = _shadowUniforms;
              state.spotShadowMap[spotLength] = shadowMap;
              state.spotShadowMatrix[spotLength] = light.shadow.matrix;
              numSpotShadows++;
            }
            state.spot[spotLength] = _uniforms;
            spotLength++;
          } else if (light.isRectAreaLight) {
            var _uniforms2 = cache.get(light);
            _uniforms2.color.copy(color).multiplyScalar(intensity);
            _uniforms2.halfWidth.set(light.width * 0.5, 0, 0);
            _uniforms2.halfHeight.set(0, light.height * 0.5, 0);
            state.rectArea[rectAreaLength] = _uniforms2;
            rectAreaLength++;
          } else if (light.isPointLight) {
            var _uniforms3 = cache.get(light);
            _uniforms3.color.copy(light.color).multiplyScalar(light.intensity);
            _uniforms3.distance = light.distance;
            _uniforms3.decay = light.decay;
            if (light.castShadow) {
              var _shadow2 = light.shadow;
              var _shadowUniforms2 = shadowCache.get(light);
              _shadowUniforms2.shadowBias = _shadow2.bias;
              _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
              _shadowUniforms2.shadowRadius = _shadow2.radius;
              _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
              _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
              _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
              state.pointShadow[pointLength] = _shadowUniforms2;
              state.pointShadowMap[pointLength] = shadowMap;
              state.pointShadowMatrix[pointLength] = light.shadow.matrix;
              numPointShadows++;
            }
            state.point[pointLength] = _uniforms3;
            pointLength++;
          } else if (light.isHemisphereLight) {
            var _uniforms4 = cache.get(light);
            _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);
            _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);
            state.hemi[hemiLength] = _uniforms4;
            hemiLength++;
          }
        }
        if (rectAreaLength > 0) {
          if (capabilities.isWebGL2) {
            state.rectAreaLTC1 = UniformsLib2.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib2.LTC_FLOAT_2;
          } else {
            if (extensions.has("OES_texture_float_linear") === true) {
              state.rectAreaLTC1 = UniformsLib2.LTC_FLOAT_1;
              state.rectAreaLTC2 = UniformsLib2.LTC_FLOAT_2;
            } else if (extensions.has("OES_texture_half_float_linear") === true) {
              state.rectAreaLTC1 = UniformsLib2.LTC_HALF_1;
              state.rectAreaLTC2 = UniformsLib2.LTC_HALF_2;
            } else {
              console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
            }
          }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        var hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
          state.directional.length = directionalLength;
          state.spot.length = spotLength;
          state.rectArea.length = rectAreaLength;
          state.point.length = pointLength;
          state.hemi.length = hemiLength;
          state.directionalShadow.length = numDirectionalShadows;
          state.directionalShadowMap.length = numDirectionalShadows;
          state.pointShadow.length = numPointShadows;
          state.pointShadowMap.length = numPointShadows;
          state.spotShadow.length = numSpotShadows;
          state.spotShadowMap.length = numSpotShadows;
          state.directionalShadowMatrix.length = numDirectionalShadows;
          state.pointShadowMatrix.length = numPointShadows;
          state.spotShadowMatrix.length = numSpotShadows;
          hash.directionalLength = directionalLength;
          hash.pointLength = pointLength;
          hash.spotLength = spotLength;
          hash.rectAreaLength = rectAreaLength;
          hash.hemiLength = hemiLength;
          hash.numDirectionalShadows = numDirectionalShadows;
          hash.numPointShadows = numPointShadows;
          hash.numSpotShadows = numSpotShadows;
          state.version = nextVersion2++;
        }
      }
      function setupView(lights, camera2) {
        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var rectAreaLength = 0;
        var hemiLength = 0;
        var viewMatrix = camera2.matrixWorldInverse;
        for (var _i3 = 0, l = lights.length; _i3 < l; _i3++) {
          var light = lights[_i3];
          if (light.isDirectionalLight) {
            var uniforms = state.directional[directionalLength];
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(vector3);
            uniforms.direction.transformDirection(viewMatrix);
            directionalLength++;
          } else if (light.isSpotLight) {
            var _uniforms5 = state.spot[spotLength];
            _uniforms5.position.setFromMatrixPosition(light.matrixWorld);
            _uniforms5.position.applyMatrix4(viewMatrix);
            _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);
            vector3.setFromMatrixPosition(light.target.matrixWorld);
            _uniforms5.direction.sub(vector3);
            _uniforms5.direction.transformDirection(viewMatrix);
            spotLength++;
          } else if (light.isRectAreaLight) {
            var _uniforms6 = state.rectArea[rectAreaLength];
            _uniforms6.position.setFromMatrixPosition(light.matrixWorld);
            _uniforms6.position.applyMatrix4(viewMatrix);
            matrix42.identity();
            matrix4.copy(light.matrixWorld);
            matrix4.premultiply(viewMatrix);
            matrix42.extractRotation(matrix4);
            _uniforms6.halfWidth.set(light.width * 0.5, 0, 0);
            _uniforms6.halfHeight.set(0, light.height * 0.5, 0);
            _uniforms6.halfWidth.applyMatrix4(matrix42);
            _uniforms6.halfHeight.applyMatrix4(matrix42);
            rectAreaLength++;
          } else if (light.isPointLight) {
            var _uniforms7 = state.point[pointLength];
            _uniforms7.position.setFromMatrixPosition(light.matrixWorld);
            _uniforms7.position.applyMatrix4(viewMatrix);
            pointLength++;
          } else if (light.isHemisphereLight) {
            var _uniforms8 = state.hemi[hemiLength];
            _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);
            _uniforms8.direction.transformDirection(viewMatrix);
            _uniforms8.direction.normalize();
            hemiLength++;
          }
        }
      }
      return {
        setup,
        setupView,
        state
      };
    }
    function WebGLRenderState2(extensions, capabilities) {
      var lights = new WebGLLights2(extensions, capabilities);
      var lightsArray = [];
      var shadowsArray = [];
      function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
      }
      function pushLight(light) {
        lightsArray.push(light);
      }
      function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
      }
      function setupLights() {
        lights.setup(lightsArray);
      }
      function setupLightsView(camera2) {
        lights.setupView(lightsArray, camera2);
      }
      var state = {
        lightsArray,
        shadowsArray,
        lights
      };
      return {
        init,
        state,
        setupLights,
        setupLightsView,
        pushLight,
        pushShadow
      };
    }
    function WebGLRenderStates2(extensions, capabilities) {
      var renderStates = new WeakMap();
      function get(scene2, renderCallDepth) {
        if (renderCallDepth === void 0) {
          renderCallDepth = 0;
        }
        var renderState;
        if (renderStates.has(scene2) === false) {
          renderState = new WebGLRenderState2(extensions, capabilities);
          renderStates.set(scene2, [renderState]);
        } else {
          if (renderCallDepth >= renderStates.get(scene2).length) {
            renderState = new WebGLRenderState2(extensions, capabilities);
            renderStates.get(scene2).push(renderState);
          } else {
            renderState = renderStates.get(scene2)[renderCallDepth];
          }
        }
        return renderState;
      }
      function dispose() {
        renderStates = new WeakMap();
      }
      return {
        get,
        dispose
      };
    }
    var MeshDepthMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshDepthMaterial3, _Material);
      function MeshDepthMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshDepthMaterial";
        _this.depthPacking = BasicDepthPacking2;
        _this.skinning = false;
        _this.morphTargets = false;
        _this.map = null;
        _this.alphaMap = null;
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.fog = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshDepthMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
      };
      return MeshDepthMaterial3;
    }(Material2);
    MeshDepthMaterial2.prototype.isMeshDepthMaterial = true;
    var MeshDistanceMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshDistanceMaterial3, _Material);
      function MeshDistanceMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshDistanceMaterial";
        _this.referencePosition = new Vector32();
        _this.nearDistance = 1;
        _this.farDistance = 1e3;
        _this.skinning = false;
        _this.morphTargets = false;
        _this.map = null;
        _this.alphaMap = null;
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.fog = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshDistanceMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
      };
      return MeshDistanceMaterial3;
    }(Material2);
    MeshDistanceMaterial2.prototype.isMeshDistanceMaterial = true;
    var vsm_frag2 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    var vsm_vert2 = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
    function WebGLShadowMap2(_renderer, _objects, maxTextureSize) {
      var _frustum = new Frustum2();
      var _shadowMapSize = new Vector22(), _viewportSize = new Vector22(), _viewport = new Vector42(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
      var shadowSide = {
        0: BackSide2,
        1: FrontSide2,
        2: DoubleSide3
      };
      var shadowMaterialVertical = new ShaderMaterial2({
        defines: {
          SAMPLE_RATE: 2 / 8,
          HALF_SAMPLE_RATE: 1 / 8
        },
        uniforms: {
          shadow_pass: {
            value: null
          },
          resolution: {
            value: new Vector22()
          },
          radius: {
            value: 4
          }
        },
        vertexShader: vsm_vert2,
        fragmentShader: vsm_frag2
      });
      var shadowMaterialHorizontal = shadowMaterialVertical.clone();
      shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
      var fullScreenTri = new BufferGeometry3();
      fullScreenTri.setAttribute("position", new BufferAttribute3(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      var fullScreenMesh = new Mesh3(fullScreenTri, shadowMaterialVertical);
      var scope = this;
      this.enabled = false;
      this.autoUpdate = true;
      this.needsUpdate = false;
      this.type = PCFShadowMap2;
      this.render = function(lights, scene2, camera2) {
        if (scope.enabled === false)
          return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
          return;
        if (lights.length === 0)
          return;
        var currentRenderTarget = _renderer.getRenderTarget();
        var activeCubeFace = _renderer.getActiveCubeFace();
        var activeMipmapLevel = _renderer.getActiveMipmapLevel();
        var _state = _renderer.state;
        _state.setBlending(NoBlending2);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        for (var i2 = 0, il = lights.length; i2 < il; i2++) {
          var light = lights[i2];
          var shadow = light.shadow;
          if (shadow === void 0) {
            console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
            continue;
          }
          if (shadow.autoUpdate === false && shadow.needsUpdate === false)
            continue;
          _shadowMapSize.copy(shadow.mapSize);
          var shadowFrameExtents = shadow.getFrameExtents();
          _shadowMapSize.multiply(shadowFrameExtents);
          _viewportSize.copy(shadow.mapSize);
          if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
            if (_shadowMapSize.x > maxTextureSize) {
              _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
              _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
              shadow.mapSize.x = _viewportSize.x;
            }
            if (_shadowMapSize.y > maxTextureSize) {
              _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
              _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
              shadow.mapSize.y = _viewportSize.y;
            }
          }
          if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap2) {
            var pars = {
              minFilter: LinearFilter2,
              magFilter: LinearFilter2,
              format: RGBAFormat2
            };
            shadow.map = new WebGLRenderTarget2(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.mapPass = new WebGLRenderTarget2(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadow.camera.updateProjectionMatrix();
          }
          if (shadow.map === null) {
            var _pars = {
              minFilter: NearestFilter2,
              magFilter: NearestFilter2,
              format: RGBAFormat2
            };
            shadow.map = new WebGLRenderTarget2(_shadowMapSize.x, _shadowMapSize.y, _pars);
            shadow.map.texture.name = light.name + ".shadowMap";
            shadow.camera.updateProjectionMatrix();
          }
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          var viewportCount = shadow.getViewportCount();
          for (var vp = 0; vp < viewportCount; vp++) {
            var viewport = shadow.getViewport(vp);
            _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
            _state.viewport(_viewport);
            shadow.updateMatrices(light, vp);
            _frustum = shadow.getFrustum();
            renderObject(scene2, camera2, shadow.camera, light, this.type);
          }
          if (!shadow.isPointLightShadow && this.type === VSMShadowMap2) {
            VSMPass(shadow, camera2);
          }
          shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
      };
      function VSMPass(shadow, camera2) {
        var geometry = _objects.update(fullScreenMesh);
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
      }
      function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        var material = _depthMaterials[index];
        if (material === void 0) {
          material = new MeshDepthMaterial2({
            depthPacking: RGBADepthPacking2,
            morphTargets: useMorphing,
            skinning: useSkinning
          });
          _depthMaterials[index] = material;
        }
        return material;
      }
      function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        var material = _distanceMaterials[index];
        if (material === void 0) {
          material = new MeshDistanceMaterial2({
            morphTargets: useMorphing,
            skinning: useSkinning
          });
          _distanceMaterials[index] = material;
        }
        return material;
      }
      function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        var result = null;
        var getMaterialVariant = getDepthMaterialVariant;
        var customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
          getMaterialVariant = getDistanceMaterialVariant;
          customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === void 0) {
          var useMorphing = false;
          if (material.morphTargets === true) {
            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
          }
          var useSkinning = false;
          if (object.isSkinnedMesh === true) {
            if (material.skinning === true) {
              useSkinning = true;
            } else {
              console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
            }
          }
          var useInstancing = object.isInstancedMesh === true;
          result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else {
          result = customMaterial;
        }
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
          var keyA = result.uuid, keyB = material.uuid;
          var materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          var cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
          }
          result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap2) {
          result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        } else {
          result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        }
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
          result.referencePosition.setFromMatrixPosition(light.matrixWorld);
          result.nearDistance = shadowCameraNear;
          result.farDistance = shadowCameraFar;
        }
        return result;
      }
      function renderObject(object, camera2, shadowCamera, light, type) {
        if (object.visible === false)
          return;
        var visible = object.layers.test(camera2.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
          if ((object.castShadow || object.receiveShadow && type === VSMShadowMap2) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
            object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
            var geometry = _objects.update(object);
            var material = object.material;
            if (Array.isArray(material)) {
              var groups = geometry.groups;
              for (var k = 0, kl = groups.length; k < kl; k++) {
                var group = groups[k];
                var groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                  _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                }
              }
            } else if (material.visible) {
              var _depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial, object, null);
            }
          }
        }
        var children = object.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          renderObject(children[i2], camera2, shadowCamera, light, type);
        }
      }
    }
    function WebGLState2(gl, extensions, capabilities) {
      var _equationToGL, _factorToGL;
      var isWebGL2 = capabilities.isWebGL2;
      function ColorBuffer() {
        var locked = false;
        var color = new Vector42();
        var currentColorMask = null;
        var currentColorClear = new Vector42(0, 0, 0, 0);
        return {
          setMask: function setMask(colorMask) {
            if (currentColorMask !== colorMask && !locked) {
              gl.colorMask(colorMask, colorMask, colorMask, colorMask);
              currentColorMask = colorMask;
            }
          },
          setLocked: function setLocked(lock) {
            locked = lock;
          },
          setClear: function setClear(r, g, b, a, premultipliedAlpha) {
            if (premultipliedAlpha === true) {
              r *= a;
              g *= a;
              b *= a;
            }
            color.set(r, g, b, a);
            if (currentColorClear.equals(color) === false) {
              gl.clearColor(r, g, b, a);
              currentColorClear.copy(color);
            }
          },
          reset: function reset2() {
            locked = false;
            currentColorMask = null;
            currentColorClear.set(-1, 0, 0, 0);
          }
        };
      }
      function DepthBuffer() {
        var locked = false;
        var currentDepthMask = null;
        var currentDepthFunc = null;
        var currentDepthClear = null;
        return {
          setTest: function setTest(depthTest) {
            if (depthTest) {
              enable(2929);
            } else {
              disable(2929);
            }
          },
          setMask: function setMask(depthMask) {
            if (currentDepthMask !== depthMask && !locked) {
              gl.depthMask(depthMask);
              currentDepthMask = depthMask;
            }
          },
          setFunc: function setFunc(depthFunc) {
            if (currentDepthFunc !== depthFunc) {
              if (depthFunc) {
                switch (depthFunc) {
                  case NeverDepth2:
                    gl.depthFunc(512);
                    break;
                  case AlwaysDepth2:
                    gl.depthFunc(519);
                    break;
                  case LessDepth2:
                    gl.depthFunc(513);
                    break;
                  case LessEqualDepth2:
                    gl.depthFunc(515);
                    break;
                  case EqualDepth2:
                    gl.depthFunc(514);
                    break;
                  case GreaterEqualDepth2:
                    gl.depthFunc(518);
                    break;
                  case GreaterDepth2:
                    gl.depthFunc(516);
                    break;
                  case NotEqualDepth2:
                    gl.depthFunc(517);
                    break;
                  default:
                    gl.depthFunc(515);
                }
              } else {
                gl.depthFunc(515);
              }
              currentDepthFunc = depthFunc;
            }
          },
          setLocked: function setLocked(lock) {
            locked = lock;
          },
          setClear: function setClear(depth) {
            if (currentDepthClear !== depth) {
              gl.clearDepth(depth);
              currentDepthClear = depth;
            }
          },
          reset: function reset2() {
            locked = false;
            currentDepthMask = null;
            currentDepthFunc = null;
            currentDepthClear = null;
          }
        };
      }
      function StencilBuffer() {
        var locked = false;
        var currentStencilMask = null;
        var currentStencilFunc = null;
        var currentStencilRef = null;
        var currentStencilFuncMask = null;
        var currentStencilFail = null;
        var currentStencilZFail = null;
        var currentStencilZPass = null;
        var currentStencilClear = null;
        return {
          setTest: function setTest(stencilTest) {
            if (!locked) {
              if (stencilTest) {
                enable(2960);
              } else {
                disable(2960);
              }
            }
          },
          setMask: function setMask(stencilMask) {
            if (currentStencilMask !== stencilMask && !locked) {
              gl.stencilMask(stencilMask);
              currentStencilMask = stencilMask;
            }
          },
          setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
            if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
              gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
              currentStencilFunc = stencilFunc;
              currentStencilRef = stencilRef;
              currentStencilFuncMask = stencilMask;
            }
          },
          setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
            if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
              gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
              currentStencilFail = stencilFail;
              currentStencilZFail = stencilZFail;
              currentStencilZPass = stencilZPass;
            }
          },
          setLocked: function setLocked(lock) {
            locked = lock;
          },
          setClear: function setClear(stencil) {
            if (currentStencilClear !== stencil) {
              gl.clearStencil(stencil);
              currentStencilClear = stencil;
            }
          },
          reset: function reset2() {
            locked = false;
            currentStencilMask = null;
            currentStencilFunc = null;
            currentStencilRef = null;
            currentStencilFuncMask = null;
            currentStencilFail = null;
            currentStencilZFail = null;
            currentStencilZPass = null;
            currentStencilClear = null;
          }
        };
      }
      var colorBuffer = new ColorBuffer();
      var depthBuffer = new DepthBuffer();
      var stencilBuffer = new StencilBuffer();
      var enabledCapabilities = {};
      var currentProgram = null;
      var currentBlendingEnabled = false;
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentPremultipledAlpha = false;
      var currentFlipSided = null;
      var currentCullFace = null;
      var currentLineWidth = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      var maxTextures = gl.getParameter(35661);
      var lineWidthAvailable = false;
      var version = 0;
      var glVersion = gl.getParameter(7938);
      if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
      } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
      }
      var currentTextureSlot = null;
      var currentBoundTextures = {};
      var currentScissor = new Vector42();
      var currentViewport = new Vector42();
      function createTexture(type, target, count) {
        var data = new Uint8Array(4);
        var texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for (var i2 = 0; i2 < count; i2++) {
          gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
        }
        return texture;
      }
      var emptyTextures = {};
      emptyTextures[3553] = createTexture(3553, 3553, 1);
      emptyTextures[34067] = createTexture(34067, 34069, 6);
      colorBuffer.setClear(0, 0, 0, 1);
      depthBuffer.setClear(1);
      stencilBuffer.setClear(0);
      enable(2929);
      depthBuffer.setFunc(LessEqualDepth2);
      setFlipSided(false);
      setCullFace(CullFaceBack2);
      enable(2884);
      setBlending(NoBlending2);
      function enable(id) {
        if (enabledCapabilities[id] !== true) {
          gl.enable(id);
          enabledCapabilities[id] = true;
        }
      }
      function disable(id) {
        if (enabledCapabilities[id] !== false) {
          gl.disable(id);
          enabledCapabilities[id] = false;
        }
      }
      function useProgram(program) {
        if (currentProgram !== program) {
          gl.useProgram(program);
          currentProgram = program;
          return true;
        }
        return false;
      }
      var equationToGL = (_equationToGL = {}, _equationToGL[AddEquation2] = 32774, _equationToGL[SubtractEquation2] = 32778, _equationToGL[ReverseSubtractEquation2] = 32779, _equationToGL);
      if (isWebGL2) {
        equationToGL[MinEquation2] = 32775;
        equationToGL[MaxEquation2] = 32776;
      } else {
        var extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
          equationToGL[MinEquation2] = extension.MIN_EXT;
          equationToGL[MaxEquation2] = extension.MAX_EXT;
        }
      }
      var factorToGL = (_factorToGL = {}, _factorToGL[ZeroFactor2] = 0, _factorToGL[OneFactor2] = 1, _factorToGL[SrcColorFactor2] = 768, _factorToGL[SrcAlphaFactor2] = 770, _factorToGL[SrcAlphaSaturateFactor2] = 776, _factorToGL[DstColorFactor2] = 774, _factorToGL[DstAlphaFactor2] = 772, _factorToGL[OneMinusSrcColorFactor2] = 769, _factorToGL[OneMinusSrcAlphaFactor2] = 771, _factorToGL[OneMinusDstColorFactor2] = 775, _factorToGL[OneMinusDstAlphaFactor2] = 773, _factorToGL);
      function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending2) {
          if (currentBlendingEnabled === true) {
            disable(3042);
            currentBlendingEnabled = false;
          }
          return;
        }
        if (currentBlendingEnabled === false) {
          enable(3042);
          currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending2) {
          if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
            if (currentBlendEquation !== AddEquation2 || currentBlendEquationAlpha !== AddEquation2) {
              gl.blendEquation(32774);
              currentBlendEquation = AddEquation2;
              currentBlendEquationAlpha = AddEquation2;
            }
            if (premultipliedAlpha) {
              switch (blending) {
                case NormalBlending2:
                  gl.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case AdditiveBlending2:
                  gl.blendFunc(1, 1);
                  break;
                case SubtractiveBlending2:
                  gl.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case MultiplyBlending2:
                  gl.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            } else {
              switch (blending) {
                case NormalBlending2:
                  gl.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case AdditiveBlending2:
                  gl.blendFunc(770, 1);
                  break;
                case SubtractiveBlending2:
                  gl.blendFunc(0, 769);
                  break;
                case MultiplyBlending2:
                  gl.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", blending);
                  break;
              }
            }
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
          }
          return;
        }
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
          gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
          currentBlendEquation = blendEquation;
          currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
          gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
          currentBlendSrc = blendSrc;
          currentBlendDst = blendDst;
          currentBlendSrcAlpha = blendSrcAlpha;
          currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
      }
      function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide3 ? disable(2884) : enable(2884);
        var flipSided = material.side === BackSide2;
        if (frontFaceCW)
          flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending2 && material.transparent === false ? setBlending(NoBlending2) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        var stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
          stencilBuffer.setMask(material.stencilWriteMask);
          stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
          stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      }
      function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(2304);
          } else {
            gl.frontFace(2305);
          }
          currentFlipSided = flipSided;
        }
      }
      function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone2) {
          enable(2884);
          if (cullFace !== currentCullFace) {
            if (cullFace === CullFaceBack2) {
              gl.cullFace(1029);
            } else if (cullFace === CullFaceFront2) {
              gl.cullFace(1028);
            } else {
              gl.cullFace(1032);
            }
          }
        } else {
          disable(2884);
        }
        currentCullFace = cullFace;
      }
      function setLineWidth(width) {
        if (width !== currentLineWidth) {
          if (lineWidthAvailable)
            gl.lineWidth(width);
          currentLineWidth = width;
        }
      }
      function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
          enable(32823);
          if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
            gl.polygonOffset(factor, units);
            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;
          }
        } else {
          disable(32823);
        }
      }
      function setScissorTest(scissorTest) {
        if (scissorTest) {
          enable(3089);
        } else {
          disable(3089);
        }
      }
      function activeTexture(webglSlot) {
        if (webglSlot === void 0)
          webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
      }
      function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) {
          activeTexture();
        }
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === void 0) {
          boundTexture = {
            type: void 0,
            texture: void 0
          };
          currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      }
      function unbindTexture() {
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== void 0 && boundTexture.type !== void 0) {
          gl.bindTexture(boundTexture.type, null);
          boundTexture.type = void 0;
          boundTexture.texture = void 0;
        }
      }
      function compressedTexImage2D() {
        try {
          gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage2D() {
        try {
          gl.texImage2D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function texImage3D() {
        try {
          gl.texImage3D.apply(gl, arguments);
        } catch (error) {
          console.error("THREE.WebGLState:", error);
        }
      }
      function scissor(scissor2) {
        if (currentScissor.equals(scissor2) === false) {
          gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
          currentScissor.copy(scissor2);
        }
      }
      function viewport(viewport2) {
        if (currentViewport.equals(viewport2) === false) {
          gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
          currentViewport.copy(viewport2);
        }
      }
      function reset() {
        gl.disable(3042);
        gl.disable(2884);
        gl.disable(2929);
        gl.disable(32823);
        gl.disable(3089);
        gl.disable(2960);
        gl.blendEquation(32774);
        gl.blendFunc(1, 0);
        gl.blendFuncSeparate(1, 0, 1, 0);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(513);
        gl.clearDepth(1);
        gl.stencilMask(4294967295);
        gl.stencilFunc(519, 0, 4294967295);
        gl.stencilOp(7680, 7680, 7680);
        gl.clearStencil(0);
        gl.cullFace(1029);
        gl.frontFace(2305);
        gl.polygonOffset(0, 0);
        gl.activeTexture(33984);
        gl.useProgram(null);
        gl.lineWidth(1);
        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentProgram = null;
        currentBlendingEnabled = false;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
      }
      return {
        buffers: {
          color: colorBuffer,
          depth: depthBuffer,
          stencil: stencilBuffer
        },
        enable,
        disable,
        useProgram,
        setBlending,
        setMaterial,
        setFlipSided,
        setCullFace,
        setLineWidth,
        setPolygonOffset,
        setScissorTest,
        activeTexture,
        bindTexture,
        unbindTexture,
        compressedTexImage2D,
        texImage2D,
        texImage3D,
        scissor,
        viewport,
        reset
      };
    }
    function WebGLTextures2(_gl, extensions, state, properties, capabilities, utils, info) {
      var _wrappingToGL, _filterToGL;
      var isWebGL2 = capabilities.isWebGL2;
      var maxTextures = capabilities.maxTextures;
      var maxCubemapSize = capabilities.maxCubemapSize;
      var maxTextureSize = capabilities.maxTextureSize;
      var maxSamples = capabilities.maxSamples;
      var _videoTextures = new WeakMap();
      var _canvas3;
      var useOffscreenCanvas = false;
      try {
        useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
      } catch (err) {
      }
      function createCanvas(width, height) {
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        var scale = 1;
        if (image.width > maxSize || image.height > maxSize) {
          scale = maxSize / Math.max(image.width, image.height);
        }
        if (scale < 1 || needsPowerOfTwo === true) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            var floor = needsPowerOfTwo ? MathUtils2.floorPowerOfTwo : Math.floor;
            var width = floor(scale * image.width);
            var height = floor(scale * image.height);
            if (_canvas3 === void 0)
              _canvas3 = createCanvas(width, height);
            var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas3;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, width, height);
            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
            return canvas;
          } else {
            if ("data" in image) {
              console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
            }
            return image;
          }
        }
        return image;
      }
      function isPowerOfTwo(image) {
        return MathUtils2.isPowerOfTwo(image.width) && MathUtils2.isPowerOfTwo(image.height);
      }
      function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2)
          return false;
        return texture.wrapS !== ClampToEdgeWrapping2 || texture.wrapT !== ClampToEdgeWrapping2 || texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2;
      }
      function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2;
      }
      function generateMipmap(target, texture, width, height) {
        _gl.generateMipmap(target);
        var textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
      }
      function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false)
          return glFormat;
        if (internalFormatName !== null) {
          if (_gl[internalFormatName] !== void 0)
            return _gl[internalFormatName];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
        }
        var internalFormat = glFormat;
        if (glFormat === 6403) {
          if (glType === 5126)
            internalFormat = 33326;
          if (glType === 5131)
            internalFormat = 33325;
          if (glType === 5121)
            internalFormat = 33321;
        }
        if (glFormat === 6407) {
          if (glType === 5126)
            internalFormat = 34837;
          if (glType === 5131)
            internalFormat = 34843;
          if (glType === 5121)
            internalFormat = 32849;
        }
        if (glFormat === 6408) {
          if (glType === 5126)
            internalFormat = 34836;
          if (glType === 5131)
            internalFormat = 34842;
          if (glType === 5121)
            internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
          extensions.get("EXT_color_buffer_float");
        }
        return internalFormat;
      }
      function filterFallback(f) {
        if (f === NearestFilter2 || f === NearestMipmapNearestFilter2 || f === NearestMipmapLinearFilter2) {
          return 9728;
        }
        return 9729;
      }
      function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) {
          _videoTextures.delete(texture);
        }
        info.memory.textures--;
      }
      function onRenderTargetDispose(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
      }
      function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === void 0)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
      }
      function deallocateRenderTarget(renderTarget) {
        var texture = renderTarget.texture;
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(texture);
        if (!renderTarget)
          return;
        if (textureProperties.__webglTexture !== void 0) {
          _gl.deleteTexture(textureProperties.__webglTexture);
        }
        if (renderTarget.depthTexture) {
          renderTarget.depthTexture.dispose();
        }
        if (renderTarget.isWebGLCubeRenderTarget) {
          for (var i2 = 0; i2 < 6; i2++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
          }
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
          if (renderTargetProperties.__webglMultisampledFramebuffer)
            _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
          if (renderTargetProperties.__webglColorRenderbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
          if (renderTargetProperties.__webglDepthRenderbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        properties.remove(texture);
        properties.remove(renderTarget);
      }
      var textureUnits = 0;
      function resetTextureUnits() {
        textureUnits = 0;
      }
      function allocateTextureUnit() {
        var textureUnit = textureUnits;
        if (textureUnit >= maxTextures) {
          console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
        }
        textureUnits += 1;
        return textureUnit;
      }
      function setTexture2D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.isVideoTexture)
          updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          var image = texture.image;
          if (image === void 0) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
          } else if (image.complete === false) {
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          } else {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
      }
      function setTexture2DArray(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
      }
      function setTexture3D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
      }
      function setTextureCube(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          uploadCubeTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
      }
      var wrappingToGL = (_wrappingToGL = {}, _wrappingToGL[RepeatWrapping2] = 10497, _wrappingToGL[ClampToEdgeWrapping2] = 33071, _wrappingToGL[MirroredRepeatWrapping2] = 33648, _wrappingToGL);
      var filterToGL = (_filterToGL = {}, _filterToGL[NearestFilter2] = 9728, _filterToGL[NearestMipmapNearestFilter2] = 9984, _filterToGL[NearestMipmapLinearFilter2] = 9986, _filterToGL[LinearFilter2] = 9729, _filterToGL[LinearMipmapNearestFilter2] = 9985, _filterToGL[LinearMipmapLinearFilter2] = 9987, _filterToGL);
      function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
          _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
          _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
          }
          _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
          _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
          _gl.texParameteri(textureType, 10242, 33071);
          _gl.texParameteri(textureType, 10243, 33071);
          if (textureType === 32879 || textureType === 35866) {
            _gl.texParameteri(textureType, 32882, 33071);
          }
          if (texture.wrapS !== ClampToEdgeWrapping2 || texture.wrapT !== ClampToEdgeWrapping2) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
          }
          _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
          if (texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2) {
            console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
          }
        }
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
          var extension = extensions.get("EXT_texture_filter_anisotropic");
          if (texture.type === FloatType2 && extensions.has("OES_texture_float_linear") === false)
            return;
          if (isWebGL2 === false && texture.type === HalfFloatType2 && extensions.has("OES_texture_half_float_linear") === false)
            return;
          if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === void 0) {
          textureProperties.__webglInit = true;
          texture.addEventListener("dispose", onTextureDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          info.memory.textures++;
        }
      }
      function uploadTexture(textureProperties, texture, slot) {
        var textureType = 3553;
        if (texture.isDataTexture2DArray)
          textureType = 35866;
        if (texture.isDataTexture3D)
          textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        var supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        var glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        var mipmap;
        var mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (isWebGL2) {
            if (texture.type === FloatType2) {
              glInternalFormat = 36012;
            } else if (texture.type === UnsignedIntType2) {
              glInternalFormat = 33190;
            } else if (texture.type === UnsignedInt248Type2) {
              glInternalFormat = 35056;
            } else {
              glInternalFormat = 33189;
            }
          } else {
            if (texture.type === FloatType2) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat2 && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType2 && texture.type !== UnsignedIntType2) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedShortType2;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat2 && glInternalFormat === 6402) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type2) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type2;
              glType = utils.convert(texture.type);
            }
          }
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            for (var i2 = 0, il = mipmaps.length; i2 < il; i2++) {
              mipmap = mipmaps[i2];
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
          }
        } else if (texture.isCompressedTexture) {
          for (var _i = 0, _il = mipmaps.length; _i < _il; _i++) {
            mipmap = mipmaps[_i];
            if (texture.format !== RGBAFormat2 && texture.format !== RGBFormat2) {
              if (glFormat !== null) {
                state.compressedTexImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              state.texImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            for (var _i2 = 0, _il2 = mipmaps.length; _i2 < _il2; _i2++) {
              mipmap = mipmaps[_i2];
              state.texImage2D(3553, _i2, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6)
          return;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];
        for (var i2 = 0; i2 < 6; i2++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
          } else {
            cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
          }
        }
        var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);
        var mipmaps;
        if (isCompressed) {
          for (var _i3 = 0; _i3 < 6; _i3++) {
            mipmaps = cubeImage[_i3].mipmaps;
            for (var j = 0; j < mipmaps.length; j++) {
              var mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat2 && texture.format !== RGBFormat2) {
                if (glFormat !== null) {
                  state.compressedTexImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                state.texImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          mipmaps = texture.mipmaps;
          for (var _i4 = 0; _i4 < 6; _i4++) {
            if (isDataTexture) {
              state.texImage2D(34069 + _i4, 0, glInternalFormat, cubeImage[_i4].width, cubeImage[_i4].height, 0, glFormat, glType, cubeImage[_i4].data);
              for (var _j = 0; _j < mipmaps.length; _j++) {
                var _mipmap = mipmaps[_j];
                var mipmapImage = _mipmap.image[_i4].image;
                state.texImage2D(34069 + _i4, _j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            } else {
              state.texImage2D(34069 + _i4, 0, glInternalFormat, glFormat, glType, cubeImage[_i4]);
              for (var _j2 = 0; _j2 < mipmaps.length; _j2++) {
                var _mipmap2 = mipmaps[_j2];
                state.texImage2D(34069 + _i4, _j2 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i4]);
              }
            }
          }
          textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, image.width, image.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        var texture = renderTarget.texture;
        var glFormat = utils.convert(texture.format);
        var glType = utils.convert(texture.type);
        var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        if (textureTarget === 32879 || textureTarget === 35866) {
          state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
        _gl.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
        _gl.bindFramebuffer(36160, null);
      }
      function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          var glInternalFormat = 33189;
          if (isMultisample) {
            var depthTexture = renderTarget.depthTexture;
            if (depthTexture && depthTexture.isDepthTexture) {
              if (depthTexture.type === FloatType2) {
                glInternalFormat = 36012;
              } else if (depthTexture.type === UnsignedIntType2) {
                glInternalFormat = 33190;
              }
            }
            var samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          if (isMultisample) {
            var _samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, _samples, 35056, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
          }
          _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
          var texture = renderTarget.texture;
          var glFormat = utils.convert(texture.format);
          var glType = utils.convert(texture.type);
          var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          if (isMultisample) {
            var _samples2 = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, _glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
        _gl.bindRenderbuffer(36161, null);
      }
      function setupDepthTexture(framebuffer, renderTarget) {
        var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube)
          throw new Error("Depth Texture with cube render targets is not supported");
        _gl.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
          throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        }
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
          renderTarget.depthTexture.image.width = renderTarget.width;
          renderTarget.depthTexture.image.height = renderTarget.height;
          renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat2) {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === DepthStencilFormat2) {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        } else {
          throw new Error("Unknown depthTexture format");
        }
      }
      function setupDepthRenderbuffer(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
          if (isCube)
            throw new Error("target.depthTexture not supported in Cube render targets");
          setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else {
          if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for (var i2 = 0; i2 < 6; i2++) {
              _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
              renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
            }
          } else {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
          }
        }
        _gl.bindFramebuffer(36160, null);
      }
      function setupRenderTarget(renderTarget) {
        var texture = renderTarget.texture;
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        var isCube = renderTarget.isWebGLCubeRenderTarget === true;
        var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        var isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
        var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (isWebGL2 && texture.format === RGBFormat2 && (texture.type === FloatType2 || texture.type === HalfFloatType2)) {
          texture.format = RGBAFormat2;
          console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
        }
        if (isCube) {
          renderTargetProperties.__webglFramebuffer = [];
          for (var i2 = 0; i2 < 6; i2++) {
            renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
          if (isMultisample) {
            if (isWebGL2) {
              renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
              renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
              _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
              var glFormat = utils.convert(texture.format);
              var glType = utils.convert(texture.type);
              var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
              var samples = getRenderTargetSamples(renderTarget);
              _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
              _gl.bindRenderbuffer(36161, null);
              if (renderTarget.depthBuffer) {
                renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
              }
              _gl.bindFramebuffer(36160, null);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          }
        }
        if (isCube) {
          state.bindTexture(34067, textureProperties.__webglTexture);
          setTextureParameters(34067, texture, supportsMips);
          for (var _i5 = 0; _i5 < 6; _i5++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i5], renderTarget, 36064, 34069 + _i5);
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
          }
          state.bindTexture(34067, null);
        } else {
          var glTextureType = 3553;
          if (isRenderTarget3D) {
            if (isWebGL2) {
              var isTexture3D = texture.isDataTexture3D;
              glTextureType = isTexture3D ? 32879 : 35866;
            } else {
              console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
            }
          }
          state.bindTexture(glTextureType, textureProperties.__webglTexture);
          setTextureParameters(glTextureType, texture, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
          }
          state.bindTexture(3553, null);
        }
        if (renderTarget.depthBuffer) {
          setupDepthRenderbuffer(renderTarget);
        }
      }
      function updateRenderTargetMipmap(renderTarget) {
        var texture = renderTarget.texture;
        var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          var webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target, texture, renderTarget.width, renderTarget.height);
          state.bindTexture(target, null);
        }
      }
      function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
          if (isWebGL2) {
            var renderTargetProperties = properties.get(renderTarget);
            _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
            var width = renderTarget.width;
            var height = renderTarget.height;
            var mask = 16384;
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
      }
      function updateVideoTexture(texture) {
        var frame = info.render.frame;
        if (_videoTextures.get(texture) !== frame) {
          _videoTextures.set(texture, frame);
          texture.update();
        }
      }
      var warnedTexture2D = false;
      var warnedTextureCube = false;
      function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
          if (warnedTexture2D === false) {
            console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
            warnedTexture2D = true;
          }
          texture = texture.texture;
        }
        setTexture2D(texture, slot);
      }
      function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
          if (warnedTextureCube === false) {
            console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
            warnedTextureCube = true;
          }
          texture = texture.texture;
        }
        setTextureCube(texture, slot);
      }
      this.allocateTextureUnit = allocateTextureUnit;
      this.resetTextureUnits = resetTextureUnits;
      this.setTexture2D = setTexture2D;
      this.setTexture2DArray = setTexture2DArray;
      this.setTexture3D = setTexture3D;
      this.setTextureCube = setTextureCube;
      this.setupRenderTarget = setupRenderTarget;
      this.updateRenderTargetMipmap = updateRenderTargetMipmap;
      this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
      this.safeSetTexture2D = safeSetTexture2D;
      this.safeSetTextureCube = safeSetTextureCube;
    }
    function WebGLUtils2(gl, extensions, capabilities) {
      var isWebGL2 = capabilities.isWebGL2;
      function convert(p) {
        var extension;
        if (p === UnsignedByteType2)
          return 5121;
        if (p === UnsignedShort4444Type2)
          return 32819;
        if (p === UnsignedShort5551Type2)
          return 32820;
        if (p === UnsignedShort565Type2)
          return 33635;
        if (p === ByteType2)
          return 5120;
        if (p === ShortType2)
          return 5122;
        if (p === UnsignedShortType2)
          return 5123;
        if (p === IntType2)
          return 5124;
        if (p === UnsignedIntType2)
          return 5125;
        if (p === FloatType2)
          return 5126;
        if (p === HalfFloatType2) {
          if (isWebGL2)
            return 5131;
          extension = extensions.get("OES_texture_half_float");
          if (extension !== null) {
            return extension.HALF_FLOAT_OES;
          } else {
            return null;
          }
        }
        if (p === AlphaFormat2)
          return 6406;
        if (p === RGBFormat2)
          return 6407;
        if (p === RGBAFormat2)
          return 6408;
        if (p === LuminanceFormat2)
          return 6409;
        if (p === LuminanceAlphaFormat2)
          return 6410;
        if (p === DepthFormat2)
          return 6402;
        if (p === DepthStencilFormat2)
          return 34041;
        if (p === RedFormat2)
          return 6403;
        if (p === RedIntegerFormat2)
          return 36244;
        if (p === RGFormat2)
          return 33319;
        if (p === RGIntegerFormat2)
          return 33320;
        if (p === RGBIntegerFormat2)
          return 36248;
        if (p === RGBAIntegerFormat2)
          return 36249;
        if (p === RGB_S3TC_DXT1_Format2 || p === RGBA_S3TC_DXT1_Format2 || p === RGBA_S3TC_DXT3_Format2 || p === RGBA_S3TC_DXT5_Format2) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format2)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format2)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format2)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format2)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
        if (p === RGB_PVRTC_4BPPV1_Format2 || p === RGB_PVRTC_2BPPV1_Format2 || p === RGBA_PVRTC_4BPPV1_Format2 || p === RGBA_PVRTC_2BPPV1_Format2) {
          extension = extensions.get("WEBGL_compressed_texture_pvrtc");
          if (extension !== null) {
            if (p === RGB_PVRTC_4BPPV1_Format2)
              return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === RGB_PVRTC_2BPPV1_Format2)
              return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === RGBA_PVRTC_4BPPV1_Format2)
              return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === RGBA_PVRTC_2BPPV1_Format2)
              return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else {
            return null;
          }
        }
        if (p === RGB_ETC1_Format2) {
          extension = extensions.get("WEBGL_compressed_texture_etc1");
          if (extension !== null) {
            return extension.COMPRESSED_RGB_ETC1_WEBGL;
          } else {
            return null;
          }
        }
        if (p === RGB_ETC2_Format2 || p === RGBA_ETC2_EAC_Format2) {
          extension = extensions.get("WEBGL_compressed_texture_etc");
          if (extension !== null) {
            if (p === RGB_ETC2_Format2)
              return extension.COMPRESSED_RGB8_ETC2;
            if (p === RGBA_ETC2_EAC_Format2)
              return extension.COMPRESSED_RGBA8_ETC2_EAC;
          }
        }
        if (p === RGBA_ASTC_4x4_Format2 || p === RGBA_ASTC_5x4_Format2 || p === RGBA_ASTC_5x5_Format2 || p === RGBA_ASTC_6x5_Format2 || p === RGBA_ASTC_6x6_Format2 || p === RGBA_ASTC_8x5_Format2 || p === RGBA_ASTC_8x6_Format2 || p === RGBA_ASTC_8x8_Format2 || p === RGBA_ASTC_10x5_Format2 || p === RGBA_ASTC_10x6_Format2 || p === RGBA_ASTC_10x8_Format2 || p === RGBA_ASTC_10x10_Format2 || p === RGBA_ASTC_12x10_Format2 || p === RGBA_ASTC_12x12_Format2 || p === SRGB8_ALPHA8_ASTC_4x4_Format2 || p === SRGB8_ALPHA8_ASTC_5x4_Format2 || p === SRGB8_ALPHA8_ASTC_5x5_Format2 || p === SRGB8_ALPHA8_ASTC_6x5_Format2 || p === SRGB8_ALPHA8_ASTC_6x6_Format2 || p === SRGB8_ALPHA8_ASTC_8x5_Format2 || p === SRGB8_ALPHA8_ASTC_8x6_Format2 || p === SRGB8_ALPHA8_ASTC_8x8_Format2 || p === SRGB8_ALPHA8_ASTC_10x5_Format2 || p === SRGB8_ALPHA8_ASTC_10x6_Format2 || p === SRGB8_ALPHA8_ASTC_10x8_Format2 || p === SRGB8_ALPHA8_ASTC_10x10_Format2 || p === SRGB8_ALPHA8_ASTC_12x10_Format2 || p === SRGB8_ALPHA8_ASTC_12x12_Format2) {
          extension = extensions.get("WEBGL_compressed_texture_astc");
          if (extension !== null) {
            return p;
          } else {
            return null;
          }
        }
        if (p === RGBA_BPTC_Format2) {
          extension = extensions.get("EXT_texture_compression_bptc");
          if (extension !== null) {
            return p;
          } else {
            return null;
          }
        }
        if (p === UnsignedInt248Type2) {
          if (isWebGL2)
            return 34042;
          extension = extensions.get("WEBGL_depth_texture");
          if (extension !== null) {
            return extension.UNSIGNED_INT_24_8_WEBGL;
          } else {
            return null;
          }
        }
      }
      return {
        convert
      };
    }
    function ArrayCamera2(array) {
      if (array === void 0) {
        array = [];
      }
      PerspectiveCamera3.call(this);
      this.cameras = array;
    }
    ArrayCamera2.prototype = Object.assign(Object.create(PerspectiveCamera3.prototype), {
      constructor: ArrayCamera2,
      isArrayCamera: true
    });
    var Group2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(Group3, _Object3D);
      function Group3() {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "Group";
        return _this;
      }
      return Group3;
    }(Object3D2);
    Group2.prototype.isGroup = true;
    function WebXRController2() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    Object.assign(WebXRController2.prototype, {
      constructor: WebXRController2,
      getHandSpace: function getHandSpace() {
        if (this._hand === null) {
          this._hand = new Group2();
          this._hand.matrixAutoUpdate = false;
          this._hand.visible = false;
          this._hand.joints = {};
          this._hand.inputState = {
            pinching: false
          };
        }
        return this._hand;
      },
      getTargetRaySpace: function getTargetRaySpace() {
        if (this._targetRay === null) {
          this._targetRay = new Group2();
          this._targetRay.matrixAutoUpdate = false;
          this._targetRay.visible = false;
        }
        return this._targetRay;
      },
      getGripSpace: function getGripSpace() {
        if (this._grip === null) {
          this._grip = new Group2();
          this._grip.matrixAutoUpdate = false;
          this._grip.visible = false;
        }
        return this._grip;
      },
      dispatchEvent: function dispatchEvent(event) {
        if (this._targetRay !== null) {
          this._targetRay.dispatchEvent(event);
        }
        if (this._grip !== null) {
          this._grip.dispatchEvent(event);
        }
        if (this._hand !== null) {
          this._hand.dispatchEvent(event);
        }
        return this;
      },
      disconnect: function disconnect(inputSource) {
        this.dispatchEvent({
          type: "disconnected",
          data: inputSource
        });
        if (this._targetRay !== null) {
          this._targetRay.visible = false;
        }
        if (this._grip !== null) {
          this._grip.visible = false;
        }
        if (this._hand !== null) {
          this._hand.visible = false;
        }
        return this;
      },
      update: function update(inputSource, frame, referenceSpace) {
        var inputPose = null;
        var gripPose = null;
        var handPose = null;
        var targetRay = this._targetRay;
        var grip = this._grip;
        var hand = this._hand;
        if (inputSource && frame.session.visibilityState !== "visible-blurred") {
          if (hand && inputSource.hand) {
            handPose = true;
            for (var _iterator = _createForOfIteratorHelperLoose(inputSource.hand.values()), _step; !(_step = _iterator()).done; ) {
              var inputjoint = _step.value;
              var jointPose = frame.getJointPose(inputjoint, referenceSpace);
              if (hand.joints[inputjoint.jointName] === void 0) {
                var _joint = new Group2();
                _joint.matrixAutoUpdate = false;
                _joint.visible = false;
                hand.joints[inputjoint.jointName] = _joint;
                hand.add(_joint);
              }
              var joint = hand.joints[inputjoint.jointName];
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
            }
            var indexTip = hand.joints["index-finger-tip"];
            var thumbTip = hand.joints["thumb-tip"];
            var distance = indexTip.position.distanceTo(thumbTip.position);
            var distanceToPinch = 0.02;
            var threshold = 5e-3;
            if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
              hand.inputState.pinching = false;
              this.dispatchEvent({
                type: "pinchend",
                handedness: inputSource.handedness,
                target: this
              });
            } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
              hand.inputState.pinching = true;
              this.dispatchEvent({
                type: "pinchstart",
                handedness: inputSource.handedness,
                target: this
              });
            }
          } else {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
              }
            }
            if (grip !== null && inputSource.gripSpace) {
              gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
              if (gripPose !== null) {
                grip.matrix.fromArray(gripPose.transform.matrix);
                grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              }
            }
          }
        }
        if (targetRay !== null) {
          targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
          grip.visible = gripPose !== null;
        }
        if (hand !== null) {
          hand.visible = handPose !== null;
        }
        return this;
      }
    });
    function WebXRManager2(renderer2, gl) {
      var scope = this;
      var session = null;
      var framebufferScaleFactor = 1;
      var referenceSpace = null;
      var referenceSpaceType = "local-floor";
      var pose = null;
      var controllers = [];
      var inputSourcesMap = new Map();
      var cameraL = new PerspectiveCamera3();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector42();
      var cameraR = new PerspectiveCamera3();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector42();
      var cameras = [cameraL, cameraR];
      var cameraVR = new ArrayCamera2();
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);
      var _currentDepthNear = null;
      var _currentDepthFar = null;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index) {
        var controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController2();
          controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index) {
        var controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController2();
          controllers[index] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index) {
        var controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController2();
          controllers[index] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event) {
        var controller = inputSourcesMap.get(event.inputSource);
        if (controller) {
          controller.dispatchEvent({
            type: event.type,
            data: event.inputSource
          });
        }
      }
      function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
          controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        _currentDepthNear = null;
        _currentDepthFar = null;
        renderer2.setFramebuffer(null);
        renderer2.setRenderTarget(renderer2.getRenderTarget());
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({
          type: "sessionend"
        });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return referenceSpace;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(/* @__PURE__ */ regeneratorRuntime.mark(function _callee(value) {
          var attributes, layerInit, baseLayer;
          return regeneratorRuntime.wrap(function _callee$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  session = value;
                  if (!(session !== null)) {
                    _context3.next = 24;
                    break;
                  }
                  session.addEventListener("select", onSessionEvent);
                  session.addEventListener("selectstart", onSessionEvent);
                  session.addEventListener("selectend", onSessionEvent);
                  session.addEventListener("squeeze", onSessionEvent);
                  session.addEventListener("squeezestart", onSessionEvent);
                  session.addEventListener("squeezeend", onSessionEvent);
                  session.addEventListener("end", onSessionEnd);
                  session.addEventListener("inputsourceschange", onInputSourcesChange);
                  attributes = gl.getContextAttributes();
                  if (!(attributes.xrCompatible !== true)) {
                    _context3.next = 14;
                    break;
                  }
                  _context3.next = 14;
                  return gl.makeXRCompatible();
                case 14:
                  layerInit = {
                    antialias: attributes.antialias,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil,
                    framebufferScaleFactor
                  };
                  baseLayer = new XRWebGLLayer(session, gl, layerInit);
                  session.updateRenderState({
                    baseLayer
                  });
                  _context3.next = 19;
                  return session.requestReferenceSpace(referenceSpaceType);
                case 19:
                  referenceSpace = _context3.sent;
                  animation.setContext(session);
                  animation.start();
                  scope.isPresenting = true;
                  scope.dispatchEvent({
                    type: "sessionstart"
                  });
                case 24:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee);
        }));
        return function(_x3) {
          return _ref.apply(this, arguments);
        };
      }();
      function onInputSourcesChange(event) {
        var inputSources = session.inputSources;
        for (var i2 = 0; i2 < controllers.length; i2++) {
          inputSourcesMap.set(inputSources[i2], controllers[i2]);
        }
        for (var _i = 0; _i < event.removed.length; _i++) {
          var inputSource = event.removed[_i];
          var controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({
              type: "disconnected",
              data: inputSource
            });
            inputSourcesMap.delete(inputSource);
          }
        }
        for (var _i2 = 0; _i2 < event.added.length; _i2++) {
          var _inputSource = event.added[_i2];
          var _controller = inputSourcesMap.get(_inputSource);
          if (_controller) {
            _controller.dispatchEvent({
              type: "connected",
              data: _inputSource
            });
          }
        }
      }
      var cameraLPos = new Vector32();
      var cameraRPos = new Vector32();
      function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        var ipd = cameraLPos.distanceTo(cameraRPos);
        var projL = cameraL2.projectionMatrix.elements;
        var projR = cameraR2.projectionMatrix.elements;
        var near = projL[14] / (projL[10] - 1);
        var far = projL[14] / (projL[10] + 1);
        var topFov = (projL[9] + 1) / projL[5];
        var bottomFov = (projL[9] - 1) / projL[5];
        var leftFov = (projL[8] - 1) / projL[0];
        var rightFov = (projR[8] + 1) / projR[0];
        var left = near * leftFov;
        var right = near * rightFov;
        var zOffset = ipd / (-leftFov + rightFov);
        var xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
        camera2.translateX(xOffset);
        camera2.translateZ(zOffset);
        camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
        camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
        var near2 = near + zOffset;
        var far2 = far + zOffset;
        var left2 = left - xOffset;
        var right2 = right + (ipd - xOffset);
        var top2 = topFov * far / far2 * near2;
        var bottom2 = bottomFov * far / far2 * near2;
        camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      }
      function updateCamera(camera2, parent) {
        if (parent === null) {
          camera2.matrixWorld.copy(camera2.matrix);
        } else {
          camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
        }
        camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
      }
      this.getCamera = function(camera2) {
        cameraVR.near = cameraR.near = cameraL.near = camera2.near;
        cameraVR.far = cameraR.far = cameraL.far = camera2.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
          session.updateRenderState({
            depthNear: cameraVR.near,
            depthFar: cameraVR.far
          });
          _currentDepthNear = cameraVR.near;
          _currentDepthFar = cameraVR.far;
        }
        var parent = camera2.parent;
        var cameras2 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (var i2 = 0; i2 < cameras2.length; i2++) {
          updateCamera(cameras2[i2], parent);
        }
        camera2.matrixWorld.copy(cameraVR.matrixWorld);
        camera2.matrix.copy(cameraVR.matrix);
        camera2.matrix.decompose(camera2.position, camera2.quaternion, camera2.scale);
        var children = camera2.children;
        for (var _i3 = 0, l = children.length; _i3 < l; _i3++) {
          children[_i3].updateMatrixWorld(true);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraVR, cameraL, cameraR);
        } else {
          cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
        return cameraVR;
      };
      var onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
          var views = pose.views;
          var baseLayer = session.renderState.baseLayer;
          renderer2.setFramebuffer(baseLayer.framebuffer);
          var cameraVRNeedsUpdate = false;
          if (views.length !== cameraVR.cameras.length) {
            cameraVR.cameras.length = 0;
            cameraVRNeedsUpdate = true;
          }
          for (var i2 = 0; i2 < views.length; i2++) {
            var view = views[i2];
            var viewport = baseLayer.getViewport(view);
            var camera2 = cameras[i2];
            camera2.matrix.fromArray(view.transform.matrix);
            camera2.projectionMatrix.fromArray(view.projectionMatrix);
            camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i2 === 0) {
              cameraVR.matrix.copy(camera2.matrix);
            }
            if (cameraVRNeedsUpdate === true) {
              cameraVR.cameras.push(camera2);
            }
          }
        }
        var inputSources = session.inputSources;
        for (var _i4 = 0; _i4 < controllers.length; _i4++) {
          var controller = controllers[_i4];
          var inputSource = inputSources[_i4];
          controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time, frame);
      }
      var animation = new WebGLAnimation2();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
    Object.assign(WebXRManager2.prototype, EventDispatcher2.prototype);
    function WebGLMaterials2(properties) {
      function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
        if (material.isMeshBasicMaterial) {
          refreshUniformsCommon(uniforms, material);
        } else if (material.isMeshLambertMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
          refreshUniformsCommon(uniforms, material);
          if (material.isMeshPhysicalMaterial) {
            refreshUniformsPhysical(uniforms, material);
          } else {
            refreshUniformsStandard(uniforms, material);
          }
        } else if (material.isMeshMatcapMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
          refreshUniformsCommon(uniforms, material);
          refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
          refreshUniformsLine(uniforms, material);
          if (material.isLineDashedMaterial) {
            refreshUniformsDash(uniforms, material);
          }
        } else if (material.isPointsMaterial) {
          refreshUniformsPoints(uniforms, material, pixelRatio, height);
        } else if (material.isSpriteMaterial) {
          refreshUniformsSprites(uniforms, material);
        } else if (material.isShadowMaterial) {
          uniforms.color.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) {
          material.uniformsNeedUpdate = false;
        }
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) {
          uniforms.diffuse.value.copy(material.color);
        }
        if (material.emissive) {
          uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        }
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        if (material.specularMap) {
          uniforms.specularMap.value = material.specularMap;
        }
        var envMap = properties.get(material).envMap;
        if (envMap) {
          uniforms.envMap.value = envMap;
          uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
          uniforms.reflectivity.value = material.reflectivity;
          uniforms.refractionRatio.value = material.refractionRatio;
          var maxMipLevel = properties.get(envMap).__maxMipLevel;
          if (maxMipLevel !== void 0) {
            uniforms.maxMipLevel.value = maxMipLevel;
          }
        }
        if (material.lightMap) {
          uniforms.lightMap.value = material.lightMap;
          uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
          uniforms.aoMap.value = material.aoMap;
          uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.roughnessMap) {
          uvScaleMap = material.roughnessMap;
        } else if (material.metalnessMap) {
          uvScaleMap = material.metalnessMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        } else if (material.clearcoatMap) {
          uvScaleMap = material.clearcoatMap;
        } else if (material.clearcoatNormalMap) {
          uvScaleMap = material.clearcoatNormalMap;
        } else if (material.clearcoatRoughnessMap) {
          uvScaleMap = material.clearcoatRoughnessMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
          }
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        var uv2ScaleMap;
        if (material.aoMap) {
          uv2ScaleMap = material.aoMap;
        } else if (material.lightMap) {
          uv2ScaleMap = material.lightMap;
        }
        if (uv2ScaleMap !== void 0) {
          if (uv2ScaleMap.isWebGLRenderTarget) {
            uv2ScaleMap = uv2ScaleMap.texture;
          }
          if (uv2ScaleMap.matrixAutoUpdate === true) {
            uv2ScaleMap.updateMatrix();
          }
          uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) {
          uniforms.map.value = material.map;
        }
        if (material.alphaMap) {
          uniforms.alphaMap.value = material.alphaMap;
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== void 0) {
          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }
          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
      }
      function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 1e-4);
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide2)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide2)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) {
          uniforms.gradientMap.value = material.gradientMap;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide2)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide2)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) {
          uniforms.roughnessMap.value = material.roughnessMap;
        }
        if (material.metalnessMap) {
          uniforms.metalnessMap.value = material.metalnessMap;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide2)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide2)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
        var envMap = properties.get(material).envMap;
        if (envMap) {
          uniforms.envMapIntensity.value = material.envMapIntensity;
        }
      }
      function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen)
          uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide2) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
        uniforms.transmission.value = material.transmission;
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
      }
      function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) {
          uniforms.matcap.value = material.matcap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide2)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide2)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
      }
      function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
          if (material.side === BackSide2)
            uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
          if (material.side === BackSide2)
            uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      return {
        refreshFogUniforms,
        refreshMaterialUniforms
      };
    }
    function createCanvasElement2() {
      var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      canvas.style.display = "block";
      return canvas;
    }
    function WebGLRenderer3(parameters) {
      parameters = parameters || {};
      var _canvas3 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement2(), _context3 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
      var currentRenderList = null;
      var currentRenderState = null;
      var renderListStack = [];
      var renderStateStack = [];
      this.domElement = _canvas3;
      this.debug = {
        checkShaderErrors: true
      };
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.clippingPlanes = [];
      this.localClippingEnabled = false;
      this.gammaFactor = 2;
      this.outputEncoding = LinearEncoding2;
      this.physicallyCorrectLights = false;
      this.toneMapping = NoToneMapping2;
      this.toneMappingExposure = 1;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      var _this = this;
      var _isContextLost = false;
      var _framebuffer = null;
      var _currentActiveCubeFace = 0;
      var _currentActiveMipmapLevel = 0;
      var _currentRenderTarget = null;
      var _currentFramebuffer = null;
      var _currentMaterialId = -1;
      var _currentCamera = null;
      var _currentViewport = new Vector42();
      var _currentScissor = new Vector42();
      var _currentScissorTest = null;
      var _width = _canvas3.width;
      var _height = _canvas3.height;
      var _pixelRatio = 1;
      var _opaqueSort = null;
      var _transparentSort = null;
      var _viewport = new Vector42(0, 0, _width, _height);
      var _scissor = new Vector42(0, 0, _width, _height);
      var _scissorTest = false;
      var _frustum = new Frustum2();
      var _clippingEnabled = false;
      var _localClippingEnabled = false;
      var _projScreenMatrix3 = new Matrix43();
      var _vector32 = new Vector32();
      var _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
      };
      function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
      }
      var _gl = _context3;
      function getContext(contextNames2, contextAttributes2) {
        for (var i2 = 0; i2 < contextNames2.length; i2++) {
          var contextName = contextNames2[i2];
          var context = _canvas3.getContext(contextName, contextAttributes2);
          if (context !== null)
            return context;
        }
        return null;
      }
      try {
        var contextAttributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer,
          powerPreference: _powerPreference,
          failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        _canvas3.addEventListener("webglcontextlost", onContextLost, false);
        _canvas3.addEventListener("webglcontextrestored", onContextRestore, false);
        if (_gl === null) {
          var contextNames = ["webgl2", "webgl", "experimental-webgl"];
          if (_this.isWebGL1Renderer === true) {
            contextNames.shift();
          }
          _gl = getContext(contextNames, contextAttributes);
          if (_gl === null) {
            if (getContext(contextNames)) {
              throw new Error("Error creating WebGL context with your selected attributes.");
            } else {
              throw new Error("Error creating WebGL context.");
            }
          }
        }
        if (_gl.getShaderPrecisionFormat === void 0) {
          _gl.getShaderPrecisionFormat = function() {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1
            };
          };
        }
      } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
      }
      var extensions, capabilities, state, info;
      var properties, textures, cubemaps, attributes, geometries, objects;
      var programCache, materials, renderLists, renderStates, clipping;
      var background, morphtargets, bufferRenderer, indexedBufferRenderer;
      var utils, bindingStates;
      function initGLContext() {
        extensions = new WebGLExtensions2(_gl);
        capabilities = new WebGLCapabilities2(_gl, extensions, parameters);
        extensions.init(capabilities);
        utils = new WebGLUtils2(_gl, extensions, capabilities);
        state = new WebGLState2(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo2(_gl);
        properties = new WebGLProperties2();
        textures = new WebGLTextures2(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps2(_this);
        attributes = new WebGLAttributes2(_gl, capabilities);
        bindingStates = new WebGLBindingStates2(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries2(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects2(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets2(_gl);
        clipping = new WebGLClipping2(properties);
        programCache = new WebGLPrograms2(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials2(properties);
        renderLists = new WebGLRenderLists2(properties);
        renderStates = new WebGLRenderStates2(extensions, capabilities);
        background = new WebGLBackground2(_this, cubemaps, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer2(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer2(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
      }
      initGLContext();
      var xr = new WebXRManager2(_this, _gl);
      this.xr = xr;
      var shadowMap = new WebGLShadowMap2(_this, objects, capabilities.maxTextureSize);
      this.shadowMap = shadowMap;
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.loseContext();
      };
      this.forceContextRestore = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension)
          extension.restoreContext();
      };
      this.getPixelRatio = function() {
        return _pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value === void 0)
          return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
      };
      this.getSize = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
          target = new Vector22();
        }
        return target.set(_width, _height);
      };
      this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        _width = width;
        _height = height;
        _canvas3.width = Math.floor(width * _pixelRatio);
        _canvas3.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
          _canvas3.style.width = width + "px";
          _canvas3.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
      };
      this.getDrawingBufferSize = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
          target = new Vector22();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
      };
      this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas3.width = Math.floor(width * pixelRatio);
        _canvas3.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
      };
      this.getCurrentViewport = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
          target = new Vector42();
        }
        return target.copy(_currentViewport);
      };
      this.getViewport = function(target) {
        return target.copy(_viewport);
      };
      this.setViewport = function(x, y, width, height) {
        if (x.isVector4) {
          _viewport.set(x.x, x.y, x.z, x.w);
        } else {
          _viewport.set(x, y, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissor = function(target) {
        return target.copy(_scissor);
      };
      this.setScissor = function(x, y, width, height) {
        if (x.isVector4) {
          _scissor.set(x.x, x.y, x.z, x.w);
        } else {
          _scissor.set(x, y, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
      };
      this.getScissorTest = function() {
        return _scissorTest;
      };
      this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
      };
      this.setOpaqueSort = function(method) {
        _opaqueSort = method;
      };
      this.setTransparentSort = function(method) {
        _transparentSort = method;
      };
      this.getClearColor = function(target) {
        if (target === void 0) {
          console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
          target = new Color5();
        }
        return target.copy(background.getClearColor());
      };
      this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
      };
      this.getClearAlpha = function() {
        return background.getClearAlpha();
      };
      this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === void 0 || color)
          bits |= 16384;
        if (depth === void 0 || depth)
          bits |= 256;
        if (stencil === void 0 || stencil)
          bits |= 1024;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        this.clear(true, false, false);
      };
      this.clearDepth = function() {
        this.clear(false, true, false);
      };
      this.clearStencil = function() {
        this.clear(false, false, true);
      };
      this.dispose = function() {
        _canvas3.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas3.removeEventListener("webglcontextrestored", onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
      };
      function onContextLost(event) {
        event.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
      }
      function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        initGLContext();
      }
      function onMaterialDispose(event) {
        var material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
      }
      function releaseMaterialProgramReference(material) {
        var programInfo = properties.get(material).program;
        if (programInfo !== void 0) {
          programCache.releaseProgram(programInfo);
        }
      }
      function renderObjectImmediate(object, program) {
        object.render(function(object2) {
          _this.renderBufferImmediate(object2, program);
        });
      }
      this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position)
          buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
          buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
          buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color)
          buffers.color = _gl.createBuffer();
        var programAttributes = program.getAttributes();
        if (object.hasPositions) {
          _gl.bindBuffer(34962, buffers.position);
          _gl.bufferData(34962, object.positionArray, 35048);
          bindingStates.enableAttribute(programAttributes.position);
          _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(34962, buffers.normal);
          _gl.bufferData(34962, object.normalArray, 35048);
          bindingStates.enableAttribute(programAttributes.normal);
          _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
          _gl.bindBuffer(34962, buffers.uv);
          _gl.bufferData(34962, object.uvArray, 35048);
          bindingStates.enableAttribute(programAttributes.uv);
          _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
          _gl.bindBuffer(34962, buffers.color);
          _gl.bufferData(34962, object.colorArray, 35048);
          bindingStates.enableAttribute(programAttributes.color);
          _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
      };
      this.renderBufferDirect = function(camera2, scene2, geometry, material, object, group) {
        if (scene2 === null)
          scene2 = _emptyScene;
        var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        var program = setProgram(camera2, scene2, material, object);
        state.setMaterial(material, frontFaceCW);
        var index = geometry.index;
        var position = geometry.attributes.position;
        if (index === null) {
          if (position === void 0 || position.count === 0)
            return;
        } else if (index.count === 0) {
          return;
        }
        var rangeFactor = 1;
        if (material.wireframe === true) {
          index = geometries.getWireframeAttribute(geometry);
          rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) {
          morphtargets.update(object, geometry, material, program);
        }
        bindingStates.setup(object, material, program, geometry, index);
        var attribute;
        var renderer2 = bufferRenderer;
        if (index !== null) {
          attribute = attributes.get(index);
          renderer2 = indexedBufferRenderer;
          renderer2.setIndex(attribute);
        }
        var dataCount = index !== null ? index.count : position.count;
        var rangeStart = geometry.drawRange.start * rangeFactor;
        var rangeCount = geometry.drawRange.count * rangeFactor;
        var groupStart = group !== null ? group.start * rangeFactor : 0;
        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
        var drawStart = Math.max(rangeStart, groupStart);
        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0)
          return;
        if (object.isMesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
            renderer2.setMode(1);
          } else {
            renderer2.setMode(4);
          }
        } else if (object.isLine) {
          var lineWidth = material.linewidth;
          if (lineWidth === void 0)
            lineWidth = 1;
          state.setLineWidth(lineWidth * getTargetPixelRatio());
          if (object.isLineSegments) {
            renderer2.setMode(1);
          } else if (object.isLineLoop) {
            renderer2.setMode(2);
          } else {
            renderer2.setMode(3);
          }
        } else if (object.isPoints) {
          renderer2.setMode(0);
        } else if (object.isSprite) {
          renderer2.setMode(4);
        }
        if (object.isInstancedMesh) {
          renderer2.renderInstances(drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
          var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
          renderer2.renderInstances(drawStart, drawCount, instanceCount);
        } else {
          renderer2.render(drawStart, drawCount);
        }
      };
      this.compile = function(scene2, camera2) {
        currentRenderState = renderStates.get(scene2);
        currentRenderState.init();
        scene2.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera2.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
        currentRenderState.setupLights();
        var compiled = new WeakMap();
        scene2.traverse(function(object) {
          var material = object.material;
          if (material) {
            if (Array.isArray(material)) {
              for (var i2 = 0; i2 < material.length; i2++) {
                var material2 = material[i2];
                if (compiled.has(material2) === false) {
                  initMaterial(material2, scene2, object);
                  compiled.set(material2);
                }
              }
            } else if (compiled.has(material) === false) {
              initMaterial(material, scene2, object);
              compiled.set(material);
            }
          }
        });
      };
      var onAnimationFrameCallback = null;
      function onAnimationFrame(time) {
        if (xr.isPresenting)
          return;
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time);
      }
      var animation = new WebGLAnimation2();
      animation.setAnimationLoop(onAnimationFrame);
      if (typeof window !== "undefined")
        animation.setContext(window);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
      };
      this.render = function(scene2, camera2) {
        var renderTarget, forceClear;
        if (arguments[2] !== void 0) {
          console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
          renderTarget = arguments[2];
        }
        if (arguments[3] !== void 0) {
          console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
          forceClear = arguments[3];
        }
        if (camera2 !== void 0 && camera2.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (_isContextLost === true)
          return;
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        if (scene2.autoUpdate === true)
          scene2.updateMatrixWorld();
        if (camera2.parent === null)
          camera2.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
          camera2 = xr.getCamera(camera2);
        }
        if (scene2.isScene === true)
          scene2.onBeforeRender(_this, scene2, camera2, renderTarget || _currentRenderTarget);
        currentRenderState = renderStates.get(scene2, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix3.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix3);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
        currentRenderList = renderLists.get(scene2, renderListStack.length);
        currentRenderList.init();
        renderListStack.push(currentRenderList);
        projectObject(scene2, camera2, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) {
          currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        if (_clippingEnabled === true)
          clipping.beginShadows();
        var shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene2, camera2);
        currentRenderState.setupLights();
        currentRenderState.setupLightsView(camera2);
        if (_clippingEnabled === true)
          clipping.endShadows();
        if (this.info.autoReset === true)
          this.info.reset();
        if (renderTarget !== void 0) {
          this.setRenderTarget(renderTarget);
        }
        background.render(currentRenderList, scene2, camera2, forceClear);
        var opaqueObjects = currentRenderList.opaque;
        var transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0)
          renderObjects(opaqueObjects, scene2, camera2);
        if (transparentObjects.length > 0)
          renderObjects(transparentObjects, scene2, camera2);
        if (scene2.isScene === true)
          scene2.onAfterRender(_this, scene2, camera2);
        if (_currentRenderTarget !== null) {
          textures.updateRenderTargetMipmap(_currentRenderTarget);
          textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        renderStateStack.pop();
        if (renderStateStack.length > 0) {
          currentRenderState = renderStateStack[renderStateStack.length - 1];
        } else {
          currentRenderState = null;
        }
        renderListStack.pop();
        if (renderListStack.length > 0) {
          currentRenderList = renderListStack[renderListStack.length - 1];
        } else {
          currentRenderList = null;
        }
      };
      function projectObject(object, camera2, groupOrder, sortObjects) {
        if (object.visible === false)
          return;
        var visible = object.layers.test(camera2.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
          } else if (object.isLOD) {
            if (object.autoUpdate === true)
              object.update(camera2);
          } else if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (sortObjects) {
                _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
              }
              var geometry = objects.update(object);
              var material = object.material;
              if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
              }
            }
          } else if (object.isImmediateRenderObject) {
            if (sortObjects) {
              _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
            }
            currentRenderList.push(object, null, object.material, groupOrder, _vector32.z, null);
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (object.isSkinnedMesh) {
              if (object.skeleton.frame !== info.render.frame) {
                object.skeleton.update();
                object.skeleton.frame = info.render.frame;
              }
            }
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              if (sortObjects) {
                _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
              }
              var _geometry3 = objects.update(object);
              var _material = object.material;
              if (Array.isArray(_material)) {
                var groups = _geometry3.groups;
                for (var i2 = 0, l = groups.length; i2 < l; i2++) {
                  var group = groups[i2];
                  var groupMaterial = _material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    currentRenderList.push(object, _geometry3, groupMaterial, groupOrder, _vector32.z, group);
                  }
                }
              } else if (_material.visible) {
                currentRenderList.push(object, _geometry3, _material, groupOrder, _vector32.z, null);
              }
            }
          }
        }
        var children = object.children;
        for (var _i = 0, _l = children.length; _i < _l; _i++) {
          projectObject(children[_i], camera2, groupOrder, sortObjects);
        }
      }
      function renderObjects(renderList, scene2, camera2) {
        var overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
        for (var i2 = 0, l = renderList.length; i2 < l; i2++) {
          var renderItem = renderList[i2];
          var object = renderItem.object;
          var geometry = renderItem.geometry;
          var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
          var group = renderItem.group;
          if (camera2.isArrayCamera) {
            var cameras = camera2.cameras;
            for (var j = 0, jl = cameras.length; j < jl; j++) {
              var camera22 = cameras[j];
              if (object.layers.test(camera22.layers)) {
                state.viewport(_currentViewport.copy(camera22.viewport));
                currentRenderState.setupLightsView(camera22);
                renderObject(object, scene2, camera22, geometry, material, group);
              }
            }
          } else {
            renderObject(object, scene2, camera2, geometry, material, group);
          }
        }
      }
      function renderObject(object, scene2, camera2, geometry, material, group) {
        object.onBeforeRender(_this, scene2, camera2, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
          var program = setProgram(camera2, scene2, material, object);
          state.setMaterial(material);
          bindingStates.reset();
          renderObjectImmediate(object, program);
        } else {
          _this.renderBufferDirect(camera2, scene2, geometry, material, object, group);
        }
        object.onAfterRender(_this, scene2, camera2, geometry, material, group);
      }
      function initMaterial(material, scene2, object) {
        if (scene2.isScene !== true)
          scene2 = _emptyScene;
        var materialProperties = properties.get(material);
        var lights = currentRenderState.state.lights;
        var shadowsArray = currentRenderState.state.shadowsArray;
        var lightsStateVersion = lights.state.version;
        var parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object);
        var programCacheKey = programCache.getProgramCacheKey(parameters2);
        var program = materialProperties.program;
        var programChange = true;
        materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
        materialProperties.fog = scene2.fog;
        materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
        if (program === void 0) {
          material.addEventListener("dispose", onMaterialDispose);
        } else if (program.cacheKey !== programCacheKey) {
          releaseMaterialProgramReference(material);
        } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
          programChange = false;
        } else if (parameters2.shaderID !== void 0) {
          return;
        } else {
          programChange = false;
        }
        if (programChange) {
          parameters2.uniforms = programCache.getUniforms(material);
          material.onBeforeCompile(parameters2, _this);
          program = programCache.acquireProgram(parameters2, programCacheKey);
          materialProperties.program = program;
          materialProperties.uniforms = parameters2.uniforms;
          materialProperties.outputEncoding = parameters2.outputEncoding;
        }
        var uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
          materialProperties.numClippingPlanes = clipping.numPlanes;
          materialProperties.numIntersection = clipping.numIntersection;
          uniforms.clippingPlanes = clipping.uniform;
        }
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
          uniforms.ambientLightColor.value = lights.state.ambient;
          uniforms.lightProbe.value = lights.state.probe;
          uniforms.directionalLights.value = lights.state.directional;
          uniforms.directionalLightShadows.value = lights.state.directionalShadow;
          uniforms.spotLights.value = lights.state.spot;
          uniforms.spotLightShadows.value = lights.state.spotShadow;
          uniforms.rectAreaLights.value = lights.state.rectArea;
          uniforms.ltc_1.value = lights.state.rectAreaLTC1;
          uniforms.ltc_2.value = lights.state.rectAreaLTC2;
          uniforms.pointLights.value = lights.state.point;
          uniforms.pointLightShadows.value = lights.state.pointShadow;
          uniforms.hemisphereLights.value = lights.state.hemi;
          uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
          uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
          uniforms.spotShadowMap.value = lights.state.spotShadowMap;
          uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
          uniforms.pointShadowMap.value = lights.state.pointShadowMap;
          uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        var progUniforms = materialProperties.program.getUniforms();
        var uniformsList = WebGLUniforms2.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
      }
      function setProgram(camera2, scene2, material, object) {
        if (scene2.isScene !== true)
          scene2 = _emptyScene;
        textures.resetTextureUnits();
        var fog = scene2.fog;
        var environment = material.isMeshStandardMaterial ? scene2.environment : null;
        var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        var envMap = cubemaps.get(material.envMap || environment);
        var materialProperties = properties.get(material);
        var lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
          if (_localClippingEnabled === true || camera2 !== _currentCamera) {
            var useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
            clipping.setState(material, camera2, useCache);
          }
        }
        if (material.version === materialProperties.__version) {
          if (material.fog && materialProperties.fog !== fog) {
            initMaterial(material, scene2, object);
          } else if (materialProperties.environment !== environment) {
            initMaterial(material, scene2, object);
          } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            initMaterial(material, scene2, object);
          } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
            initMaterial(material, scene2, object);
          } else if (materialProperties.outputEncoding !== encoding) {
            initMaterial(material, scene2, object);
          } else if (materialProperties.envMap !== envMap) {
            initMaterial(material, scene2, object);
          }
        } else {
          initMaterial(material, scene2, object);
          materialProperties.__version = material.version;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera2) {
          p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
          if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
          }
          if (_currentCamera !== camera2) {
            _currentCamera = camera2;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
            var uCamPos = p_uniforms.map.cameraPosition;
            if (uCamPos !== void 0) {
              uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera2.matrixWorld));
            }
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
            p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
            p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
          }
        }
        if (material.skinning) {
          p_uniforms.setOptional(_gl, object, "bindMatrix");
          p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
          var skeleton = object.skeleton;
          if (skeleton) {
            var bones = skeleton.bones;
            if (capabilities.floatVertexTextures) {
              if (skeleton.boneTexture === null) {
                var size = Math.sqrt(bones.length * 4);
                size = MathUtils2.ceilPowerOfTwo(size);
                size = Math.max(size, 4);
                var boneMatrices = new Float32Array(size * size * 4);
                boneMatrices.set(skeleton.boneMatrices);
                var boneTexture = new DataTexture2(boneMatrices, size, size, RGBAFormat2, FloatType2);
                skeleton.boneMatrices = boneMatrices;
                skeleton.boneTexture = boneTexture;
                skeleton.boneTextureSize = size;
              }
              p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
              p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
            } else {
              p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
            }
          }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
          materialProperties.receiveShadow = object.receiveShadow;
          p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (refreshMaterial) {
          p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
          if (materialProperties.needsLights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
          }
          if (fog && material.fog) {
            materials.refreshFogUniforms(m_uniforms, fog);
          }
          materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
          WebGLUniforms2.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
          WebGLUniforms2.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) {
          p_uniforms.setValue(_gl, "center", object.center);
        }
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
      }
      function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
      }
      this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null)
          _gl.bindFramebuffer(36160, value);
        _framebuffer = value;
      };
      this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
      };
      this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
      };
      this.getRenderTarget = function() {
        return _currentRenderTarget;
      };
      this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
        if (activeCubeFace === void 0) {
          activeCubeFace = 0;
        }
        if (activeMipmapLevel === void 0) {
          activeMipmapLevel = 0;
        }
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        }
        var framebuffer = _framebuffer;
        var isCube = false;
        var isRenderTarget3D = false;
        if (renderTarget) {
          var texture = renderTarget.texture;
          if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
            isRenderTarget3D = true;
          }
          var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget) {
            framebuffer = __webglFramebuffer[activeCubeFace];
            isCube = true;
          } else if (renderTarget.isWebGLMultisampleRenderTarget) {
            framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
          } else {
            framebuffer = __webglFramebuffer;
          }
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
        } else {
          _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
          _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
          _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
          _gl.bindFramebuffer(36160, framebuffer);
          _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
          var textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
          var _textureProperties = properties.get(renderTarget.texture);
          var layer = activeCubeFace || 0;
          _gl.framebufferTextureLayer(36160, 36064, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          var restore = false;
          if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(36160, framebuffer);
            restore = true;
          }
          try {
            var texture = renderTarget.texture;
            var textureFormat = texture.format;
            var textureType = texture.type;
            if (textureFormat !== RGBAFormat2 && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            var halfFloatSupportedByExt = textureType === HalfFloatType2 && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
            if (textureType !== UnsignedByteType2 && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType2 && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            if (_gl.checkFramebufferStatus(36160) === 36053) {
              if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
              }
            } else {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            }
          } finally {
            if (restore) {
              _gl.bindFramebuffer(36160, _currentFramebuffer);
            }
          }
        }
      };
      this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === void 0) {
          level = 0;
        }
        var levelScale = Math.pow(2, -level);
        var width = Math.floor(texture.image.width * levelScale);
        var height = Math.floor(texture.image.height * levelScale);
        var glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
      };
      this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        if (level === void 0) {
          level = 0;
        }
        var width = srcTexture.image.width;
        var height = srcTexture.image.height;
        var glFormat = utils.convert(dstTexture.format);
        var glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) {
          _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        } else {
          if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
          } else {
            _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
          }
        }
        if (level === 0 && dstTexture.generateMipmaps)
          _gl.generateMipmap(3553);
        state.unbindTexture();
      };
      this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level) {
        if (level === void 0) {
          level = 0;
        }
        if (_this.isWebGL1Renderer) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          return;
        }
        var _srcTexture$image = srcTexture.image, width = _srcTexture$image.width, height = _srcTexture$image.height, data = _srcTexture$image.data;
        var glFormat = utils.convert(dstTexture.format);
        var glType = utils.convert(dstTexture.type);
        var glTarget;
        if (dstTexture.isDataTexture3D) {
          textures.setTexture3D(dstTexture, 0);
          glTarget = 32879;
        } else if (dstTexture.isDataTexture2DArray) {
          textures.setTexture2DArray(dstTexture, 0);
          glTarget = 35866;
        } else {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          return;
        }
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        var unpackRowLen = _gl.getParameter(3314);
        var unpackImageHeight = _gl.getParameter(32878);
        var unpackSkipPixels = _gl.getParameter(3316);
        var unpackSkipRows = _gl.getParameter(3315);
        var unpackSkipImages = _gl.getParameter(32877);
        _gl.pixelStorei(3314, width);
        _gl.pixelStorei(32878, height);
        _gl.pixelStorei(3316, sourceBox.min.x);
        _gl.pixelStorei(3315, sourceBox.min.y);
        _gl.pixelStorei(32877, sourceBox.min.z);
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
        _gl.pixelStorei(3314, unpackRowLen);
        _gl.pixelStorei(32878, unpackImageHeight);
        _gl.pixelStorei(3316, unpackSkipPixels);
        _gl.pixelStorei(3315, unpackSkipRows);
        _gl.pixelStorei(32877, unpackSkipImages);
        if (level === 0 && dstTexture.generateMipmaps)
          _gl.generateMipmap(glTarget);
        state.unbindTexture();
      };
      this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
      };
      this.resetState = function() {
        state.reset();
        bindingStates.reset();
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
    }
    var WebGL1Renderer2 = /* @__PURE__ */ function(_WebGLRenderer) {
      _inheritsLoose(WebGL1Renderer3, _WebGLRenderer);
      function WebGL1Renderer3() {
        return _WebGLRenderer.apply(this, arguments) || this;
      }
      return WebGL1Renderer3;
    }(WebGLRenderer3);
    WebGL1Renderer2.prototype.isWebGL1Renderer = true;
    var FogExp22 = /* @__PURE__ */ function() {
      function FogExp23(color, density) {
        this.name = "";
        this.color = new Color5(color);
        this.density = density !== void 0 ? density : 25e-5;
      }
      var _proto = FogExp23.prototype;
      _proto.clone = function clone() {
        return new FogExp23(this.color, this.density);
      };
      _proto.toJSON = function toJSON2() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      };
      return FogExp23;
    }();
    FogExp22.prototype.isFogExp2 = true;
    var Fog2 = /* @__PURE__ */ function() {
      function Fog3(color, near, far) {
        this.name = "";
        this.color = new Color5(color);
        this.near = near !== void 0 ? near : 1;
        this.far = far !== void 0 ? far : 1e3;
      }
      var _proto = Fog3.prototype;
      _proto.clone = function clone() {
        return new Fog3(this.color, this.near, this.far);
      };
      _proto.toJSON = function toJSON2() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      };
      return Fog3;
    }();
    Fog2.prototype.isFog = true;
    var Scene3 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(Scene4, _Object3D);
      function Scene4() {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "Scene";
        _this.background = null;
        _this.environment = null;
        _this.fog = null;
        _this.overrideMaterial = null;
        _this.autoUpdate = true;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: _assertThisInitialized(_this)
          }));
        }
        return _this;
      }
      var _proto = Scene4.prototype;
      _proto.copy = function copy(source, recursive) {
        _Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = _Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null)
          data.object.background = this.background.toJSON(meta);
        if (this.environment !== null)
          data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      };
      return Scene4;
    }(Object3D2);
    Scene3.prototype.isScene = true;
    function InterleavedBuffer3(array, stride) {
      this.array = array;
      this.stride = stride;
      this.count = array !== void 0 ? array.length / stride : 0;
      this.usage = StaticDrawUsage2;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
      this.uuid = MathUtils2.generateUUID();
    }
    Object.defineProperty(InterleavedBuffer3.prototype, "needsUpdate", {
      set: function set(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.assign(InterleavedBuffer3.prototype, {
      isInterleavedBuffer: true,
      onUploadCallback: function onUploadCallback() {
      },
      setUsage: function setUsage(value) {
        this.usage = value;
        return this;
      },
      copy: function copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      },
      copyAt: function copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i2 = 0, l = this.stride; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      },
      set: function set(value, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.array.set(value, offset);
        return this;
      },
      clone: function clone(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = MathUtils2.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        var ib = new InterleavedBuffer3(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      },
      onUpload: function onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      },
      toJSON: function toJSON2(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = MathUtils2.generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    });
    var _vector$62 = new Vector32();
    function InterleavedBufferAttribute3(interleavedBuffer, itemSize, offset, normalized) {
      this.name = "";
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.normalized = normalized === true;
    }
    Object.defineProperties(InterleavedBufferAttribute3.prototype, {
      count: {
        get: function get() {
          return this.data.count;
        }
      },
      array: {
        get: function get() {
          return this.data.array;
        }
      },
      needsUpdate: {
        set: function set(value) {
          this.data.needsUpdate = value;
        }
      }
    });
    Object.assign(InterleavedBufferAttribute3.prototype, {
      isInterleavedBufferAttribute: true,
      applyMatrix4: function applyMatrix4(m) {
        for (var i2 = 0, l = this.data.count; i2 < l; i2++) {
          _vector$62.x = this.getX(i2);
          _vector$62.y = this.getY(i2);
          _vector$62.z = this.getZ(i2);
          _vector$62.applyMatrix4(m);
          this.setXYZ(i2, _vector$62.x, _vector$62.y, _vector$62.z);
        }
        return this;
      },
      setX: function setX(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      },
      setY: function setY(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
      },
      setZ: function setZ(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      },
      setW: function setW(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      },
      getX: function getX(index) {
        return this.data.array[index * this.data.stride + this.offset];
      },
      getY: function getY(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
      },
      getZ: function getZ(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
      },
      getW: function getW(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
      },
      setXY: function setXY(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
      },
      setXYZ: function setXYZ(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
      },
      setXYZW: function setXYZW(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      },
      clone: function clone(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          var array = [];
          for (var i2 = 0; i2 < this.count; i2++) {
            var index = i2 * this.data.stride + this.offset;
            for (var j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return new BufferAttribute3(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute3(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      },
      toJSON: function toJSON2(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          var array = [];
          for (var i2 = 0; i2 < this.count; i2++) {
            var index = i2 * this.data.stride + this.offset;
            for (var j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    });
    var SpriteMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(SpriteMaterial3, _Material);
      function SpriteMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "SpriteMaterial";
        _this.color = new Color5(16777215);
        _this.map = null;
        _this.alphaMap = null;
        _this.rotation = 0;
        _this.sizeAttenuation = true;
        _this.transparent = true;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = SpriteMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
      };
      return SpriteMaterial3;
    }(Material2);
    SpriteMaterial2.prototype.isSpriteMaterial = true;
    var _geometry2;
    var _intersectPoint2 = /* @__PURE__ */ new Vector32();
    var _worldScale2 = /* @__PURE__ */ new Vector32();
    var _mvPosition2 = /* @__PURE__ */ new Vector32();
    var _alignedPosition2 = /* @__PURE__ */ new Vector22();
    var _rotatedPosition2 = /* @__PURE__ */ new Vector22();
    var _viewWorldMatrix2 = /* @__PURE__ */ new Matrix43();
    var _vA$12 = /* @__PURE__ */ new Vector32();
    var _vB$12 = /* @__PURE__ */ new Vector32();
    var _vC$12 = /* @__PURE__ */ new Vector32();
    var _uvA$12 = /* @__PURE__ */ new Vector22();
    var _uvB$12 = /* @__PURE__ */ new Vector22();
    var _uvC$12 = /* @__PURE__ */ new Vector22();
    var Sprite2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(Sprite3, _Object3D);
      function Sprite3(material) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "Sprite";
        if (_geometry2 === void 0) {
          _geometry2 = new BufferGeometry3();
          var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
          var interleavedBuffer = new InterleavedBuffer3(float32Array, 5);
          _geometry2.setIndex([0, 1, 2, 0, 2, 3]);
          _geometry2.setAttribute("position", new InterleavedBufferAttribute3(interleavedBuffer, 3, 0, false));
          _geometry2.setAttribute("uv", new InterleavedBufferAttribute3(interleavedBuffer, 2, 3, false));
        }
        _this.geometry = _geometry2;
        _this.material = material !== void 0 ? material : new SpriteMaterial2();
        _this.center = new Vector22(0.5, 0.5);
        return _this;
      }
      var _proto = Sprite3.prototype;
      _proto.raycast = function raycast(raycaster, intersects3) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale2.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix2.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition2.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale2.multiplyScalar(-_mvPosition2.z);
        }
        var rotation = this.material.rotation;
        var sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        var center = this.center;
        transformVertex2(_vA$12.set(-0.5, -0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
        transformVertex2(_vB$12.set(0.5, -0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
        transformVertex2(_vC$12.set(0.5, 0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
        _uvA$12.set(0, 0);
        _uvB$12.set(1, 0);
        _uvC$12.set(1, 1);
        var intersect = raycaster.ray.intersectTriangle(_vA$12, _vB$12, _vC$12, false, _intersectPoint2);
        if (intersect === null) {
          transformVertex2(_vB$12.set(-0.5, 0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
          _uvB$12.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA$12, _vC$12, _vB$12, false, _intersectPoint2);
          if (intersect === null) {
            return;
          }
        }
        var distance = raycaster.ray.origin.distanceTo(_intersectPoint2);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects3.push({
          distance,
          point: _intersectPoint2.clone(),
          uv: Triangle2.getUV(_intersectPoint2, _vA$12, _vB$12, _vC$12, _uvA$12, _uvB$12, _uvC$12, new Vector22()),
          face: null,
          object: this
        });
      };
      _proto.copy = function copy(source) {
        _Object3D.prototype.copy.call(this, source);
        if (source.center !== void 0)
          this.center.copy(source.center);
        this.material = source.material;
        return this;
      };
      return Sprite3;
    }(Object3D2);
    Sprite2.prototype.isSprite = true;
    function transformVertex2(vertexPosition, mvPosition, center, scale, sin, cos) {
      _alignedPosition2.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
      if (sin !== void 0) {
        _rotatedPosition2.x = cos * _alignedPosition2.x - sin * _alignedPosition2.y;
        _rotatedPosition2.y = sin * _alignedPosition2.x + cos * _alignedPosition2.y;
      } else {
        _rotatedPosition2.copy(_alignedPosition2);
      }
      vertexPosition.copy(mvPosition);
      vertexPosition.x += _rotatedPosition2.x;
      vertexPosition.y += _rotatedPosition2.y;
      vertexPosition.applyMatrix4(_viewWorldMatrix2);
    }
    var _v1$42 = /* @__PURE__ */ new Vector32();
    var _v2$22 = /* @__PURE__ */ new Vector32();
    var LOD2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(LOD3, _Object3D);
      function LOD3() {
        var _this;
        _this = _Object3D.call(this) || this;
        _this._currentLevel = 0;
        _this.type = "LOD";
        Object.defineProperties(_assertThisInitialized(_this), {
          levels: {
            enumerable: true,
            value: []
          },
          isLOD: {
            value: true
          }
        });
        _this.autoUpdate = true;
        return _this;
      }
      var _proto = LOD3.prototype;
      _proto.copy = function copy(source) {
        _Object3D.prototype.copy.call(this, source, false);
        var levels = source.levels;
        for (var i2 = 0, l = levels.length; i2 < l; i2++) {
          var level = levels[i2];
          this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      };
      _proto.addLevel = function addLevel(object, distance) {
        if (distance === void 0) {
          distance = 0;
        }
        distance = Math.abs(distance);
        var levels = this.levels;
        var l;
        for (l = 0; l < levels.length; l++) {
          if (distance < levels[l].distance) {
            break;
          }
        }
        levels.splice(l, 0, {
          distance,
          object
        });
        this.add(object);
        return this;
      };
      _proto.getCurrentLevel = function getCurrentLevel() {
        return this._currentLevel;
      };
      _proto.getObjectForDistance = function getObjectForDistance(distance) {
        var levels = this.levels;
        if (levels.length > 0) {
          var i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance < levels[i2].distance) {
              break;
            }
          }
          return levels[i2 - 1].object;
        }
        return null;
      };
      _proto.raycast = function raycast(raycaster, intersects3) {
        var levels = this.levels;
        if (levels.length > 0) {
          _v1$42.setFromMatrixPosition(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(_v1$42);
          this.getObjectForDistance(distance).raycast(raycaster, intersects3);
        }
      };
      _proto.update = function update(camera2) {
        var levels = this.levels;
        if (levels.length > 1) {
          _v1$42.setFromMatrixPosition(camera2.matrixWorld);
          _v2$22.setFromMatrixPosition(this.matrixWorld);
          var distance = _v1$42.distanceTo(_v2$22) / camera2.zoom;
          levels[0].object.visible = true;
          var i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance >= levels[i2].distance) {
              levels[i2 - 1].object.visible = false;
              levels[i2].object.visible = true;
            } else {
              break;
            }
          }
          this._currentLevel = i2 - 1;
          for (; i2 < l; i2++) {
            levels[i2].object.visible = false;
          }
        }
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = _Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false)
          data.object.autoUpdate = false;
        data.object.levels = [];
        var levels = this.levels;
        for (var i2 = 0, l = levels.length; i2 < l; i2++) {
          var level = levels[i2];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance
          });
        }
        return data;
      };
      return LOD3;
    }(Object3D2);
    var _basePosition2 = new Vector32();
    var _skinIndex2 = new Vector42();
    var _skinWeight2 = new Vector42();
    var _vector$72 = new Vector32();
    var _matrix$12 = new Matrix43();
    function SkinnedMesh2(geometry, material) {
      Mesh3.call(this, geometry, material);
      this.type = "SkinnedMesh";
      this.bindMode = "attached";
      this.bindMatrix = new Matrix43();
      this.bindMatrixInverse = new Matrix43();
    }
    SkinnedMesh2.prototype = Object.assign(Object.create(Mesh3.prototype), {
      constructor: SkinnedMesh2,
      isSkinnedMesh: true,
      copy: function copy(source) {
        Mesh3.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
      },
      bind: function bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
      },
      pose: function pose() {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function normalizeSkinWeights() {
        var vector = new Vector42();
        var skinWeight = this.geometry.attributes.skinWeight;
        for (var i2 = 0, l = skinWeight.count; i2 < l; i2++) {
          vector.x = skinWeight.getX(i2);
          vector.y = skinWeight.getY(i2);
          vector.z = skinWeight.getZ(i2);
          vector.w = skinWeight.getW(i2);
          var scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
      },
      updateMatrixWorld: function updateMatrixWorld(force) {
        Mesh3.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === "attached") {
          this.bindMatrixInverse.copy(this.matrixWorld).invert();
        } else if (this.bindMode === "detached") {
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      },
      boneTransform: function boneTransform(index, target) {
        var skeleton = this.skeleton;
        var geometry = this.geometry;
        _skinIndex2.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight2.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition2.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for (var i2 = 0; i2 < 4; i2++) {
          var weight = _skinWeight2.getComponent(i2);
          if (weight !== 0) {
            var boneIndex = _skinIndex2.getComponent(i2);
            _matrix$12.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            target.addScaledVector(_vector$72.copy(_basePosition2).applyMatrix4(_matrix$12), weight);
          }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
      }
    });
    function Bone2() {
      Object3D2.call(this);
      this.type = "Bone";
    }
    Bone2.prototype = Object.assign(Object.create(Object3D2.prototype), {
      constructor: Bone2,
      isBone: true
    });
    var _offsetMatrix2 = /* @__PURE__ */ new Matrix43();
    var _identityMatrix2 = /* @__PURE__ */ new Matrix43();
    var Skeleton2 = /* @__PURE__ */ function() {
      function Skeleton3(bones, boneInverses) {
        if (bones === void 0) {
          bones = [];
        }
        if (boneInverses === void 0) {
          boneInverses = [];
        }
        this.uuid = MathUtils2.generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
      }
      var _proto = Skeleton3.prototype;
      _proto.init = function init() {
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        if (boneInverses.length === 0) {
          this.calculateInverses();
        } else {
          if (bones.length !== boneInverses.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
            this.boneInverses = [];
            for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
              this.boneInverses.push(new Matrix43());
            }
          }
        }
      };
      _proto.calculateInverses = function calculateInverses() {
        this.boneInverses.length = 0;
        for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
          var inverse = new Matrix43();
          if (this.bones[i2]) {
            inverse.copy(this.bones[i2].matrixWorld).invert();
          }
          this.boneInverses.push(inverse);
        }
      };
      _proto.pose = function pose() {
        for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
          var bone = this.bones[i2];
          if (bone) {
            bone.matrixWorld.copy(this.boneInverses[i2]).invert();
          }
        }
        for (var _i = 0, _il = this.bones.length; _i < _il; _i++) {
          var _bone = this.bones[_i];
          if (_bone) {
            if (_bone.parent && _bone.parent.isBone) {
              _bone.matrix.copy(_bone.parent.matrixWorld).invert();
              _bone.matrix.multiply(_bone.matrixWorld);
            } else {
              _bone.matrix.copy(_bone.matrixWorld);
            }
            _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
          }
        }
      };
      _proto.update = function update() {
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        var boneMatrices = this.boneMatrices;
        var boneTexture = this.boneTexture;
        for (var i2 = 0, il = bones.length; i2 < il; i2++) {
          var matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix2;
          _offsetMatrix2.multiplyMatrices(matrix, boneInverses[i2]);
          _offsetMatrix2.toArray(boneMatrices, i2 * 16);
        }
        if (boneTexture !== null) {
          boneTexture.needsUpdate = true;
        }
      };
      _proto.clone = function clone() {
        return new Skeleton3(this.bones, this.boneInverses);
      };
      _proto.getBoneByName = function getBoneByName(name2) {
        for (var i2 = 0, il = this.bones.length; i2 < il; i2++) {
          var bone = this.bones[i2];
          if (bone.name === name2) {
            return bone;
          }
        }
        return void 0;
      };
      _proto.dispose = function dispose() {
        if (this.boneTexture !== null) {
          this.boneTexture.dispose();
          this.boneTexture = null;
        }
      };
      _proto.fromJSON = function fromJSON(json, bones) {
        this.uuid = json.uuid;
        for (var i2 = 0, l = json.bones.length; i2 < l; i2++) {
          var uuid = json.bones[i2];
          var bone = bones[uuid];
          if (bone === void 0) {
            console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
            bone = new Bone2();
          }
          this.bones.push(bone);
          this.boneInverses.push(new Matrix43().fromArray(json.boneInverses[i2]));
        }
        this.init();
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        data.uuid = this.uuid;
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        for (var i2 = 0, l = bones.length; i2 < l; i2++) {
          var bone = bones[i2];
          data.bones.push(bone.uuid);
          var boneInverse = boneInverses[i2];
          data.boneInverses.push(boneInverse.toArray());
        }
        return data;
      };
      return Skeleton3;
    }();
    var _instanceLocalMatrix2 = new Matrix43();
    var _instanceWorldMatrix2 = new Matrix43();
    var _instanceIntersects2 = [];
    var _mesh2 = new Mesh3();
    function InstancedMesh2(geometry, material, count) {
      Mesh3.call(this, geometry, material);
      this.instanceMatrix = new BufferAttribute3(new Float32Array(count * 16), 16);
      this.instanceColor = null;
      this.count = count;
      this.frustumCulled = false;
    }
    InstancedMesh2.prototype = Object.assign(Object.create(Mesh3.prototype), {
      constructor: InstancedMesh2,
      isInstancedMesh: true,
      copy: function copy(source) {
        Mesh3.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null)
          this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
      },
      getColorAt: function getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
      },
      getMatrixAt: function getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
      },
      raycast: function raycast(raycaster, intersects3) {
        var matrixWorld = this.matrixWorld;
        var raycastTimes = this.count;
        _mesh2.geometry = this.geometry;
        _mesh2.material = this.material;
        if (_mesh2.material === void 0)
          return;
        for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix2);
          _instanceWorldMatrix2.multiplyMatrices(matrixWorld, _instanceLocalMatrix2);
          _mesh2.matrixWorld = _instanceWorldMatrix2;
          _mesh2.raycast(raycaster, _instanceIntersects2);
          for (var i2 = 0, l = _instanceIntersects2.length; i2 < l; i2++) {
            var intersect = _instanceIntersects2[i2];
            intersect.instanceId = instanceId;
            intersect.object = this;
            intersects3.push(intersect);
          }
          _instanceIntersects2.length = 0;
        }
      },
      setColorAt: function setColorAt(index, color) {
        if (this.instanceColor === null) {
          this.instanceColor = new BufferAttribute3(new Float32Array(this.count * 3), 3);
        }
        color.toArray(this.instanceColor.array, index * 3);
      },
      setMatrixAt: function setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
      },
      updateMorphTargets: function updateMorphTargets() {
      },
      dispose: function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    });
    var LineBasicMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(LineBasicMaterial3, _Material);
      function LineBasicMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "LineBasicMaterial";
        _this.color = new Color5(16777215);
        _this.linewidth = 1;
        _this.linecap = "round";
        _this.linejoin = "round";
        _this.morphTargets = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = LineBasicMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.morphTargets = source.morphTargets;
        return this;
      };
      return LineBasicMaterial3;
    }(Material2);
    LineBasicMaterial2.prototype.isLineBasicMaterial = true;
    var _start2 = new Vector32();
    var _end2 = new Vector32();
    var _inverseMatrix$12 = new Matrix43();
    var _ray$12 = new Ray2();
    var _sphere$22 = new Sphere2();
    function Line2(geometry, material) {
      if (geometry === void 0) {
        geometry = new BufferGeometry3();
      }
      if (material === void 0) {
        material = new LineBasicMaterial2();
      }
      Object3D2.call(this);
      this.type = "Line";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    Line2.prototype = Object.assign(Object.create(Object3D2.prototype), {
      constructor: Line2,
      isLine: true,
      copy: function copy(source) {
        Object3D2.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      computeLineDistances: function computeLineDistances() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            var positionAttribute = geometry.attributes.position;
            var lineDistances = [0];
            for (var i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
              _start2.fromBufferAttribute(positionAttribute, i2 - 1);
              _end2.fromBufferAttribute(positionAttribute, i2);
              lineDistances[i2] = lineDistances[i2 - 1];
              lineDistances[i2] += _start2.distanceTo(_end2);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      },
      raycast: function raycast(raycaster, intersects3) {
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Line.threshold;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$22.copy(geometry.boundingSphere);
        _sphere$22.applyMatrix4(matrixWorld);
        _sphere$22.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$22) === false)
          return;
        _inverseMatrix$12.copy(matrixWorld).invert();
        _ray$12.copy(raycaster.ray).applyMatrix4(_inverseMatrix$12);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var vStart = new Vector32();
        var vEnd = new Vector32();
        var interSegment = new Vector32();
        var interRay = new Vector32();
        var step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positionAttribute = attributes.position;
          if (index !== null) {
            var indices = index.array;
            for (var i2 = 0, l = indices.length - 1; i2 < l; i2 += step) {
              var a = indices[i2];
              var b = indices[i2 + 1];
              vStart.fromBufferAttribute(positionAttribute, a);
              vEnd.fromBufferAttribute(positionAttribute, b);
              var distSq = _ray$12.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects3.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            for (var _i = 0, _l = positionAttribute.count - 1; _i < _l; _i += step) {
              vStart.fromBufferAttribute(positionAttribute, _i);
              vEnd.fromBufferAttribute(positionAttribute, _i + 1);
              var _distSq = _ray$12.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (_distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var _distance = raycaster.ray.origin.distanceTo(interRay);
              if (_distance < raycaster.near || _distance > raycaster.far)
                continue;
              intersects3.push({
                distance: _distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: _i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      },
      updateMorphTargets: function updateMorphTargets() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          var morphAttributes = geometry.morphAttributes;
          var keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            var morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                var name2 = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m;
              }
            }
          }
        } else {
          var morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    });
    var _start$12 = new Vector32();
    var _end$12 = new Vector32();
    function LineSegments2(geometry, material) {
      Line2.call(this, geometry, material);
      this.type = "LineSegments";
    }
    LineSegments2.prototype = Object.assign(Object.create(Line2.prototype), {
      constructor: LineSegments2,
      isLineSegments: true,
      computeLineDistances: function computeLineDistances() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            var positionAttribute = geometry.attributes.position;
            var lineDistances = [];
            for (var i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
              _start$12.fromBufferAttribute(positionAttribute, i2);
              _end$12.fromBufferAttribute(positionAttribute, i2 + 1);
              lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
              lineDistances[i2 + 1] = lineDistances[i2] + _start$12.distanceTo(_end$12);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      }
    });
    var LineLoop2 = /* @__PURE__ */ function(_Line) {
      _inheritsLoose(LineLoop3, _Line);
      function LineLoop3(geometry, material) {
        var _this;
        _this = _Line.call(this, geometry, material) || this;
        _this.type = "LineLoop";
        return _this;
      }
      return LineLoop3;
    }(Line2);
    LineLoop2.prototype.isLineLoop = true;
    var PointsMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(PointsMaterial3, _Material);
      function PointsMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "PointsMaterial";
        _this.color = new Color5(16777215);
        _this.map = null;
        _this.alphaMap = null;
        _this.size = 1;
        _this.sizeAttenuation = true;
        _this.morphTargets = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = PointsMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
      };
      return PointsMaterial3;
    }(Material2);
    PointsMaterial2.prototype.isPointsMaterial = true;
    var _inverseMatrix$22 = new Matrix43();
    var _ray$22 = new Ray2();
    var _sphere$32 = new Sphere2();
    var _position$12 = new Vector32();
    function Points2(geometry, material) {
      if (geometry === void 0) {
        geometry = new BufferGeometry3();
      }
      if (material === void 0) {
        material = new PointsMaterial2();
      }
      Object3D2.call(this);
      this.type = "Points";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    Points2.prototype = Object.assign(Object.create(Object3D2.prototype), {
      constructor: Points2,
      isPoints: true,
      copy: function copy(source) {
        Object3D2.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      },
      raycast: function raycast(raycaster, intersects3) {
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$32.copy(geometry.boundingSphere);
        _sphere$32.applyMatrix4(matrixWorld);
        _sphere$32.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$32) === false)
          return;
        _inverseMatrix$22.copy(matrixWorld).invert();
        _ray$22.copy(raycaster.ray).applyMatrix4(_inverseMatrix$22);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positionAttribute = attributes.position;
          if (index !== null) {
            var indices = index.array;
            for (var i2 = 0, il = indices.length; i2 < il; i2++) {
              var a = indices[i2];
              _position$12.fromBufferAttribute(positionAttribute, a);
              testPoint2(_position$12, a, localThresholdSq, matrixWorld, raycaster, intersects3, this);
            }
          } else {
            for (var _i = 0, l = positionAttribute.count; _i < l; _i++) {
              _position$12.fromBufferAttribute(positionAttribute, _i);
              testPoint2(_position$12, _i, localThresholdSq, matrixWorld, raycaster, intersects3, this);
            }
          }
        } else {
          console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      },
      updateMorphTargets: function updateMorphTargets() {
        var geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          var morphAttributes = geometry.morphAttributes;
          var keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            var morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                var name2 = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name2] = m;
              }
            }
          }
        } else {
          var morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    });
    function testPoint2(point, index, localThresholdSq, matrixWorld, raycaster, intersects3, object) {
      var rayPointDistanceSq = _ray$22.distanceSqToPoint(point);
      if (rayPointDistanceSq < localThresholdSq) {
        var intersectPoint = new Vector32();
        _ray$22.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects3.push({
          distance,
          distanceToRay: Math.sqrt(rayPointDistanceSq),
          point: intersectPoint,
          index,
          face: null,
          object
        });
      }
    }
    var VideoTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(VideoTexture3, _Texture);
      function VideoTexture3(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        var _this;
        _this = _Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
        _this.format = format !== void 0 ? format : RGBFormat2;
        _this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter2;
        _this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter2;
        _this.generateMipmaps = false;
        var scope = _assertThisInitialized(_this);
        function updateVideo() {
          scope.needsUpdate = true;
          video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) {
          video.requestVideoFrameCallback(updateVideo);
        }
        return _this;
      }
      var _proto = VideoTexture3.prototype;
      _proto.clone = function clone() {
        return new this.constructor(this.image).copy(this);
      };
      _proto.update = function update() {
        var video = this.image;
        var hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      };
      return VideoTexture3;
    }(Texture2);
    VideoTexture2.prototype.isVideoTexture = true;
    var CompressedTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(CompressedTexture3, _Texture);
      function CompressedTexture3(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        var _this;
        _this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
        _this.image = {
          width,
          height
        };
        _this.mipmaps = mipmaps;
        _this.flipY = false;
        _this.generateMipmaps = false;
        return _this;
      }
      return CompressedTexture3;
    }(Texture2);
    CompressedTexture2.prototype.isCompressedTexture = true;
    var CanvasTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(CanvasTexture3, _Texture);
      function CanvasTexture3(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        var _this;
        _this = _Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
        _this.needsUpdate = true;
        return _this;
      }
      return CanvasTexture3;
    }(Texture2);
    CanvasTexture2.prototype.isCanvasTexture = true;
    var DepthTexture2 = /* @__PURE__ */ function(_Texture) {
      _inheritsLoose(DepthTexture3, _Texture);
      function DepthTexture3(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        var _this;
        format = format !== void 0 ? format : DepthFormat2;
        if (format !== DepthFormat2 && format !== DepthStencilFormat2) {
          throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        }
        if (type === void 0 && format === DepthFormat2)
          type = UnsignedShortType2;
        if (type === void 0 && format === DepthStencilFormat2)
          type = UnsignedInt248Type2;
        _this = _Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
        _this.image = {
          width,
          height
        };
        _this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter2;
        _this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter2;
        _this.flipY = false;
        _this.generateMipmaps = false;
        return _this;
      }
      return DepthTexture3;
    }(Texture2);
    DepthTexture2.prototype.isDepthTexture = true;
    var CircleGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(CircleGeometry2, _BufferGeometry);
      function CircleGeometry2(radius, segments, thetaStart, thetaLength) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (segments === void 0) {
          segments = 8;
        }
        if (thetaStart === void 0) {
          thetaStart = 0;
        }
        if (thetaLength === void 0) {
          thetaLength = Math.PI * 2;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "CircleGeometry";
        _this.parameters = {
          radius,
          segments,
          thetaStart,
          thetaLength
        };
        segments = Math.max(3, segments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var vertex = new Vector32();
        var uv = new Vector22();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (var s = 0, i2 = 3; s <= segments; s++, i2 += 3) {
          var segment = thetaStart + s / segments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, 0, 1);
          uv.x = (vertices[i2] / radius + 1) / 2;
          uv.y = (vertices[i2 + 1] / radius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        for (var _i = 1; _i <= segments; _i++) {
          indices.push(_i, _i + 1, 0);
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        return _this;
      }
      return CircleGeometry2;
    }(BufferGeometry3);
    var CylinderGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(CylinderGeometry2, _BufferGeometry);
      function CylinderGeometry2(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        var _this;
        if (radiusTop === void 0) {
          radiusTop = 1;
        }
        if (radiusBottom === void 0) {
          radiusBottom = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (radialSegments === void 0) {
          radialSegments = 8;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (openEnded === void 0) {
          openEnded = false;
        }
        if (thetaStart === void 0) {
          thetaStart = 0;
        }
        if (thetaLength === void 0) {
          thetaLength = Math.PI * 2;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "CylinderGeometry";
        _this.parameters = {
          radiusTop,
          radiusBottom,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
        var scope = _assertThisInitialized(_this);
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
        generateTorso();
        if (openEnded === false) {
          if (radiusTop > 0)
            generateCap(true);
          if (radiusBottom > 0)
            generateCap(false);
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        function generateTorso() {
          var normal = new Vector32();
          var vertex = new Vector32();
          var groupCount = 0;
          var slope = (radiusBottom - radiusTop) / height;
          for (var y = 0; y <= heightSegments; y++) {
            var indexRow = [];
            var v = y / heightSegments;
            var radius = v * (radiusBottom - radiusTop) + radiusTop;
            for (var x = 0; x <= radialSegments; x++) {
              var u = x / radialSegments;
              var theta = u * thetaLength + thetaStart;
              var sinTheta = Math.sin(theta);
              var cosTheta = Math.cos(theta);
              vertex.x = radius * sinTheta;
              vertex.y = -v * height + halfHeight;
              vertex.z = radius * cosTheta;
              vertices.push(vertex.x, vertex.y, vertex.z);
              normal.set(sinTheta, slope, cosTheta).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u, 1 - v);
              indexRow.push(index++);
            }
            indexArray.push(indexRow);
          }
          for (var _x3 = 0; _x3 < radialSegments; _x3++) {
            for (var _y3 = 0; _y3 < heightSegments; _y3++) {
              var a = indexArray[_y3][_x3];
              var b = indexArray[_y3 + 1][_x3];
              var c = indexArray[_y3 + 1][_x3 + 1];
              var d = indexArray[_y3][_x3 + 1];
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, 0);
          groupStart += groupCount;
        }
        function generateCap(top) {
          var centerIndexStart = index;
          var uv = new Vector22();
          var vertex = new Vector32();
          var groupCount = 0;
          var radius = top === true ? radiusTop : radiusBottom;
          var sign3 = top === true ? 1 : -1;
          for (var x = 1; x <= radialSegments; x++) {
            vertices.push(0, halfHeight * sign3, 0);
            normals.push(0, sign3, 0);
            uvs.push(0.5, 0.5);
            index++;
          }
          var centerIndexEnd = index;
          for (var _x22 = 0; _x22 <= radialSegments; _x22++) {
            var u = _x22 / radialSegments;
            var theta = u * thetaLength + thetaStart;
            var cosTheta = Math.cos(theta);
            var sinTheta = Math.sin(theta);
            vertex.x = radius * sinTheta;
            vertex.y = halfHeight * sign3;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, sign3, 0);
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign3 + 0.5;
            uvs.push(uv.x, uv.y);
            index++;
          }
          for (var _x3 = 0; _x3 < radialSegments; _x3++) {
            var c = centerIndexStart + _x3;
            var i2 = centerIndexEnd + _x3;
            if (top === true) {
              indices.push(i2, i2 + 1, c);
            } else {
              indices.push(i2 + 1, i2, c);
            }
            groupCount += 3;
          }
          scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
          groupStart += groupCount;
        }
        return _this;
      }
      return CylinderGeometry2;
    }(BufferGeometry3);
    var ConeGeometry = /* @__PURE__ */ function(_CylinderGeometry) {
      _inheritsLoose(ConeGeometry2, _CylinderGeometry);
      function ConeGeometry2(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (height === void 0) {
          height = 1;
        }
        if (radialSegments === void 0) {
          radialSegments = 8;
        }
        if (heightSegments === void 0) {
          heightSegments = 1;
        }
        if (openEnded === void 0) {
          openEnded = false;
        }
        if (thetaStart === void 0) {
          thetaStart = 0;
        }
        if (thetaLength === void 0) {
          thetaLength = Math.PI * 2;
        }
        _this = _CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
        _this.type = "ConeGeometry";
        _this.parameters = {
          radius,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
        return _this;
      }
      return ConeGeometry2;
    }(CylinderGeometry);
    var PolyhedronGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(PolyhedronGeometry2, _BufferGeometry);
      function PolyhedronGeometry2(vertices, indices, radius, detail) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (detail === void 0) {
          detail = 0;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "PolyhedronGeometry";
        _this.parameters = {
          vertices,
          indices,
          radius,
          detail
        };
        var vertexBuffer = [];
        var uvBuffer = [];
        subdivide(detail);
        applyRadius(radius);
        generateUVs();
        _this.setAttribute("position", new Float32BufferAttribute2(vertexBuffer, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(vertexBuffer.slice(), 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvBuffer, 2));
        if (detail === 0) {
          _this.computeVertexNormals();
        } else {
          _this.normalizeNormals();
        }
        function subdivide(detail2) {
          var a = new Vector32();
          var b = new Vector32();
          var c = new Vector32();
          for (var i2 = 0; i2 < indices.length; i2 += 3) {
            getVertexByIndex(indices[i2 + 0], a);
            getVertexByIndex(indices[i2 + 1], b);
            getVertexByIndex(indices[i2 + 2], c);
            subdivideFace(a, b, c, detail2);
          }
        }
        function subdivideFace(a, b, c, detail2) {
          var cols = detail2 + 1;
          var v = [];
          for (var i2 = 0; i2 <= cols; i2++) {
            v[i2] = [];
            var aj = a.clone().lerp(c, i2 / cols);
            var bj = b.clone().lerp(c, i2 / cols);
            var rows = cols - i2;
            for (var j = 0; j <= rows; j++) {
              if (j === 0 && i2 === cols) {
                v[i2][j] = aj;
              } else {
                v[i2][j] = aj.clone().lerp(bj, j / rows);
              }
            }
          }
          for (var _i = 0; _i < cols; _i++) {
            for (var _j = 0; _j < 2 * (cols - _i) - 1; _j++) {
              var k = Math.floor(_j / 2);
              if (_j % 2 === 0) {
                pushVertex(v[_i][k + 1]);
                pushVertex(v[_i + 1][k]);
                pushVertex(v[_i][k]);
              } else {
                pushVertex(v[_i][k + 1]);
                pushVertex(v[_i + 1][k + 1]);
                pushVertex(v[_i + 1][k]);
              }
            }
          }
        }
        function applyRadius(radius2) {
          var vertex = new Vector32();
          for (var i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex.x = vertexBuffer[i2 + 0];
            vertex.y = vertexBuffer[i2 + 1];
            vertex.z = vertexBuffer[i2 + 2];
            vertex.normalize().multiplyScalar(radius2);
            vertexBuffer[i2 + 0] = vertex.x;
            vertexBuffer[i2 + 1] = vertex.y;
            vertexBuffer[i2 + 2] = vertex.z;
          }
        }
        function generateUVs() {
          var vertex = new Vector32();
          for (var i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex.x = vertexBuffer[i2 + 0];
            vertex.y = vertexBuffer[i2 + 1];
            vertex.z = vertexBuffer[i2 + 2];
            var u = azimuth(vertex) / 2 / Math.PI + 0.5;
            var v = inclination(vertex) / Math.PI + 0.5;
            uvBuffer.push(u, 1 - v);
          }
          correctUVs();
          correctSeam();
        }
        function correctSeam() {
          for (var i2 = 0; i2 < uvBuffer.length; i2 += 6) {
            var x0 = uvBuffer[i2 + 0];
            var x1 = uvBuffer[i2 + 2];
            var x2 = uvBuffer[i2 + 4];
            var max = Math.max(x0, x1, x2);
            var min = Math.min(x0, x1, x2);
            if (max > 0.9 && min < 0.1) {
              if (x0 < 0.2)
                uvBuffer[i2 + 0] += 1;
              if (x1 < 0.2)
                uvBuffer[i2 + 2] += 1;
              if (x2 < 0.2)
                uvBuffer[i2 + 4] += 1;
            }
          }
        }
        function pushVertex(vertex) {
          vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
          var stride = index * 3;
          vertex.x = vertices[stride + 0];
          vertex.y = vertices[stride + 1];
          vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
          var a = new Vector32();
          var b = new Vector32();
          var c = new Vector32();
          var centroid = new Vector32();
          var uvA = new Vector22();
          var uvB = new Vector22();
          var uvC = new Vector22();
          for (var i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
            a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
            b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
            c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            centroid.copy(a).add(b).add(c).divideScalar(3);
            var azi = azimuth(centroid);
            correctUV(uvA, j + 0, a, azi);
            correctUV(uvB, j + 2, b, azi);
            correctUV(uvC, j + 4, c, azi);
          }
        }
        function correctUV(uv, stride, vector, azimuth2) {
          if (azimuth2 < 0 && uv.x === 1) {
            uvBuffer[stride] = uv.x - 1;
          }
          if (vector.x === 0 && vector.z === 0) {
            uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
          }
        }
        function azimuth(vector) {
          return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
          return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
        return _this;
      }
      return PolyhedronGeometry2;
    }(BufferGeometry3);
    var DodecahedronGeometry = /* @__PURE__ */ function(_PolyhedronGeometry) {
      _inheritsLoose(DodecahedronGeometry2, _PolyhedronGeometry);
      function DodecahedronGeometry2(radius, detail) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (detail === void 0) {
          detail = 0;
        }
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -r,
          -t,
          0,
          -r,
          t,
          0,
          r,
          -t,
          0,
          r,
          t,
          -r,
          -t,
          0,
          -r,
          t,
          0,
          r,
          -t,
          0,
          r,
          t,
          0,
          -t,
          0,
          -r,
          t,
          0,
          -r,
          -t,
          0,
          r,
          t,
          0,
          r
        ];
        var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
        _this.type = "DodecahedronGeometry";
        _this.parameters = {
          radius,
          detail
        };
        return _this;
      }
      return DodecahedronGeometry2;
    }(PolyhedronGeometry);
    var _v0$22 = new Vector32();
    var _v1$52 = new Vector32();
    var _normal$12 = new Vector32();
    var _triangle2 = new Triangle2();
    var EdgesGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(EdgesGeometry2, _BufferGeometry);
      function EdgesGeometry2(geometry, thresholdAngle) {
        var _this;
        _this = _BufferGeometry.call(this) || this;
        _this.type = "EdgesGeometry";
        _this.parameters = {
          thresholdAngle
        };
        thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
        if (geometry.isGeometry === true) {
          console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return _assertThisInitialized(_this);
        }
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var thresholdDot = Math.cos(MathUtils2.DEG2RAD * thresholdAngle);
        var indexAttr = geometry.getIndex();
        var positionAttr = geometry.getAttribute("position");
        var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        var indexArr = [0, 0, 0];
        var vertKeys = ["a", "b", "c"];
        var hashes = new Array(3);
        var edgeData = {};
        var vertices = [];
        for (var i2 = 0; i2 < indexCount; i2 += 3) {
          if (indexAttr) {
            indexArr[0] = indexAttr.getX(i2);
            indexArr[1] = indexAttr.getX(i2 + 1);
            indexArr[2] = indexAttr.getX(i2 + 2);
          } else {
            indexArr[0] = i2;
            indexArr[1] = i2 + 1;
            indexArr[2] = i2 + 2;
          }
          var a = _triangle2.a, b = _triangle2.b, c = _triangle2.c;
          a.fromBufferAttribute(positionAttr, indexArr[0]);
          b.fromBufferAttribute(positionAttr, indexArr[1]);
          c.fromBufferAttribute(positionAttr, indexArr[2]);
          _triangle2.getNormal(_normal$12);
          hashes[0] = Math.round(a.x * precision) + "," + Math.round(a.y * precision) + "," + Math.round(a.z * precision);
          hashes[1] = Math.round(b.x * precision) + "," + Math.round(b.y * precision) + "," + Math.round(b.z * precision);
          hashes[2] = Math.round(c.x * precision) + "," + Math.round(c.y * precision) + "," + Math.round(c.z * precision);
          if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
            continue;
          }
          for (var j = 0; j < 3; j++) {
            var jNext = (j + 1) % 3;
            var vecHash0 = hashes[j];
            var vecHash1 = hashes[jNext];
            var v0 = _triangle2[vertKeys[j]];
            var v1 = _triangle2[vertKeys[jNext]];
            var hash = vecHash0 + "_" + vecHash1;
            var reverseHash = vecHash1 + "_" + vecHash0;
            if (reverseHash in edgeData && edgeData[reverseHash]) {
              if (_normal$12.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
              }
              edgeData[reverseHash] = null;
            } else if (!(hash in edgeData)) {
              edgeData[hash] = {
                index0: indexArr[j],
                index1: indexArr[jNext],
                normal: _normal$12.clone()
              };
            }
          }
        }
        for (var key in edgeData) {
          if (edgeData[key]) {
            var _edgeData$key = edgeData[key], index0 = _edgeData$key.index0, index1 = _edgeData$key.index1;
            _v0$22.fromBufferAttribute(positionAttr, index0);
            _v1$52.fromBufferAttribute(positionAttr, index1);
            vertices.push(_v0$22.x, _v0$22.y, _v0$22.z);
            vertices.push(_v1$52.x, _v1$52.y, _v1$52.z);
          }
        }
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        return _this;
      }
      return EdgesGeometry2;
    }(BufferGeometry3);
    var Earcut2 = {
      triangulate: function triangulate(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var outerNode = linkedList2(data, 0, outerLen, dim, true);
        var triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i2 = dim; i2 < outerLen; i2 += dim) {
            x = data[i2];
            y = data[i2 + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked2(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
    };
    function linkedList2(data, start, end, dim, clockwise) {
      var i2, last;
      if (clockwise === signedArea2(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim) {
          last = insertNode2(i2, data[i2], data[i2 + 1], last);
        }
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim) {
          last = insertNode2(i2, data[i2], data[i2 + 1], last);
        }
      }
      if (last && equals2(last, last.next)) {
        removeNode2(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints2(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals2(p, p.next) || area2(p.prev, p, p.next) === 0)) {
          removeNode2(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve2(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode2(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
            earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut2(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar2(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area2(a, b, c) >= 0)
        return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed2(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area2(a, b, c) >= 0)
        return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder2(minTX, minTY, minX, minY, invSize), maxZ = zOrder2(maxTX, maxTY, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections2(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals2(a, b) && intersects2(a, p, p.next, b) && locallyInside2(a, b) && locallyInside2(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode2(p);
          removeNode2(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints2(p);
    }
    function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal2(a, b)) {
            var c = splitPolygon2(a, b);
            a = filterPoints2(a, a.next);
            c = filterPoints2(c, c.next);
            earcutLinked2(a, triangles, dim, minX, minY, invSize);
            earcutLinked2(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles2(data, holeIndices, outerNode, dim) {
      var queue = [];
      var i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList2(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost2(list));
      }
      queue.sort(compareX2);
      for (i2 = 0; i2 < queue.length; i2++) {
        eliminateHole2(queue[i2], outerNode);
        outerNode = filterPoints2(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX2(a, b) {
      return a.x - b.x;
    }
    function eliminateHole2(hole, outerNode) {
      outerNode = findHoleBridge2(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon2(outerNode, hole);
        filterPoints2(outerNode, outerNode.next);
        filterPoints2(b, b.next);
      }
    }
    function findHoleBridge2(hole, outerNode) {
      var p = outerNode;
      var hx = hole.x;
      var hy = hole.y;
      var qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y)
                return p;
              if (hy === p.next.y)
                return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      if (hx === qx)
        return m;
      var stop = m, mx = m.x, my = m.y;
      var tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside2(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector2(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector2(m, p) {
      return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
    }
    function indexCurve2(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === null)
          p.z = zOrder2(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked2(p);
    }
    function sortLinked2(list) {
      var i2, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder2(x, y, minX, minY, invSize) {
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost2(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle2(ax, ay, bx, by, cx, cy, px3, py3) {
      return (cx - px3) * (ay - py3) - (ax - px3) * (cy - py3) >= 0 && (ax - px3) * (by - py3) - (bx - px3) * (ay - py3) >= 0 && (bx - px3) * (cy - py3) - (cx - px3) * (by - py3) >= 0;
    }
    function isValidDiagonal2(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon2(a, b) && (locallyInside2(a, b) && locallyInside2(b, a) && middleInside2(a, b) && (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || equals2(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
    }
    function area2(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals2(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects2(p1, q1, p2, q2) {
      var o1 = sign2(area2(p1, q1, p2));
      var o2 = sign2(area2(p1, q1, q2));
      var o3 = sign2(area2(p2, q2, p1));
      var o4 = sign2(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment2(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment2(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment2(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment2(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment2(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon2(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside2(a, b) {
      return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
    }
    function middleInside2(a, b) {
      var p = a, inside = false;
      var px3 = (a.x + b.x) / 2, py3 = (a.y + b.y) / 2;
      do {
        if (p.y > py3 !== p.next.y > py3 && p.next.y !== p.y && px3 < (p.next.x - p.x) * (py3 - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon2(a, b) {
      var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode2(i2, x, y, last) {
      var p = new Node2(i2, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode2(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node2(i2, x, y) {
      this.i = i2;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    function signedArea2(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j = end - dim; i2 < end; i2 += dim) {
        sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
        j = i2;
      }
      return sum;
    }
    var ShapeUtils2 = {
      area: function area3(contour) {
        var n = contour.length;
        var a = 0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      },
      isClockWise: function isClockWise(pts) {
        return ShapeUtils2.area(pts) < 0;
      },
      triangulateShape: function triangulateShape(contour, holes) {
        var vertices = [];
        var holeIndices = [];
        var faces = [];
        removeDupEndPts2(contour);
        addContour2(vertices, contour);
        var holeIndex = contour.length;
        holes.forEach(removeDupEndPts2);
        for (var i2 = 0; i2 < holes.length; i2++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i2].length;
          addContour2(vertices, holes[i2]);
        }
        var triangles = Earcut2.triangulate(vertices, holeIndices);
        for (var _i = 0; _i < triangles.length; _i += 3) {
          faces.push(triangles.slice(_i, _i + 3));
        }
        return faces;
      }
    };
    function removeDupEndPts2(points) {
      var l = points.length;
      if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
      }
    }
    function addContour2(vertices, contour) {
      for (var i2 = 0; i2 < contour.length; i2++) {
        vertices.push(contour[i2].x);
        vertices.push(contour[i2].y);
      }
    }
    var ExtrudeGeometry2 = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(ExtrudeGeometry3, _BufferGeometry);
      function ExtrudeGeometry3(shapes, options) {
        var _this;
        _this = _BufferGeometry.call(this) || this;
        _this.type = "ExtrudeGeometry";
        _this.parameters = {
          shapes,
          options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        var scope = _assertThisInitialized(_this);
        var verticesArray = [];
        var uvArray = [];
        for (var i2 = 0, l = shapes.length; i2 < l; i2++) {
          var shape = shapes[i2];
          addShape(shape);
        }
        _this.setAttribute("position", new Float32BufferAttribute2(verticesArray, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvArray, 2));
        _this.computeVertexNormals();
        function addShape(shape2) {
          var placeholder = [];
          var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
          var steps = options.steps !== void 0 ? options.steps : 1;
          var depth = options.depth !== void 0 ? options.depth : 100;
          var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
          var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
          var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
          var bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
          var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
          var extrudePath = options.extrudePath;
          var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator2;
          if (options.amount !== void 0) {
            console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
            depth = options.amount;
          }
          var extrudePts, extrudeByPath = false;
          var splineTube, binormal, normal, position2;
          if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector32();
            normal = new Vector32();
            position2 = new Vector32();
          }
          if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
            bevelOffset = 0;
          }
          var shapePoints = shape2.extractPoints(curveSegments);
          var vertices = shapePoints.shape;
          var holes = shapePoints.holes;
          var reverse = !ShapeUtils2.isClockWise(vertices);
          if (reverse) {
            vertices = vertices.reverse();
            for (var h = 0, hl = holes.length; h < hl; h++) {
              var ahole = holes[h];
              if (ShapeUtils2.isClockWise(ahole)) {
                holes[h] = ahole.reverse();
              }
            }
          }
          var faces = ShapeUtils2.triangulateShape(vertices, holes);
          var contour = vertices;
          for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
            var _ahole = holes[_h];
            vertices = vertices.concat(_ahole);
          }
          function scalePt2(pt, vec, size) {
            if (!vec)
              console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
          }
          var vlen = vertices.length, flen = faces.length;
          function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by;
            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
              var v_prev_len = Math.sqrt(v_prev_lensq);
              var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
              var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
              var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
              var ptNextShift_x = inNext.x - v_next_y / v_next_len;
              var ptNextShift_y = inNext.y + v_next_x / v_next_len;
              var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
              v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
              v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
              var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
              if (v_trans_lensq <= 2) {
                return new Vector22(v_trans_x, v_trans_y);
              } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
              }
            } else {
              var direction_eq = false;
              if (v_prev_x > Number.EPSILON) {
                if (v_next_x > Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (v_prev_x < -Number.EPSILON) {
                  if (v_next_x < -Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                    direction_eq = true;
                  }
                }
              }
              if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
              } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
              }
            }
            return new Vector22(v_trans_x / shrink_by, v_trans_y / shrink_by);
          }
          var contourMovements = [];
          for (var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);
          }
          var holesMovements = [];
          var oneHoleMovements, verticesMovements = contourMovements.concat();
          for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
            var _ahole2 = holes[_h2];
            oneHoleMovements = [];
            for (var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++) {
              if (_j === _il)
                _j = 0;
              if (_k === _il)
                _k = 0;
              oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
          }
          for (var b = 0; b < bevelSegments; b++) {
            var t = b / bevelSegments;
            var z = bevelThickness * Math.cos(t * Math.PI / 2);
            var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
            for (var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++) {
              var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);
              v(vert.x, vert.y, -z);
            }
            for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
              var _ahole3 = holes[_h3];
              oneHoleMovements = holesMovements[_h3];
              for (var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++) {
                var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);
                v(_vert.x, _vert.y, -z);
              }
            }
          }
          var bs = bevelSize + bevelOffset;
          for (var _i5 = 0; _i5 < vlen; _i5++) {
            var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];
            if (!extrudeByPath) {
              v(_vert2.x, _vert2.y, 0);
            } else {
              normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
              binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
              position2.copy(extrudePts[0]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
          for (var s = 1; s <= steps; s++) {
            for (var _i6 = 0; _i6 < vlen; _i6++) {
              var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];
              if (!extrudeByPath) {
                v(_vert3.x, _vert3.y, depth / steps * s);
              } else {
                normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
          }
          for (var _b = bevelSegments - 1; _b >= 0; _b--) {
            var _t = _b / bevelSegments;
            var _z3 = bevelThickness * Math.cos(_t * Math.PI / 2);
            var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset;
            for (var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++) {
              var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);
              v(_vert4.x, _vert4.y, depth + _z3);
            }
            for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
              var _ahole4 = holes[_h4];
              oneHoleMovements = holesMovements[_h4];
              for (var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++) {
                var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);
                if (!extrudeByPath) {
                  v(_vert5.x, _vert5.y, depth + _z3);
                } else {
                  v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z3);
                }
              }
            }
          }
          buildLidFaces();
          buildSideFaces();
          function buildLidFaces() {
            var start = verticesArray.length / 3;
            if (bevelEnabled) {
              var layer = 0;
              var offset = vlen * layer;
              for (var _i9 = 0; _i9 < flen; _i9++) {
                var face = faces[_i9];
                f3(face[2] + offset, face[1] + offset, face[0] + offset);
              }
              layer = steps + bevelSegments * 2;
              offset = vlen * layer;
              for (var _i10 = 0; _i10 < flen; _i10++) {
                var _face = faces[_i10];
                f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
              }
            } else {
              for (var _i11 = 0; _i11 < flen; _i11++) {
                var _face2 = faces[_i11];
                f3(_face2[2], _face2[1], _face2[0]);
              }
              for (var _i12 = 0; _i12 < flen; _i12++) {
                var _face3 = faces[_i12];
                f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
              }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
          }
          function buildSideFaces() {
            var start = verticesArray.length / 3;
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
              var _ahole5 = holes[_h5];
              sidewalls(_ahole5, layeroffset);
              layeroffset += _ahole5.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
          }
          function sidewalls(contour2, layeroffset) {
            var i3 = contour2.length;
            while (--i3 >= 0) {
              var _j2 = i3;
              var _k2 = i3 - 1;
              if (_k2 < 0)
                _k2 = contour2.length - 1;
              for (var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++) {
                var slen1 = vlen * _s;
                var slen2 = vlen * (_s + 1);
                var a = layeroffset + _j2 + slen1, _b2 = layeroffset + _k2 + slen1, c = layeroffset + _k2 + slen2, d = layeroffset + _j2 + slen2;
                f4(a, _b2, c, d);
              }
            }
          }
          function v(x, y, z2) {
            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z2);
          }
          function f3(a, b2, c) {
            addVertex(a);
            addVertex(b2);
            addVertex(c);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
          }
          function f4(a, b2, c, d) {
            addVertex(a);
            addVertex(b2);
            addVertex(d);
            addVertex(b2);
            addVertex(c);
            addVertex(d);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
          }
          function addVertex(index) {
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
          }
          function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
          }
        }
        return _this;
      }
      var _proto = ExtrudeGeometry3.prototype;
      _proto.toJSON = function toJSON2() {
        var data = BufferGeometry3.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
        return _toJSON(shapes, options, data);
      };
      return ExtrudeGeometry3;
    }(BufferGeometry3);
    var WorldUVGenerator2 = {
      generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        return [new Vector22(a_x, a_y), new Vector22(b_x, b_y), new Vector22(c_x, c_y)];
      },
      generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var a_z = vertices[indexA * 3 + 2];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var b_z = vertices[indexB * 3 + 2];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        var c_z = vertices[indexC * 3 + 2];
        var d_x = vertices[indexD * 3];
        var d_y = vertices[indexD * 3 + 1];
        var d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) {
          return [new Vector22(a_x, 1 - a_z), new Vector22(b_x, 1 - b_z), new Vector22(c_x, 1 - c_z), new Vector22(d_x, 1 - d_z)];
        } else {
          return [new Vector22(a_y, 1 - a_z), new Vector22(b_y, 1 - b_z), new Vector22(c_y, 1 - c_z), new Vector22(d_y, 1 - d_z)];
        }
      }
    };
    function _toJSON(shapes, options, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (var i2 = 0, l = shapes.length; i2 < l; i2++) {
          var shape = shapes[i2];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      if (options.extrudePath !== void 0)
        data.options.extrudePath = options.extrudePath.toJSON();
      return data;
    }
    var IcosahedronGeometry = /* @__PURE__ */ function(_PolyhedronGeometry) {
      _inheritsLoose(IcosahedronGeometry2, _PolyhedronGeometry);
      function IcosahedronGeometry2(radius, detail) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (detail === void 0) {
          detail = 0;
        }
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
        var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
        _this.type = "IcosahedronGeometry";
        _this.parameters = {
          radius,
          detail
        };
        return _this;
      }
      return IcosahedronGeometry2;
    }(PolyhedronGeometry);
    var LatheGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(LatheGeometry2, _BufferGeometry);
      function LatheGeometry2(points, segments, phiStart, phiLength) {
        var _this;
        if (segments === void 0) {
          segments = 12;
        }
        if (phiStart === void 0) {
          phiStart = 0;
        }
        if (phiLength === void 0) {
          phiLength = Math.PI * 2;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "LatheGeometry";
        _this.parameters = {
          points,
          segments,
          phiStart,
          phiLength
        };
        segments = Math.floor(segments);
        phiLength = MathUtils2.clamp(phiLength, 0, Math.PI * 2);
        var indices = [];
        var vertices = [];
        var uvs = [];
        var inverseSegments = 1 / segments;
        var vertex = new Vector32();
        var uv = new Vector22();
        for (var i2 = 0; i2 <= segments; i2++) {
          var phi = phiStart + i2 * inverseSegments * phiLength;
          var sin = Math.sin(phi);
          var cos = Math.cos(phi);
          for (var j = 0; j <= points.length - 1; j++) {
            vertex.x = points[j].x * sin;
            vertex.y = points[j].y;
            vertex.z = points[j].x * cos;
            vertices.push(vertex.x, vertex.y, vertex.z);
            uv.x = i2 / segments;
            uv.y = j / (points.length - 1);
            uvs.push(uv.x, uv.y);
          }
        }
        for (var _i = 0; _i < segments; _i++) {
          for (var _j = 0; _j < points.length - 1; _j++) {
            var base = _j + _i * points.length;
            var a = base;
            var b = base + points.length;
            var c = base + points.length + 1;
            var d = base + 1;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        _this.computeVertexNormals();
        if (phiLength === Math.PI * 2) {
          var normals = _this.attributes.normal.array;
          var n1 = new Vector32();
          var n2 = new Vector32();
          var n = new Vector32();
          var _base = segments * points.length * 3;
          for (var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3) {
            n1.x = normals[_j2 + 0];
            n1.y = normals[_j2 + 1];
            n1.z = normals[_j2 + 2];
            n2.x = normals[_base + _j2 + 0];
            n2.y = normals[_base + _j2 + 1];
            n2.z = normals[_base + _j2 + 2];
            n.addVectors(n1, n2).normalize();
            normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;
            normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;
            normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;
          }
        }
        return _this;
      }
      return LatheGeometry2;
    }(BufferGeometry3);
    var OctahedronGeometry = /* @__PURE__ */ function(_PolyhedronGeometry) {
      _inheritsLoose(OctahedronGeometry2, _PolyhedronGeometry);
      function OctahedronGeometry2(radius, detail) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (detail === void 0) {
          detail = 0;
        }
        var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
        var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
        _this.type = "OctahedronGeometry";
        _this.parameters = {
          radius,
          detail
        };
        return _this;
      }
      return OctahedronGeometry2;
    }(PolyhedronGeometry);
    function ParametricGeometry2(func, slices, stacks) {
      BufferGeometry3.call(this);
      this.type = "ParametricGeometry";
      this.parameters = {
        func,
        slices,
        stacks
      };
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var EPS = 1e-5;
      var normal = new Vector32();
      var p0 = new Vector32(), p1 = new Vector32();
      var pu = new Vector32(), pv = new Vector32();
      if (func.length < 3) {
        console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
      }
      var sliceCount = slices + 1;
      for (var i2 = 0; i2 <= stacks; i2++) {
        var v = i2 / stacks;
        for (var j = 0; j <= slices; j++) {
          var u = j / slices;
          func(u, v, p0);
          vertices.push(p0.x, p0.y, p0.z);
          if (u - EPS >= 0) {
            func(u - EPS, v, p1);
            pu.subVectors(p0, p1);
          } else {
            func(u + EPS, v, p1);
            pu.subVectors(p1, p0);
          }
          if (v - EPS >= 0) {
            func(u, v - EPS, p1);
            pv.subVectors(p0, p1);
          } else {
            func(u, v + EPS, p1);
            pv.subVectors(p1, p0);
          }
          normal.crossVectors(pu, pv).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, v);
        }
      }
      for (var _i = 0; _i < stacks; _i++) {
        for (var _j = 0; _j < slices; _j++) {
          var a = _i * sliceCount + _j;
          var b = _i * sliceCount + _j + 1;
          var c = (_i + 1) * sliceCount + _j + 1;
          var d = (_i + 1) * sliceCount + _j;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    }
    ParametricGeometry2.prototype = Object.create(BufferGeometry3.prototype);
    ParametricGeometry2.prototype.constructor = ParametricGeometry2;
    var RingGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(RingGeometry2, _BufferGeometry);
      function RingGeometry2(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        var _this;
        if (innerRadius === void 0) {
          innerRadius = 0.5;
        }
        if (outerRadius === void 0) {
          outerRadius = 1;
        }
        if (thetaSegments === void 0) {
          thetaSegments = 8;
        }
        if (phiSegments === void 0) {
          phiSegments = 1;
        }
        if (thetaStart === void 0) {
          thetaStart = 0;
        }
        if (thetaLength === void 0) {
          thetaLength = Math.PI * 2;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "RingGeometry";
        _this.parameters = {
          innerRadius,
          outerRadius,
          thetaSegments,
          phiSegments,
          thetaStart,
          thetaLength
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var radius = innerRadius;
        var radiusStep = (outerRadius - innerRadius) / phiSegments;
        var vertex = new Vector32();
        var uv = new Vector22();
        for (var j = 0; j <= phiSegments; j++) {
          for (var i2 = 0; i2 <= thetaSegments; i2++) {
            var segment = thetaStart + i2 / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, 0, 1);
            uv.x = (vertex.x / outerRadius + 1) / 2;
            uv.y = (vertex.y / outerRadius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          radius += radiusStep;
        }
        for (var _j = 0; _j < phiSegments; _j++) {
          var thetaSegmentLevel = _j * (thetaSegments + 1);
          for (var _i = 0; _i < thetaSegments; _i++) {
            var _segment = _i + thetaSegmentLevel;
            var a = _segment;
            var b = _segment + thetaSegments + 1;
            var c = _segment + thetaSegments + 2;
            var d = _segment + 1;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        return _this;
      }
      return RingGeometry2;
    }(BufferGeometry3);
    var ShapeGeometry2 = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(ShapeGeometry3, _BufferGeometry);
      function ShapeGeometry3(shapes, curveSegments) {
        var _this;
        if (curveSegments === void 0) {
          curveSegments = 12;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "ShapeGeometry";
        _this.parameters = {
          shapes,
          curveSegments
        };
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var groupStart = 0;
        var groupCount = 0;
        if (Array.isArray(shapes) === false) {
          addShape(shapes);
        } else {
          for (var i2 = 0; i2 < shapes.length; i2++) {
            addShape(shapes[i2]);
            _this.addGroup(groupStart, groupCount, i2);
            groupStart += groupCount;
            groupCount = 0;
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        function addShape(shape) {
          var indexOffset = vertices.length / 3;
          var points = shape.extractPoints(curveSegments);
          var shapeVertices = points.shape;
          var shapeHoles = points.holes;
          if (ShapeUtils2.isClockWise(shapeVertices) === false) {
            shapeVertices = shapeVertices.reverse();
          }
          for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {
            var shapeHole = shapeHoles[_i];
            if (ShapeUtils2.isClockWise(shapeHole) === true) {
              shapeHoles[_i] = shapeHole.reverse();
            }
          }
          var faces = ShapeUtils2.triangulateShape(shapeVertices, shapeHoles);
          for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {
            var _shapeHole = shapeHoles[_i2];
            shapeVertices = shapeVertices.concat(_shapeHole);
          }
          for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {
            var vertex = shapeVertices[_i3];
            vertices.push(vertex.x, vertex.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex.x, vertex.y);
          }
          for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {
            var face = faces[_i4];
            var a = face[0] + indexOffset;
            var b = face[1] + indexOffset;
            var c = face[2] + indexOffset;
            indices.push(a, b, c);
            groupCount += 3;
          }
        }
        return _this;
      }
      var _proto = ShapeGeometry3.prototype;
      _proto.toJSON = function toJSON2() {
        var data = BufferGeometry3.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        return _toJSON$1(shapes, data);
      };
      return ShapeGeometry3;
    }(BufferGeometry3);
    function _toJSON$1(shapes, data) {
      data.shapes = [];
      if (Array.isArray(shapes)) {
        for (var i2 = 0, l = shapes.length; i2 < l; i2++) {
          var shape = shapes[i2];
          data.shapes.push(shape.uuid);
        }
      } else {
        data.shapes.push(shapes.uuid);
      }
      return data;
    }
    var SphereGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(SphereGeometry2, _BufferGeometry);
      function SphereGeometry2(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (widthSegments === void 0) {
          widthSegments = 8;
        }
        if (heightSegments === void 0) {
          heightSegments = 6;
        }
        if (phiStart === void 0) {
          phiStart = 0;
        }
        if (phiLength === void 0) {
          phiLength = Math.PI * 2;
        }
        if (thetaStart === void 0) {
          thetaStart = 0;
        }
        if (thetaLength === void 0) {
          thetaLength = Math.PI;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "SphereGeometry";
        _this.parameters = {
          radius,
          widthSegments,
          heightSegments,
          phiStart,
          phiLength,
          thetaStart,
          thetaLength
        };
        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));
        var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        var index = 0;
        var grid = [];
        var vertex = new Vector32();
        var normal = new Vector32();
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (var iy = 0; iy <= heightSegments; iy++) {
          var verticesRow = [];
          var v = iy / heightSegments;
          var uOffset = 0;
          if (iy == 0 && thetaStart == 0) {
            uOffset = 0.5 / widthSegments;
          } else if (iy == heightSegments && thetaEnd == Math.PI) {
            uOffset = -0.5 / widthSegments;
          }
          for (var ix = 0; ix <= widthSegments; ix++) {
            var u = ix / widthSegments;
            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normal.copy(vertex).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(u + uOffset, 1 - v);
            verticesRow.push(index++);
          }
          grid.push(verticesRow);
        }
        for (var _iy = 0; _iy < heightSegments; _iy++) {
          for (var _ix = 0; _ix < widthSegments; _ix++) {
            var a = grid[_iy][_ix + 1];
            var b = grid[_iy][_ix];
            var c = grid[_iy + 1][_ix];
            var d = grid[_iy + 1][_ix + 1];
            if (_iy !== 0 || thetaStart > 0)
              indices.push(a, b, d);
            if (_iy !== heightSegments - 1 || thetaEnd < Math.PI)
              indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        return _this;
      }
      return SphereGeometry2;
    }(BufferGeometry3);
    var TetrahedronGeometry = /* @__PURE__ */ function(_PolyhedronGeometry) {
      _inheritsLoose(TetrahedronGeometry2, _PolyhedronGeometry);
      function TetrahedronGeometry2(radius, detail) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (detail === void 0) {
          detail = 0;
        }
        var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
        var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
        _this.type = "TetrahedronGeometry";
        _this.parameters = {
          radius,
          detail
        };
        return _this;
      }
      return TetrahedronGeometry2;
    }(PolyhedronGeometry);
    var TextGeometry = /* @__PURE__ */ function(_ExtrudeGeometry) {
      _inheritsLoose(TextGeometry2, _ExtrudeGeometry);
      function TextGeometry2(text, parameters) {
        var _this;
        if (parameters === void 0) {
          parameters = {};
        }
        var font = parameters.font;
        if (!(font && font.isFont)) {
          console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
          return new BufferGeometry3() || _assertThisInitialized(_this);
        }
        var shapes = font.generateShapes(text, parameters.size);
        parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
        if (parameters.bevelThickness === void 0)
          parameters.bevelThickness = 10;
        if (parameters.bevelSize === void 0)
          parameters.bevelSize = 8;
        if (parameters.bevelEnabled === void 0)
          parameters.bevelEnabled = false;
        _this = _ExtrudeGeometry.call(this, shapes, parameters) || this;
        _this.type = "TextGeometry";
        return _this;
      }
      return TextGeometry2;
    }(ExtrudeGeometry2);
    var TorusGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(TorusGeometry2, _BufferGeometry);
      function TorusGeometry2(radius, tube, radialSegments, tubularSegments, arc) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (tube === void 0) {
          tube = 0.4;
        }
        if (radialSegments === void 0) {
          radialSegments = 8;
        }
        if (tubularSegments === void 0) {
          tubularSegments = 6;
        }
        if (arc === void 0) {
          arc = Math.PI * 2;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "TorusGeometry";
        _this.parameters = {
          radius,
          tube,
          radialSegments,
          tubularSegments,
          arc
        };
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var center = new Vector32();
        var vertex = new Vector32();
        var normal = new Vector32();
        for (var j = 0; j <= radialSegments; j++) {
          for (var i2 = 0; i2 <= tubularSegments; i2++) {
            var u = i2 / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex.z = tube * Math.sin(v);
            vertices.push(vertex.x, vertex.y, vertex.z);
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            normal.subVectors(vertex, center).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j / radialSegments);
          }
        }
        for (var _j = 1; _j <= radialSegments; _j++) {
          for (var _i = 1; _i <= tubularSegments; _i++) {
            var a = (tubularSegments + 1) * _j + _i - 1;
            var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
            var c = (tubularSegments + 1) * (_j - 1) + _i;
            var d = (tubularSegments + 1) * _j + _i;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        return _this;
      }
      return TorusGeometry2;
    }(BufferGeometry3);
    var TorusKnotGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(TorusKnotGeometry2, _BufferGeometry);
      function TorusKnotGeometry2(radius, tube, tubularSegments, radialSegments, p, q) {
        var _this;
        if (radius === void 0) {
          radius = 1;
        }
        if (tube === void 0) {
          tube = 0.4;
        }
        if (tubularSegments === void 0) {
          tubularSegments = 64;
        }
        if (radialSegments === void 0) {
          radialSegments = 8;
        }
        if (p === void 0) {
          p = 2;
        }
        if (q === void 0) {
          q = 3;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "TorusKnotGeometry";
        _this.parameters = {
          radius,
          tube,
          tubularSegments,
          radialSegments,
          p,
          q
        };
        tubularSegments = Math.floor(tubularSegments);
        radialSegments = Math.floor(radialSegments);
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var vertex = new Vector32();
        var normal = new Vector32();
        var P1 = new Vector32();
        var P2 = new Vector32();
        var B = new Vector32();
        var T = new Vector32();
        var N = new Vector32();
        for (var i2 = 0; i2 <= tubularSegments; ++i2) {
          var u = i2 / tubularSegments * p * Math.PI * 2;
          calculatePositionOnCurve(u, p, q, radius, P1);
          calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
          T.subVectors(P2, P1);
          N.addVectors(P2, P1);
          B.crossVectors(T, N);
          N.crossVectors(B, T);
          B.normalize();
          N.normalize();
          for (var j = 0; j <= radialSegments; ++j) {
            var v = j / radialSegments * Math.PI * 2;
            var cx = -tube * Math.cos(v);
            var cy = tube * Math.sin(v);
            vertex.x = P1.x + (cx * N.x + cy * B.x);
            vertex.y = P1.y + (cx * N.y + cy * B.y);
            vertex.z = P1.z + (cx * N.z + cy * B.z);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normal.subVectors(vertex, P1).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j / radialSegments);
          }
        }
        for (var _j = 1; _j <= tubularSegments; _j++) {
          for (var _i = 1; _i <= radialSegments; _i++) {
            var a = (radialSegments + 1) * (_j - 1) + (_i - 1);
            var b = (radialSegments + 1) * _j + (_i - 1);
            var c = (radialSegments + 1) * _j + _i;
            var d = (radialSegments + 1) * (_j - 1) + _i;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        function calculatePositionOnCurve(u2, p2, q2, radius2, position) {
          var cu = Math.cos(u2);
          var su = Math.sin(u2);
          var quOverP = q2 / p2 * u2;
          var cs = Math.cos(quOverP);
          position.x = radius2 * (2 + cs) * 0.5 * cu;
          position.y = radius2 * (2 + cs) * su * 0.5;
          position.z = radius2 * Math.sin(quOverP) * 0.5;
        }
        return _this;
      }
      return TorusKnotGeometry2;
    }(BufferGeometry3);
    var TubeGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(TubeGeometry2, _BufferGeometry);
      function TubeGeometry2(path, tubularSegments, radius, radialSegments, closed) {
        var _this;
        if (tubularSegments === void 0) {
          tubularSegments = 64;
        }
        if (radius === void 0) {
          radius = 1;
        }
        if (radialSegments === void 0) {
          radialSegments = 8;
        }
        if (closed === void 0) {
          closed = false;
        }
        _this = _BufferGeometry.call(this) || this;
        _this.type = "TubeGeometry";
        _this.parameters = {
          path,
          tubularSegments,
          radius,
          radialSegments,
          closed
        };
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        _this.tangents = frames.tangents;
        _this.normals = frames.normals;
        _this.binormals = frames.binormals;
        var vertex = new Vector32();
        var normal = new Vector32();
        var uv = new Vector22();
        var P = new Vector32();
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        generateBufferData();
        _this.setIndex(indices);
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        _this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        _this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        function generateBufferData() {
          for (var i2 = 0; i2 < tubularSegments; i2++) {
            generateSegment(i2);
          }
          generateSegment(closed === false ? tubularSegments : 0);
          generateUVs();
          generateIndices();
        }
        function generateSegment(i2) {
          P = path.getPointAt(i2 / tubularSegments, P);
          var N = frames.normals[i2];
          var B = frames.binormals[i2];
          for (var j = 0; j <= radialSegments; j++) {
            var v = j / radialSegments * Math.PI * 2;
            var sin = Math.sin(v);
            var cos = -Math.cos(v);
            normal.x = cos * N.x + sin * B.x;
            normal.y = cos * N.y + sin * B.y;
            normal.z = cos * N.z + sin * B.z;
            normal.normalize();
            normals.push(normal.x, normal.y, normal.z);
            vertex.x = P.x + radius * normal.x;
            vertex.y = P.y + radius * normal.y;
            vertex.z = P.z + radius * normal.z;
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
        function generateIndices() {
          for (var j = 1; j <= tubularSegments; j++) {
            for (var i2 = 1; i2 <= radialSegments; i2++) {
              var a = (radialSegments + 1) * (j - 1) + (i2 - 1);
              var b = (radialSegments + 1) * j + (i2 - 1);
              var c = (radialSegments + 1) * j + i2;
              var d = (radialSegments + 1) * (j - 1) + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
        }
        function generateUVs() {
          for (var i2 = 0; i2 <= tubularSegments; i2++) {
            for (var j = 0; j <= radialSegments; j++) {
              uv.x = i2 / tubularSegments;
              uv.y = j / radialSegments;
              uvs.push(uv.x, uv.y);
            }
          }
        }
        return _this;
      }
      var _proto = TubeGeometry2.prototype;
      _proto.toJSON = function toJSON2() {
        var data = BufferGeometry3.prototype.toJSON.call(this);
        data.path = this.parameters.path.toJSON();
        return data;
      };
      return TubeGeometry2;
    }(BufferGeometry3);
    var WireframeGeometry = /* @__PURE__ */ function(_BufferGeometry) {
      _inheritsLoose(WireframeGeometry2, _BufferGeometry);
      function WireframeGeometry2(geometry) {
        var _this;
        _this = _BufferGeometry.call(this) || this;
        _this.type = "WireframeGeometry";
        if (geometry.isGeometry === true) {
          console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return _assertThisInitialized(_this);
        }
        var vertices = [];
        var edge = [0, 0], edges = {};
        var vertex = new Vector32();
        if (geometry.index !== null) {
          var position = geometry.attributes.position;
          var indices = geometry.index;
          var groups = geometry.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.count,
              materialIndex: 0
            }];
          }
          for (var o = 0, ol = groups.length; o < ol; ++o) {
            var group = groups[o];
            var start = group.start;
            var count = group.count;
            for (var i2 = start, l = start + count; i2 < l; i2 += 3) {
              for (var j = 0; j < 3; j++) {
                var edge1 = indices.getX(i2 + j);
                var edge2 = indices.getX(i2 + (j + 1) % 3);
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);
                var key = edge[0] + "," + edge[1];
                if (edges[key] === void 0) {
                  edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                  };
                }
              }
            }
          }
          for (var _key in edges) {
            var e = edges[_key];
            vertex.fromBufferAttribute(position, e.index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex.fromBufferAttribute(position, e.index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        } else {
          var _position3 = geometry.attributes.position;
          for (var _i = 0, _l = _position3.count / 3; _i < _l; _i++) {
            for (var _j = 0; _j < 3; _j++) {
              var index1 = 3 * _i + _j;
              vertex.fromBufferAttribute(_position3, index1);
              vertices.push(vertex.x, vertex.y, vertex.z);
              var index2 = 3 * _i + (_j + 1) % 3;
              vertex.fromBufferAttribute(_position3, index2);
              vertices.push(vertex.x, vertex.y, vertex.z);
            }
          }
        }
        _this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        return _this;
      }
      return WireframeGeometry2;
    }(BufferGeometry3);
    var Geometries = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BoxGeometry: BoxGeometry2,
      BoxBufferGeometry: BoxGeometry2,
      CircleGeometry,
      CircleBufferGeometry: CircleGeometry,
      ConeGeometry,
      ConeBufferGeometry: ConeGeometry,
      CylinderGeometry,
      CylinderBufferGeometry: CylinderGeometry,
      DodecahedronGeometry,
      DodecahedronBufferGeometry: DodecahedronGeometry,
      EdgesGeometry,
      ExtrudeGeometry: ExtrudeGeometry2,
      ExtrudeBufferGeometry: ExtrudeGeometry2,
      IcosahedronGeometry,
      IcosahedronBufferGeometry: IcosahedronGeometry,
      LatheGeometry,
      LatheBufferGeometry: LatheGeometry,
      OctahedronGeometry,
      OctahedronBufferGeometry: OctahedronGeometry,
      ParametricGeometry: ParametricGeometry2,
      ParametricBufferGeometry: ParametricGeometry2,
      PlaneGeometry: PlaneGeometry2,
      PlaneBufferGeometry: PlaneGeometry2,
      PolyhedronGeometry,
      PolyhedronBufferGeometry: PolyhedronGeometry,
      RingGeometry,
      RingBufferGeometry: RingGeometry,
      ShapeGeometry: ShapeGeometry2,
      ShapeBufferGeometry: ShapeGeometry2,
      SphereGeometry,
      SphereBufferGeometry: SphereGeometry,
      TetrahedronGeometry,
      TetrahedronBufferGeometry: TetrahedronGeometry,
      TextGeometry,
      TextBufferGeometry: TextGeometry,
      TorusGeometry,
      TorusBufferGeometry: TorusGeometry,
      TorusKnotGeometry,
      TorusKnotBufferGeometry: TorusKnotGeometry,
      TubeGeometry,
      TubeBufferGeometry: TubeGeometry,
      WireframeGeometry
    });
    var ShadowMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(ShadowMaterial3, _Material);
      function ShadowMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "ShadowMaterial";
        _this.color = new Color5(0);
        _this.transparent = true;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = ShadowMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        return this;
      };
      return ShadowMaterial3;
    }(Material2);
    ShadowMaterial2.prototype.isShadowMaterial = true;
    var RawShaderMaterial2 = /* @__PURE__ */ function(_ShaderMaterial) {
      _inheritsLoose(RawShaderMaterial3, _ShaderMaterial);
      function RawShaderMaterial3(parameters) {
        var _this;
        _this = _ShaderMaterial.call(this, parameters) || this;
        _this.type = "RawShaderMaterial";
        return _this;
      }
      return RawShaderMaterial3;
    }(ShaderMaterial2);
    RawShaderMaterial2.prototype.isRawShaderMaterial = true;
    function MeshStandardMaterial2(parameters) {
      Material2.call(this);
      this.defines = {
        STANDARD: ""
      };
      this.type = "MeshStandardMaterial";
      this.color = new Color5(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color5(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap2;
      this.normalScale = new Vector22(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapIntensity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.flatShading = false;
      this.vertexTangents = false;
      this.setValues(parameters);
    }
    MeshStandardMaterial2.prototype = Object.create(Material2.prototype);
    MeshStandardMaterial2.prototype.constructor = MeshStandardMaterial2;
    MeshStandardMaterial2.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial2.prototype.copy = function(source) {
      Material2.prototype.copy.call(this, source);
      this.defines = {
        STANDARD: ""
      };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.flatShading = source.flatShading;
      this.vertexTangents = source.vertexTangents;
      return this;
    };
    function MeshPhysicalMaterial2(parameters) {
      MeshStandardMaterial2.call(this);
      this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      };
      this.type = "MeshPhysicalMaterial";
      this.clearcoat = 0;
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector22(1, 1);
      this.clearcoatNormalMap = null;
      this.reflectivity = 0.5;
      Object.defineProperty(this, "ior", {
        get: function get() {
          return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
        },
        set: function set(ior) {
          this.reflectivity = MathUtils2.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
        }
      });
      this.sheen = null;
      this.transmission = 0;
      this.transmissionMap = null;
      this.setValues(parameters);
    }
    MeshPhysicalMaterial2.prototype = Object.create(MeshStandardMaterial2.prototype);
    MeshPhysicalMaterial2.prototype.constructor = MeshPhysicalMaterial2;
    MeshPhysicalMaterial2.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial2.prototype.copy = function(source) {
      MeshStandardMaterial2.prototype.copy.call(this, source);
      this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.reflectivity = source.reflectivity;
      if (source.sheen) {
        this.sheen = (this.sheen || new Color5()).copy(source.sheen);
      } else {
        this.sheen = null;
      }
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      return this;
    };
    var MeshPhongMaterial3 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshPhongMaterial4, _Material);
      function MeshPhongMaterial4(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshPhongMaterial";
        _this.color = new Color5(16777215);
        _this.specular = new Color5(1118481);
        _this.shininess = 30;
        _this.map = null;
        _this.lightMap = null;
        _this.lightMapIntensity = 1;
        _this.aoMap = null;
        _this.aoMapIntensity = 1;
        _this.emissive = new Color5(0);
        _this.emissiveIntensity = 1;
        _this.emissiveMap = null;
        _this.bumpMap = null;
        _this.bumpScale = 1;
        _this.normalMap = null;
        _this.normalMapType = TangentSpaceNormalMap2;
        _this.normalScale = new Vector22(1, 1);
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.specularMap = null;
        _this.alphaMap = null;
        _this.envMap = null;
        _this.combine = MultiplyOperation2;
        _this.reflectivity = 1;
        _this.refractionRatio = 0.98;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.wireframeLinecap = "round";
        _this.wireframeLinejoin = "round";
        _this.skinning = false;
        _this.morphTargets = false;
        _this.morphNormals = false;
        _this.flatShading = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshPhongMaterial4.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
      };
      return MeshPhongMaterial4;
    }(Material2);
    MeshPhongMaterial3.prototype.isMeshPhongMaterial = true;
    var MeshToonMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshToonMaterial3, _Material);
      function MeshToonMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.defines = {
          TOON: ""
        };
        _this.type = "MeshToonMaterial";
        _this.color = new Color5(16777215);
        _this.map = null;
        _this.gradientMap = null;
        _this.lightMap = null;
        _this.lightMapIntensity = 1;
        _this.aoMap = null;
        _this.aoMapIntensity = 1;
        _this.emissive = new Color5(0);
        _this.emissiveIntensity = 1;
        _this.emissiveMap = null;
        _this.bumpMap = null;
        _this.bumpScale = 1;
        _this.normalMap = null;
        _this.normalMapType = TangentSpaceNormalMap2;
        _this.normalScale = new Vector22(1, 1);
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.alphaMap = null;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.wireframeLinecap = "round";
        _this.wireframeLinejoin = "round";
        _this.skinning = false;
        _this.morphTargets = false;
        _this.morphNormals = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshToonMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
      };
      return MeshToonMaterial3;
    }(Material2);
    MeshToonMaterial2.prototype.isMeshToonMaterial = true;
    var MeshNormalMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshNormalMaterial3, _Material);
      function MeshNormalMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshNormalMaterial";
        _this.bumpMap = null;
        _this.bumpScale = 1;
        _this.normalMap = null;
        _this.normalMapType = TangentSpaceNormalMap2;
        _this.normalScale = new Vector22(1, 1);
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.fog = false;
        _this.skinning = false;
        _this.morphTargets = false;
        _this.morphNormals = false;
        _this.flatShading = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshNormalMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
      };
      return MeshNormalMaterial3;
    }(Material2);
    MeshNormalMaterial2.prototype.isMeshNormalMaterial = true;
    var MeshLambertMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshLambertMaterial3, _Material);
      function MeshLambertMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.type = "MeshLambertMaterial";
        _this.color = new Color5(16777215);
        _this.map = null;
        _this.lightMap = null;
        _this.lightMapIntensity = 1;
        _this.aoMap = null;
        _this.aoMapIntensity = 1;
        _this.emissive = new Color5(0);
        _this.emissiveIntensity = 1;
        _this.emissiveMap = null;
        _this.specularMap = null;
        _this.alphaMap = null;
        _this.envMap = null;
        _this.combine = MultiplyOperation2;
        _this.reflectivity = 1;
        _this.refractionRatio = 0.98;
        _this.wireframe = false;
        _this.wireframeLinewidth = 1;
        _this.wireframeLinecap = "round";
        _this.wireframeLinejoin = "round";
        _this.skinning = false;
        _this.morphTargets = false;
        _this.morphNormals = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshLambertMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
      };
      return MeshLambertMaterial3;
    }(Material2);
    MeshLambertMaterial2.prototype.isMeshLambertMaterial = true;
    var MeshMatcapMaterial2 = /* @__PURE__ */ function(_Material) {
      _inheritsLoose(MeshMatcapMaterial3, _Material);
      function MeshMatcapMaterial3(parameters) {
        var _this;
        _this = _Material.call(this) || this;
        _this.defines = {
          MATCAP: ""
        };
        _this.type = "MeshMatcapMaterial";
        _this.color = new Color5(16777215);
        _this.matcap = null;
        _this.map = null;
        _this.bumpMap = null;
        _this.bumpScale = 1;
        _this.normalMap = null;
        _this.normalMapType = TangentSpaceNormalMap2;
        _this.normalScale = new Vector22(1, 1);
        _this.displacementMap = null;
        _this.displacementScale = 1;
        _this.displacementBias = 0;
        _this.alphaMap = null;
        _this.skinning = false;
        _this.morphTargets = false;
        _this.morphNormals = false;
        _this.flatShading = false;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = MeshMatcapMaterial3.prototype;
      _proto.copy = function copy(source) {
        _Material.prototype.copy.call(this, source);
        this.defines = {
          MATCAP: ""
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
      };
      return MeshMatcapMaterial3;
    }(Material2);
    MeshMatcapMaterial2.prototype.isMeshMatcapMaterial = true;
    var LineDashedMaterial2 = /* @__PURE__ */ function(_LineBasicMaterial) {
      _inheritsLoose(LineDashedMaterial3, _LineBasicMaterial);
      function LineDashedMaterial3(parameters) {
        var _this;
        _this = _LineBasicMaterial.call(this) || this;
        _this.type = "LineDashedMaterial";
        _this.scale = 1;
        _this.dashSize = 3;
        _this.gapSize = 1;
        _this.setValues(parameters);
        return _this;
      }
      var _proto = LineDashedMaterial3.prototype;
      _proto.copy = function copy(source) {
        _LineBasicMaterial.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
      };
      return LineDashedMaterial3;
    }(LineBasicMaterial2);
    LineDashedMaterial2.prototype.isLineDashedMaterial = true;
    var Materials = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ShadowMaterial: ShadowMaterial2,
      SpriteMaterial: SpriteMaterial2,
      RawShaderMaterial: RawShaderMaterial2,
      ShaderMaterial: ShaderMaterial2,
      PointsMaterial: PointsMaterial2,
      MeshPhysicalMaterial: MeshPhysicalMaterial2,
      MeshStandardMaterial: MeshStandardMaterial2,
      MeshPhongMaterial: MeshPhongMaterial3,
      MeshToonMaterial: MeshToonMaterial2,
      MeshNormalMaterial: MeshNormalMaterial2,
      MeshLambertMaterial: MeshLambertMaterial2,
      MeshDepthMaterial: MeshDepthMaterial2,
      MeshDistanceMaterial: MeshDistanceMaterial2,
      MeshBasicMaterial: MeshBasicMaterial2,
      MeshMatcapMaterial: MeshMatcapMaterial2,
      LineDashedMaterial: LineDashedMaterial2,
      LineBasicMaterial: LineBasicMaterial2,
      Material: Material2
    });
    var AnimationUtils2 = {
      arraySlice: function arraySlice(array, from, to) {
        if (AnimationUtils2.isTypedArray(array)) {
          return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
        }
        return array.slice(from, to);
      },
      convertArray: function convertArray(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
          return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array);
        }
        return Array.prototype.slice.call(array);
      },
      isTypedArray: function isTypedArray(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function getKeyframeOrder(times) {
        function compareTime(i3, j) {
          return times[i3] - times[j];
        }
        var n = times.length;
        var result = new Array(n);
        for (var i2 = 0; i2 !== n; ++i2) {
          result[i2] = i2;
        }
        result.sort(compareTime);
        return result;
      },
      sortedArray: function sortedArray(values, stride, order) {
        var nValues = values.length;
        var result = new values.constructor(nValues);
        for (var i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
          var srcOffset = order[i2] * stride;
          for (var j = 0; j !== stride; ++j) {
            result[dstOffset++] = values[srcOffset + j];
          }
        }
        return result;
      },
      flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
        var i2 = 1, key = jsonKeys[0];
        while (key !== void 0 && key[valuePropertyName] === void 0) {
          key = jsonKeys[i2++];
        }
        if (key === void 0)
          return;
        var value = key[valuePropertyName];
        if (value === void 0)
          return;
        if (Array.isArray(value)) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push.apply(values, value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else if (value.toArray !== void 0) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              value.toArray(values, values.length);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push(value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        }
      },
      subclip: function subclip(sourceClip, name2, startFrame, endFrame, fps) {
        if (fps === void 0) {
          fps = 30;
        }
        var clip = sourceClip.clone();
        clip.name = name2;
        var tracks = [];
        for (var i2 = 0; i2 < clip.tracks.length; ++i2) {
          var track = clip.tracks[i2];
          var valueSize = track.getValueSize();
          var times = [];
          var values = [];
          for (var j = 0; j < track.times.length; ++j) {
            var frame = track.times[j] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j]);
            for (var k = 0; k < valueSize; ++k) {
              values.push(track.values[j * valueSize + k]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils2.convertArray(times, track.times.constructor);
          track.values = AnimationUtils2.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        var minStartTime = Infinity;
        for (var _i = 0; _i < clip.tracks.length; ++_i) {
          if (minStartTime > clip.tracks[_i].times[0]) {
            minStartTime = clip.tracks[_i].times[0];
          }
        }
        for (var _i2 = 0; _i2 < clip.tracks.length; ++_i2) {
          clip.tracks[_i2].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      },
      makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === void 0) {
          referenceFrame = 0;
        }
        if (referenceClip === void 0) {
          referenceClip = targetClip;
        }
        if (fps === void 0) {
          fps = 30;
        }
        if (fps <= 0)
          fps = 30;
        var numTracks = referenceClip.tracks.length;
        var referenceTime = referenceFrame / fps;
        var _loop = function _loop2(i3) {
          var referenceTrack = referenceClip.tracks[i3];
          var referenceTrackType = referenceTrack.ValueTypeName;
          if (referenceTrackType === "bool" || referenceTrackType === "string")
            return "continue";
          var targetTrack = targetClip.tracks.find(function(track) {
            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
          });
          if (targetTrack === void 0)
            return "continue";
          var referenceOffset = 0;
          var referenceValueSize = referenceTrack.getValueSize();
          if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            referenceOffset = referenceValueSize / 3;
          }
          var targetOffset = 0;
          var targetValueSize = targetTrack.getValueSize();
          if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            targetOffset = targetValueSize / 3;
          }
          var lastIndex = referenceTrack.times.length - 1;
          var referenceValue = void 0;
          if (referenceTime <= referenceTrack.times[0]) {
            var startIndex = referenceOffset;
            var endIndex = referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else if (referenceTime >= referenceTrack.times[lastIndex]) {
            var _startIndex = lastIndex * referenceValueSize + referenceOffset;
            var _endIndex = _startIndex + referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, _startIndex, _endIndex);
          } else {
            var interpolant = referenceTrack.createInterpolant();
            var _startIndex2 = referenceOffset;
            var _endIndex2 = referenceValueSize - referenceOffset;
            interpolant.evaluate(referenceTime);
            referenceValue = AnimationUtils2.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);
          }
          if (referenceTrackType === "quaternion") {
            var referenceQuat = new Quaternion2().fromArray(referenceValue).normalize().conjugate();
            referenceQuat.toArray(referenceValue);
          }
          var numTimes = targetTrack.times.length;
          for (var j = 0; j < numTimes; ++j) {
            var valueStart = j * targetValueSize + targetOffset;
            if (referenceTrackType === "quaternion") {
              Quaternion2.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
            } else {
              var valueEnd = targetValueSize - targetOffset * 2;
              for (var k = 0; k < valueEnd; ++k) {
                targetTrack.values[valueStart + k] -= referenceValue[k];
              }
            }
          }
        };
        for (var i2 = 0; i2 < numTracks; ++i2) {
          var _ret = _loop(i2);
          if (_ret === "continue")
            continue;
        }
        targetClip.blendMode = AdditiveAnimationBlendMode2;
        return targetClip;
      }
    };
    function Interpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
    }
    Object.assign(Interpolant2.prototype, {
      evaluate: function evaluate(t) {
        var pp = this.parameterPositions;
        var i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            var right;
            linear_scan: {
              forward_scan:
                if (!(t < t1)) {
                  for (var giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.afterEnd_(i1 - 1, t, t0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t >= t0)) {
                var t1global = pp[1];
                if (t < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (var _giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                  }
                  if (i1 === _giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              var mid = i1 + right >>> 1;
              if (t < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.beforeStart_(0, t, t1);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.afterEnd_(i1 - 1, t0, t);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t, t1);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function getSettings_() {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function copySampleValue_(index) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for (var i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset + i2];
        }
        return result;
      },
      interpolate_: function interpolate_() {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function intervalChanged_() {
      }
    });
    Object.assign(Interpolant2.prototype, {
      beforeStart_: Interpolant2.prototype.copySampleValue_,
      afterEnd_: Interpolant2.prototype.copySampleValue_
    });
    function CubicInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
    }
    CubicInterpolant2.prototype = Object.assign(Object.create(Interpolant2.prototype), {
      constructor: CubicInterpolant2,
      DefaultSettings_: {
        endingStart: ZeroCurvatureEnding2,
        endingEnd: ZeroCurvatureEnding2
      },
      intervalChanged_: function intervalChanged_(i1, t0, t1) {
        var pp = this.parameterPositions;
        var iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding2:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding2:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding2:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding2:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      },
      interpolate_: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;
        for (var i2 = 0; i2 !== stride; ++i2) {
          result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
        }
        return result;
      }
    });
    function LinearInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant2.prototype = Object.assign(Object.create(Interpolant2.prototype), {
      constructor: LinearInterpolant2,
      interpolate_: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (var i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
        }
        return result;
      }
    });
    function DiscreteInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant2.prototype = Object.assign(Object.create(Interpolant2.prototype), {
      constructor: DiscreteInterpolant2,
      interpolate_: function interpolate_(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    });
    var KeyframeTrack2 = /* @__PURE__ */ function() {
      function KeyframeTrack3(name2, times, values, interpolation) {
        if (name2 === void 0)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === void 0 || times.length === 0)
          throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
        this.name = name2;
        this.times = AnimationUtils2.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils2.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
      }
      KeyframeTrack3.toJSON = function toJSON2(track) {
        var trackType = track.constructor;
        var json;
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          json = {
            name: track.name,
            times: AnimationUtils2.convertArray(track.times, Array),
            values: AnimationUtils2.convertArray(track.values, Array)
          };
          var interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      };
      var _proto = KeyframeTrack3.prototype;
      _proto.InterpolantFactoryMethodDiscrete = function InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant2(this.times, this.values, this.getValueSize(), result);
      };
      _proto.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant2(this.times, this.values, this.getValueSize(), result);
      };
      _proto.InterpolantFactoryMethodSmooth = function InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant2(this.times, this.values, this.getValueSize(), result);
      };
      _proto.setInterpolation = function setInterpolation(interpolation) {
        var factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete2:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear2:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth2:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      };
      _proto.getInterpolation = function getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete2;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear2;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth2;
        }
      };
      _proto.getValueSize = function getValueSize() {
        return this.values.length / this.times.length;
      };
      _proto.shift = function shift(timeOffset) {
        if (timeOffset !== 0) {
          var times = this.times;
          for (var i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] += timeOffset;
          }
        }
        return this;
      };
      _proto.scale = function scale(timeScale) {
        if (timeScale !== 1) {
          var times = this.times;
          for (var i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] *= timeScale;
          }
        }
        return this;
      };
      _proto.trim = function trim(startTime, endTime) {
        var times = this.times, nKeys = times.length;
        var from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from !== 0 || to !== nKeys) {
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          var stride = this.getValueSize();
          this.times = AnimationUtils2.arraySlice(times, from, to);
          this.values = AnimationUtils2.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
      };
      _proto.validate = function validate() {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        var times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        var prevTime = null;
        for (var i2 = 0; i2 !== nKeys; i2++) {
          var currTime = times[i2];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils2.isTypedArray(values)) {
            for (var _i = 0, n = values.length; _i !== n; ++_i) {
              var value = values[_i];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, _i, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      };
      _proto.optimize = function optimize() {
        var times = AnimationUtils2.arraySlice(this.times), values = AnimationUtils2.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth2, lastIndex = times.length - 1;
        var writeIndex = 1;
        for (var i2 = 1; i2 < lastIndex; ++i2) {
          var keep = false;
          var time = times[i2];
          var timeNext = times[i2 + 1];
          if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              var offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (var j = 0; j !== stride; ++j) {
                var value = values[offset + j];
                if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i2 !== writeIndex) {
              times[writeIndex] = times[i2];
              var readOffset = i2 * stride, writeOffset = writeIndex * stride;
              for (var _j = 0; _j !== stride; ++_j) {
                values[writeOffset + _j] = values[readOffset + _j];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j2 = 0; _j2 !== stride; ++_j2) {
            values[_writeOffset + _j2] = values[_readOffset + _j2];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils2.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils2.arraySlice(values, 0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      };
      _proto.clone = function clone() {
        var times = AnimationUtils2.arraySlice(this.times, 0);
        var values = AnimationUtils2.arraySlice(this.values, 0);
        var TypedKeyframeTrack = this.constructor;
        var track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      };
      return KeyframeTrack3;
    }();
    KeyframeTrack2.prototype.TimeBufferType = Float32Array;
    KeyframeTrack2.prototype.ValueBufferType = Float32Array;
    KeyframeTrack2.prototype.DefaultInterpolation = InterpolateLinear2;
    var BooleanKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(BooleanKeyframeTrack3, _KeyframeTrack);
      function BooleanKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      return BooleanKeyframeTrack3;
    }(KeyframeTrack2);
    BooleanKeyframeTrack2.prototype.ValueTypeName = "bool";
    BooleanKeyframeTrack2.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack2.prototype.DefaultInterpolation = InterpolateDiscrete2;
    BooleanKeyframeTrack2.prototype.InterpolantFactoryMethodLinear = void 0;
    BooleanKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
    var ColorKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(ColorKeyframeTrack3, _KeyframeTrack);
      function ColorKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      return ColorKeyframeTrack3;
    }(KeyframeTrack2);
    ColorKeyframeTrack2.prototype.ValueTypeName = "color";
    var NumberKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(NumberKeyframeTrack3, _KeyframeTrack);
      function NumberKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      return NumberKeyframeTrack3;
    }(KeyframeTrack2);
    NumberKeyframeTrack2.prototype.ValueTypeName = "number";
    function QuaternionLinearInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant2.prototype = Object.assign(Object.create(Interpolant2.prototype), {
      constructor: QuaternionLinearInterpolant2,
      interpolate_: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        var offset = i1 * stride;
        for (var end = offset + stride; offset !== end; offset += 4) {
          Quaternion2.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    });
    var QuaternionKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(QuaternionKeyframeTrack3, _KeyframeTrack);
      function QuaternionKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      var _proto = QuaternionKeyframeTrack3.prototype;
      _proto.InterpolantFactoryMethodLinear = function InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant2(this.times, this.values, this.getValueSize(), result);
      };
      return QuaternionKeyframeTrack3;
    }(KeyframeTrack2);
    QuaternionKeyframeTrack2.prototype.ValueTypeName = "quaternion";
    QuaternionKeyframeTrack2.prototype.DefaultInterpolation = InterpolateLinear2;
    QuaternionKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
    var StringKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(StringKeyframeTrack3, _KeyframeTrack);
      function StringKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      return StringKeyframeTrack3;
    }(KeyframeTrack2);
    StringKeyframeTrack2.prototype.ValueTypeName = "string";
    StringKeyframeTrack2.prototype.ValueBufferType = Array;
    StringKeyframeTrack2.prototype.DefaultInterpolation = InterpolateDiscrete2;
    StringKeyframeTrack2.prototype.InterpolantFactoryMethodLinear = void 0;
    StringKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
    var VectorKeyframeTrack2 = /* @__PURE__ */ function(_KeyframeTrack) {
      _inheritsLoose(VectorKeyframeTrack3, _KeyframeTrack);
      function VectorKeyframeTrack3() {
        return _KeyframeTrack.apply(this, arguments) || this;
      }
      return VectorKeyframeTrack3;
    }(KeyframeTrack2);
    VectorKeyframeTrack2.prototype.ValueTypeName = "vector";
    var AnimationClip2 = /* @__PURE__ */ function() {
      function AnimationClip3(name2, duration, tracks, blendMode) {
        if (duration === void 0) {
          duration = -1;
        }
        if (blendMode === void 0) {
          blendMode = NormalAnimationBlendMode2;
        }
        this.name = name2;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = MathUtils2.generateUUID();
        if (this.duration < 0) {
          this.resetDuration();
        }
      }
      AnimationClip3.parse = function parse(json) {
        var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (var i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
          tracks.push(parseKeyframeTrack2(jsonTracks[i2]).scale(frameTime));
        }
        var clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
      };
      AnimationClip3.toJSON = function toJSON2(clip) {
        var tracks = [], clipTracks = clip.tracks;
        var json = {
          name: clip.name,
          duration: clip.duration,
          tracks,
          uuid: clip.uuid,
          blendMode: clip.blendMode
        };
        for (var i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
          tracks.push(KeyframeTrack2.toJSON(clipTracks[i2]));
        }
        return json;
      };
      AnimationClip3.CreateFromMorphTargetSequence = function CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for (var i2 = 0; i2 < numMorphTargets; i2++) {
          var times = [];
          var values = [];
          times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
          values.push(0, 1, 0);
          var order = AnimationUtils2.getKeyframeOrder(times);
          times = AnimationUtils2.sortedArray(times, 1, order);
          values = AnimationUtils2.sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack2(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
        }
        return new this(name2, -1, tracks);
      };
      AnimationClip3.findByName = function findByName(objectOrClipArray, name2) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          var o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (var i2 = 0; i2 < clipArray.length; i2++) {
          if (clipArray[i2].name === name2) {
            return clipArray[i2];
          }
        }
        return null;
      };
      AnimationClip3.CreateClipsFromMorphTargetSequences = function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};
        var pattern = /^([\w-]*?)([\d]+)$/;
        for (var i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          var morphTarget = morphTargets[i2];
          var parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            var name2 = parts[1];
            var animationMorphTargets = animationToMorphTargets[name2];
            if (!animationMorphTargets) {
              animationToMorphTargets[name2] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        var clips = [];
        for (var _name in animationToMorphTargets) {
          clips.push(this.CreateFromMorphTargetSequence(_name, animationToMorphTargets[_name], fps, noLoop));
        }
        return clips;
      };
      AnimationClip3.parseAnimation = function parseAnimation(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        var addNonemptyTrack = function addNonemptyTrack2(trackType, trackName, animationKeys2, propertyName, destTracks) {
          if (animationKeys2.length !== 0) {
            var times2 = [];
            var values2 = [];
            AnimationUtils2.flattenJSON(animationKeys2, times2, values2, propertyName);
            if (times2.length !== 0) {
              destTracks.push(new trackType(trackName, times2, values2));
            }
          }
        };
        var tracks = [];
        var clipName = animation.name || "default";
        var fps = animation.fps || 30;
        var blendMode = animation.blendMode;
        var duration = animation.length || -1;
        var hierarchyTracks = animation.hierarchy || [];
        for (var h = 0; h < hierarchyTracks.length; h++) {
          var animationKeys = hierarchyTracks[h].keys;
          if (!animationKeys || animationKeys.length === 0)
            continue;
          if (animationKeys[0].morphTargets) {
            var morphTargetNames = {};
            var k = void 0;
            for (k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                  morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
              }
            }
            for (var morphTargetName in morphTargetNames) {
              var times = [];
              var values = [];
              for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
                var animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack2(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * (fps || 1);
          } else {
            var boneName = ".bones[" + bones[h].name + "]";
            addNonemptyTrack(VectorKeyframeTrack2, boneName + ".position", animationKeys, "pos", tracks);
            addNonemptyTrack(QuaternionKeyframeTrack2, boneName + ".quaternion", animationKeys, "rot", tracks);
            addNonemptyTrack(VectorKeyframeTrack2, boneName + ".scale", animationKeys, "scl", tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        var clip = new this(clipName, duration, tracks, blendMode);
        return clip;
      };
      var _proto = AnimationClip3.prototype;
      _proto.resetDuration = function resetDuration() {
        var tracks = this.tracks;
        var duration = 0;
        for (var i2 = 0, n = tracks.length; i2 !== n; ++i2) {
          var track = this.tracks[i2];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      };
      _proto.trim = function trim() {
        for (var i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].trim(0, this.duration);
        }
        return this;
      };
      _proto.validate = function validate() {
        var valid = true;
        for (var i2 = 0; i2 < this.tracks.length; i2++) {
          valid = valid && this.tracks[i2].validate();
        }
        return valid;
      };
      _proto.optimize = function optimize() {
        for (var i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].optimize();
        }
        return this;
      };
      _proto.clone = function clone() {
        var tracks = [];
        for (var i2 = 0; i2 < this.tracks.length; i2++) {
          tracks.push(this.tracks[i2].clone());
        }
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
      };
      _proto.toJSON = function toJSON2() {
        return this.constructor.toJSON(this);
      };
      return AnimationClip3;
    }();
    function getTrackTypeForValueTypeName2(typeName) {
      switch (typeName.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return NumberKeyframeTrack2;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return VectorKeyframeTrack2;
        case "color":
          return ColorKeyframeTrack2;
        case "quaternion":
          return QuaternionKeyframeTrack2;
        case "bool":
        case "boolean":
          return BooleanKeyframeTrack2;
        case "string":
          return StringKeyframeTrack2;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
    }
    function parseKeyframeTrack2(json) {
      if (json.type === void 0) {
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      }
      var trackType = getTrackTypeForValueTypeName2(json.type);
      if (json.times === void 0) {
        var times = [], values = [];
        AnimationUtils2.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
      }
      if (trackType.parse !== void 0) {
        return trackType.parse(json);
      } else {
        return new trackType(json.name, json.times, json.values, json.interpolation);
      }
    }
    var Cache2 = {
      enabled: false,
      files: {},
      add: function add(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function get(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function remove(key) {
        delete this.files[key];
      },
      clear: function clear() {
        this.files = {};
      }
    };
    function LoadingManager2(onLoad, onProgress, onError) {
      var scope = this;
      var isLoading = false;
      var itemsLoaded = 0;
      var itemsTotal = 0;
      var urlModifier = void 0;
      var handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        var index = handlers.indexOf(regex);
        if (index !== -1) {
          handlers.splice(index, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (var i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
          var regex = handlers[i2];
          var loader = handlers[i2 + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      };
    }
    var DefaultLoadingManager2 = new LoadingManager2();
    function Loader2(manager) {
      this.manager = manager !== void 0 ? manager : DefaultLoadingManager2;
      this.crossOrigin = "anonymous";
      this.withCredentials = false;
      this.path = "";
      this.resourcePath = "";
      this.requestHeader = {};
    }
    Object.assign(Loader2.prototype, {
      load: function load() {
      },
      loadAsync: function loadAsync(url, onProgress) {
        var scope = this;
        return new Promise(function(resolve, reject) {
          scope.load(url, resolve, onProgress, reject);
        });
      },
      parse: function parse() {
      },
      setCrossOrigin: function setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      },
      setWithCredentials: function setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      },
      setPath: function setPath(path) {
        this.path = path;
        return this;
      },
      setResourcePath: function setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      },
      setRequestHeader: function setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    });
    var loading2 = {};
    function FileLoader2(manager) {
      Loader2.call(this, manager);
    }
    FileLoader2.prototype = Object.assign(Object.create(Loader2.prototype), {
      constructor: FileLoader2,
      load: function load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache2.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading2[url] !== void 0) {
          loading2[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        var dataUriRegexResult = url.match(dataUriRegex);
        var request;
        if (dataUriRegexResult) {
          var mimeType = dataUriRegexResult[1];
          var isBase64 = !!dataUriRegexResult[2];
          var data = dataUriRegexResult[3];
          data = decodeURIComponent(data);
          if (isBase64)
            data = atob(data);
          try {
            var response;
            var responseType = (this.responseType || "").toLowerCase();
            switch (responseType) {
              case "arraybuffer":
              case "blob":
                var view = new Uint8Array(data.length);
                for (var i2 = 0; i2 < data.length; i2++) {
                  view[i2] = data.charCodeAt(i2);
                }
                if (responseType === "blob") {
                  response = new Blob([view.buffer], {
                    type: mimeType
                  });
                } else {
                  response = view.buffer;
                }
                break;
              case "document":
                var parser = new DOMParser();
                response = parser.parseFromString(data, mimeType);
                break;
              case "json":
                response = JSON.parse(data);
                break;
              default:
                response = data;
                break;
            }
            setTimeout(function() {
              if (onLoad)
                onLoad(response);
              scope.manager.itemEnd(url);
            }, 0);
          } catch (error) {
            setTimeout(function() {
              if (onError)
                onError(error);
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }, 0);
          }
        } else {
          loading2[url] = [];
          loading2[url].push({
            onLoad,
            onProgress,
            onError
          });
          request = new XMLHttpRequest();
          request.open("GET", url, true);
          request.addEventListener("load", function(event) {
            var response2 = this.response;
            var callbacks = loading2[url];
            delete loading2[url];
            if (this.status === 200 || this.status === 0) {
              if (this.status === 0)
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              Cache2.add(url, response2);
              for (var _i = 0, il = callbacks.length; _i < il; _i++) {
                var callback = callbacks[_i];
                if (callback.onLoad)
                  callback.onLoad(response2);
              }
              scope.manager.itemEnd(url);
            } else {
              for (var _i2 = 0, _il = callbacks.length; _i2 < _il; _i2++) {
                var _callback = callbacks[_i2];
                if (_callback.onError)
                  _callback.onError(event);
              }
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            }
          }, false);
          request.addEventListener("progress", function(event) {
            var callbacks = loading2[url];
            for (var _i3 = 0, il = callbacks.length; _i3 < il; _i3++) {
              var callback = callbacks[_i3];
              if (callback.onProgress)
                callback.onProgress(event);
            }
          }, false);
          request.addEventListener("error", function(event) {
            var callbacks = loading2[url];
            delete loading2[url];
            for (var _i4 = 0, il = callbacks.length; _i4 < il; _i4++) {
              var callback = callbacks[_i4];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, false);
          request.addEventListener("abort", function(event) {
            var callbacks = loading2[url];
            delete loading2[url];
            for (var _i5 = 0, il = callbacks.length; _i5 < il; _i5++) {
              var callback = callbacks[_i5];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, false);
          if (this.responseType !== void 0)
            request.responseType = this.responseType;
          if (this.withCredentials !== void 0)
            request.withCredentials = this.withCredentials;
          if (request.overrideMimeType)
            request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
          for (var header in this.requestHeader) {
            request.setRequestHeader(header, this.requestHeader[header]);
          }
          request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
      },
      setResponseType: function setResponseType(value) {
        this.responseType = value;
        return this;
      },
      setMimeType: function setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    });
    var AnimationLoader = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(AnimationLoader2, _Loader);
      function AnimationLoader2(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = AnimationLoader2.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      };
      _proto.parse = function parse(json) {
        var animations = [];
        for (var i2 = 0; i2 < json.length; i2++) {
          var clip = AnimationClip2.parse(json[i2]);
          animations.push(clip);
        }
        return animations;
      };
      return AnimationLoader2;
    }(Loader2);
    function CompressedTextureLoader2(manager) {
      Loader2.call(this, manager);
    }
    CompressedTextureLoader2.prototype = Object.assign(Object.create(Loader2.prototype), {
      constructor: CompressedTextureLoader2,
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture2();
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        var loaded = 0;
        function loadTexture(i3) {
          loader.load(url[i3], function(buffer) {
            var texDatas = scope.parse(buffer, true);
            images[i3] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1)
                texture.minFilter = LinearFilter2;
              texture.image = images;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url)) {
          for (var i2 = 0, il = url.length; i2 < il; ++i2) {
            loadTexture(i2);
          }
        } else {
          loader.load(url, function(buffer) {
            var texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {
                  mipmaps: []
                };
                for (var _i = 0; _i < texDatas.mipmapCount; _i++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
              texture.image = images;
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter2;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    });
    var ImageLoader2 = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(ImageLoader3, _Loader);
      function ImageLoader3(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = ImageLoader3.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache2.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function onImageLoad() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          Cache2.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
          if (onError)
            onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.substr(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      };
      return ImageLoader3;
    }(Loader2);
    var CubeTextureLoader2 = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(CubeTextureLoader3, _Loader);
      function CubeTextureLoader3(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = CubeTextureLoader3.prototype;
      _proto.load = function load(urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture2();
        var loader = new ImageLoader2(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i3) {
          loader.load(urls[i3], function(image) {
            texture.images[i3] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, void 0, onError);
        }
        for (var i2 = 0; i2 < urls.length; ++i2) {
          loadTexture(i2);
        }
        return texture;
      };
      return CubeTextureLoader3;
    }(Loader2);
    function DataTextureLoader2(manager) {
      Loader2.call(this, manager);
    }
    DataTextureLoader2.prototype = Object.assign(Object.create(Loader2.prototype), {
      constructor: DataTextureLoader2,
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture2();
        var loader = new FileLoader2(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
          var texData = scope.parse(buffer);
          if (!texData)
            return;
          if (texData.image !== void 0) {
            texture.image = texData.image;
          } else if (texData.data !== void 0) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping2;
          texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping2;
          texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter2;
          texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter2;
          texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
          if (texData.encoding !== void 0) {
            texture.encoding = texData.encoding;
          }
          if (texData.flipY !== void 0) {
            texture.flipY = texData.flipY;
          }
          if (texData.format !== void 0) {
            texture.format = texData.format;
          }
          if (texData.type !== void 0) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== void 0) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter2;
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter2;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    });
    function TextureLoader2(manager) {
      Loader2.call(this, manager);
    }
    TextureLoader2.prototype = Object.assign(Object.create(Loader2.prototype), {
      constructor: TextureLoader2,
      load: function load(url, onLoad, onProgress, onError) {
        var texture = new Texture2();
        var loader = new ImageLoader2(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
          texture.image = image;
          var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
          texture.format = isJPEG ? RGBFormat2 : RGBAFormat2;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    });
    function Curve2() {
      this.type = "Curve";
      this.arcLengthDivisions = 200;
    }
    Object.assign(Curve2.prototype, {
      getPoint: function getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      },
      getPointAt: function getPointAt(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
      },
      getPoints: function getPoints(divisions) {
        if (divisions === void 0) {
          divisions = 5;
        }
        var points = [];
        for (var d = 0; d <= divisions; d++) {
          points.push(this.getPoint(d / divisions));
        }
        return points;
      },
      getSpacedPoints: function getSpacedPoints(divisions) {
        if (divisions === void 0) {
          divisions = 5;
        }
        var points = [];
        for (var d = 0; d <= divisions; d++) {
          points.push(this.getPointAt(d / divisions));
        }
        return points;
      },
      getLength: function getLength() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function getLengths(divisions) {
        if (divisions === void 0)
          divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current, last = this.getPoint(0);
        var sum = 0;
        cache.push(0);
        for (var p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      },
      updateArcLengths: function updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
      },
      getUtoTmapping: function getUtoTmapping(u, distance) {
        var arcLengths = this.getLengths();
        var i2 = 0;
        var il = arcLengths.length;
        var targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        var low = 0, high = il - 1, comparison;
        while (low <= high) {
          i2 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i2] - targetArcLength;
          if (comparison < 0) {
            low = i2 + 1;
          } else if (comparison > 0) {
            high = i2 - 1;
          } else {
            high = i2;
            break;
          }
        }
        i2 = high;
        if (arcLengths[i2] === targetArcLength) {
          return i2 / (il - 1);
        }
        var lengthBefore = arcLengths[i2];
        var lengthAfter = arcLengths[i2 + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        var t = (i2 + segmentFraction) / (il - 1);
        return t;
      },
      getTangent: function getTangent(t, optionalTarget) {
        var delta = 1e-4;
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0)
          t1 = 0;
        if (t2 > 1)
          t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var tangent = optionalTarget || (pt1.isVector2 ? new Vector22() : new Vector32());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      },
      getTangentAt: function getTangentAt(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
      },
      computeFrenetFrames: function computeFrenetFrames(segments, closed) {
        var normal = new Vector32();
        var tangents = [];
        var normals = [];
        var binormals = [];
        var vec = new Vector32();
        var mat = new Matrix43();
        for (var i2 = 0; i2 <= segments; i2++) {
          var u = i2 / segments;
          tangents[i2] = this.getTangentAt(u, new Vector32());
          tangents[i2].normalize();
        }
        normals[0] = new Vector32();
        binormals[0] = new Vector32();
        var min = Number.MAX_VALUE;
        var tx = Math.abs(tangents[0].x);
        var ty = Math.abs(tangents[0].y);
        var tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (var _i = 1; _i <= segments; _i++) {
          normals[_i] = normals[_i - 1].clone();
          binormals[_i] = binormals[_i - 1].clone();
          vec.crossVectors(tangents[_i - 1], tangents[_i]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            var theta = Math.acos(MathUtils2.clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1));
            normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[_i].crossVectors(tangents[_i], normals[_i]);
        }
        if (closed === true) {
          var _theta = Math.acos(MathUtils2.clamp(normals[0].dot(normals[segments]), -1, 1));
          _theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            _theta = -_theta;
          }
          for (var _i2 = 1; _i2 <= segments; _i2++) {
            normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));
            binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      },
      clone: function clone() {
        return new this.constructor().copy(this);
      },
      copy: function copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      },
      toJSON: function toJSON2() {
        var data = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      },
      fromJSON: function fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    });
    var EllipseCurve2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(EllipseCurve3, _Curve);
      function EllipseCurve3(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var _this;
        if (aX === void 0) {
          aX = 0;
        }
        if (aY === void 0) {
          aY = 0;
        }
        if (xRadius === void 0) {
          xRadius = 1;
        }
        if (yRadius === void 0) {
          yRadius = 1;
        }
        if (aStartAngle === void 0) {
          aStartAngle = 0;
        }
        if (aEndAngle === void 0) {
          aEndAngle = Math.PI * 2;
        }
        if (aClockwise === void 0) {
          aClockwise = false;
        }
        if (aRotation === void 0) {
          aRotation = 0;
        }
        _this = _Curve.call(this) || this;
        _this.type = "EllipseCurve";
        _this.aX = aX;
        _this.aY = aY;
        _this.xRadius = xRadius;
        _this.yRadius = yRadius;
        _this.aStartAngle = aStartAngle;
        _this.aEndAngle = aEndAngle;
        _this.aClockwise = aClockwise;
        _this.aRotation = aRotation;
        return _this;
      }
      var _proto = EllipseCurve3.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        var point = optionalTarget || new Vector22();
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0) {
          deltaAngle += twoPi;
        }
        while (deltaAngle > twoPi) {
          deltaAngle -= twoPi;
        }
        if (deltaAngle < Number.EPSILON) {
          if (samePoints) {
            deltaAngle = 0;
          } else {
            deltaAngle = twoPi;
          }
        }
        if (this.aClockwise === true && !samePoints) {
          if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
          } else {
            deltaAngle = deltaAngle - twoPi;
          }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
          var cos = Math.cos(this.aRotation);
          var sin = Math.sin(this.aRotation);
          var tx = x - this.aX;
          var ty = y - this.aY;
          x = tx * cos - ty * sin + this.aX;
          y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
      };
      return EllipseCurve3;
    }(Curve2);
    EllipseCurve2.prototype.isEllipseCurve = true;
    var ArcCurve2 = /* @__PURE__ */ function(_EllipseCurve) {
      _inheritsLoose(ArcCurve3, _EllipseCurve);
      function ArcCurve3(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var _this;
        _this = _EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise) || this;
        _this.type = "ArcCurve";
        return _this;
      }
      return ArcCurve3;
    }(EllipseCurve2);
    ArcCurve2.prototype.isArcCurve = true;
    function CubicPoly2() {
      var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
      function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
      }
      return {
        initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
          init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
          var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
          var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
          t1 *= dt1;
          t2 *= dt1;
          init(x1, x2, t1, t2);
        },
        calc: function calc(t) {
          var t2 = t * t;
          var t3 = t2 * t;
          return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
      };
    }
    var tmp2 = new Vector32();
    var px2 = new CubicPoly2(), py2 = new CubicPoly2(), pz2 = new CubicPoly2();
    var CatmullRomCurve32 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(CatmullRomCurve33, _Curve);
      function CatmullRomCurve33(points, closed, curveType, tension) {
        var _this;
        if (points === void 0) {
          points = [];
        }
        if (closed === void 0) {
          closed = false;
        }
        if (curveType === void 0) {
          curveType = "centripetal";
        }
        if (tension === void 0) {
          tension = 0.5;
        }
        _this = _Curve.call(this) || this;
        _this.type = "CatmullRomCurve3";
        _this.points = points;
        _this.closed = closed;
        _this.curveType = curveType;
        _this.tension = tension;
        return _this;
      }
      var _proto = CatmullRomCurve33.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector32();
        }
        var point = optionalTarget;
        var points = this.points;
        var l = points.length;
        var p = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        if (this.closed) {
          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        } else if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        var p0, p3;
        if (this.closed || intPoint > 0) {
          p0 = points[(intPoint - 1) % l];
        } else {
          tmp2.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp2;
        }
        var p1 = points[intPoint % l];
        var p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
          p3 = points[(intPoint + 2) % l];
        } else {
          tmp2.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
          p3 = tmp2;
        }
        if (this.curveType === "centripetal" || this.curveType === "chordal") {
          var pow = this.curveType === "chordal" ? 0.5 : 0.25;
          var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
          if (dt1 < 1e-4)
            dt1 = 1;
          if (dt0 < 1e-4)
            dt0 = dt1;
          if (dt2 < 1e-4)
            dt2 = dt1;
          px2.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py2.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz2.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === "catmullrom") {
          px2.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
          py2.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
          pz2.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px2.calc(weight), py2.calc(weight), pz2.calc(weight));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i2 = 0, l = source.points.length; i2 < l; i2++) {
          var point = source.points[i2];
          this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i2 = 0, l = this.points.length; i2 < l; i2++) {
          var point = this.points[i2];
          data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i2 = 0, l = json.points.length; i2 < l; i2++) {
          var point = json.points[i2];
          this.points.push(new Vector32().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
      };
      return CatmullRomCurve33;
    }(Curve2);
    CatmullRomCurve32.prototype.isCatmullRomCurve3 = true;
    function CatmullRom2(t, p0, p1, p2, p3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t2 = t * t;
      var t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP02(t, p) {
      var k = 1 - t;
      return k * k * p;
    }
    function QuadraticBezierP12(t, p) {
      return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP22(t, p) {
      return t * t * p;
    }
    function QuadraticBezier2(t, p0, p1, p2) {
      return QuadraticBezierP02(t, p0) + QuadraticBezierP12(t, p1) + QuadraticBezierP22(t, p2);
    }
    function CubicBezierP02(t, p) {
      var k = 1 - t;
      return k * k * k * p;
    }
    function CubicBezierP12(t, p) {
      var k = 1 - t;
      return 3 * k * k * t * p;
    }
    function CubicBezierP22(t, p) {
      return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP32(t, p) {
      return t * t * t * p;
    }
    function CubicBezier2(t, p0, p1, p2, p3) {
      return CubicBezierP02(t, p0) + CubicBezierP12(t, p1) + CubicBezierP22(t, p2) + CubicBezierP32(t, p3);
    }
    var CubicBezierCurve2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(CubicBezierCurve4, _Curve);
      function CubicBezierCurve4(v0, v1, v2, v3) {
        var _this;
        if (v0 === void 0) {
          v0 = new Vector22();
        }
        if (v1 === void 0) {
          v1 = new Vector22();
        }
        if (v2 === void 0) {
          v2 = new Vector22();
        }
        if (v3 === void 0) {
          v3 = new Vector22();
        }
        _this = _Curve.call(this) || this;
        _this.type = "CubicBezierCurve";
        _this.v0 = v0;
        _this.v1 = v1;
        _this.v2 = v2;
        _this.v3 = v3;
        return _this;
      }
      var _proto = CubicBezierCurve4.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector22();
        }
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier2(t, v0.x, v1.x, v2.x, v3.x), CubicBezier2(t, v0.y, v1.y, v2.y, v3.y));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      };
      return CubicBezierCurve4;
    }(Curve2);
    CubicBezierCurve2.prototype.isCubicBezierCurve = true;
    var CubicBezierCurve32 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(CubicBezierCurve33, _Curve);
      function CubicBezierCurve33(v0, v1, v2, v3) {
        var _this;
        if (v0 === void 0) {
          v0 = new Vector32();
        }
        if (v1 === void 0) {
          v1 = new Vector32();
        }
        if (v2 === void 0) {
          v2 = new Vector32();
        }
        if (v3 === void 0) {
          v3 = new Vector32();
        }
        _this = _Curve.call(this) || this;
        _this.type = "CubicBezierCurve3";
        _this.v0 = v0;
        _this.v1 = v1;
        _this.v2 = v2;
        _this.v3 = v3;
        return _this;
      }
      var _proto = CubicBezierCurve33.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector32();
        }
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier2(t, v0.x, v1.x, v2.x, v3.x), CubicBezier2(t, v0.y, v1.y, v2.y, v3.y), CubicBezier2(t, v0.z, v1.z, v2.z, v3.z));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      };
      return CubicBezierCurve33;
    }(Curve2);
    CubicBezierCurve32.prototype.isCubicBezierCurve3 = true;
    var LineCurve2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(LineCurve4, _Curve);
      function LineCurve4(v1, v2) {
        var _this;
        if (v1 === void 0) {
          v1 = new Vector22();
        }
        if (v2 === void 0) {
          v2 = new Vector22();
        }
        _this = _Curve.call(this) || this;
        _this.type = "LineCurve";
        _this.v1 = v1;
        _this.v2 = v2;
        return _this;
      }
      var _proto = LineCurve4.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector22();
        }
        var point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      };
      _proto.getPointAt = function getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      };
      _proto.getTangent = function getTangent(t, optionalTarget) {
        var tangent = optionalTarget || new Vector22();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      };
      return LineCurve4;
    }(Curve2);
    LineCurve2.prototype.isLineCurve = true;
    var LineCurve32 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(LineCurve33, _Curve);
      function LineCurve33(v1, v2) {
        var _this;
        if (v1 === void 0) {
          v1 = new Vector32();
        }
        if (v2 === void 0) {
          v2 = new Vector32();
        }
        _this = _Curve.call(this) || this;
        _this.type = "LineCurve3";
        _this.isLineCurve3 = true;
        _this.v1 = v1;
        _this.v2 = v2;
        return _this;
      }
      var _proto = LineCurve33.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector32();
        }
        var point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      };
      _proto.getPointAt = function getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      };
      return LineCurve33;
    }(Curve2);
    var QuadraticBezierCurve2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(QuadraticBezierCurve4, _Curve);
      function QuadraticBezierCurve4(v0, v1, v2) {
        var _this;
        if (v0 === void 0) {
          v0 = new Vector22();
        }
        if (v1 === void 0) {
          v1 = new Vector22();
        }
        if (v2 === void 0) {
          v2 = new Vector22();
        }
        _this = _Curve.call(this) || this;
        _this.type = "QuadraticBezierCurve";
        _this.v0 = v0;
        _this.v1 = v1;
        _this.v2 = v2;
        return _this;
      }
      var _proto = QuadraticBezierCurve4.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector22();
        }
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier2(t, v0.x, v1.x, v2.x), QuadraticBezier2(t, v0.y, v1.y, v2.y));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      };
      return QuadraticBezierCurve4;
    }(Curve2);
    QuadraticBezierCurve2.prototype.isQuadraticBezierCurve = true;
    var QuadraticBezierCurve32 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(QuadraticBezierCurve33, _Curve);
      function QuadraticBezierCurve33(v0, v1, v2) {
        var _this;
        if (v0 === void 0) {
          v0 = new Vector32();
        }
        if (v1 === void 0) {
          v1 = new Vector32();
        }
        if (v2 === void 0) {
          v2 = new Vector32();
        }
        _this = _Curve.call(this) || this;
        _this.type = "QuadraticBezierCurve3";
        _this.v0 = v0;
        _this.v1 = v1;
        _this.v2 = v2;
        return _this;
      }
      var _proto = QuadraticBezierCurve33.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector32();
        }
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier2(t, v0.x, v1.x, v2.x), QuadraticBezier2(t, v0.y, v1.y, v2.y), QuadraticBezier2(t, v0.z, v1.z, v2.z));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      };
      return QuadraticBezierCurve33;
    }(Curve2);
    QuadraticBezierCurve32.prototype.isQuadraticBezierCurve3 = true;
    var SplineCurve2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(SplineCurve3, _Curve);
      function SplineCurve3(points) {
        var _this;
        if (points === void 0) {
          points = [];
        }
        _this = _Curve.call(this) || this;
        _this.type = "SplineCurve";
        _this.points = points;
        return _this;
      }
      var _proto = SplineCurve3.prototype;
      _proto.getPoint = function getPoint(t, optionalTarget) {
        if (optionalTarget === void 0) {
          optionalTarget = new Vector22();
        }
        var point = optionalTarget;
        var points = this.points;
        var p = (points.length - 1) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var p1 = points[intPoint];
        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom2(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom2(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i2 = 0, l = source.points.length; i2 < l; i2++) {
          var point = source.points[i2];
          this.points.push(point.clone());
        }
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i2 = 0, l = this.points.length; i2 < l; i2++) {
          var point = this.points[i2];
          data.points.push(point.toArray());
        }
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i2 = 0, l = json.points.length; i2 < l; i2++) {
          var point = json.points[i2];
          this.points.push(new Vector22().fromArray(point));
        }
        return this;
      };
      return SplineCurve3;
    }(Curve2);
    SplineCurve2.prototype.isSplineCurve = true;
    var Curves2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArcCurve: ArcCurve2,
      CatmullRomCurve3: CatmullRomCurve32,
      CubicBezierCurve: CubicBezierCurve2,
      CubicBezierCurve3: CubicBezierCurve32,
      EllipseCurve: EllipseCurve2,
      LineCurve: LineCurve2,
      LineCurve3: LineCurve32,
      QuadraticBezierCurve: QuadraticBezierCurve2,
      QuadraticBezierCurve3: QuadraticBezierCurve32,
      SplineCurve: SplineCurve2
    });
    var CurvePath2 = /* @__PURE__ */ function(_Curve) {
      _inheritsLoose(CurvePath3, _Curve);
      function CurvePath3() {
        var _this;
        _this = _Curve.call(this) || this;
        _this.type = "CurvePath";
        _this.curves = [];
        _this.autoClose = false;
        return _this;
      }
      var _proto = CurvePath3.prototype;
      _proto.add = function add(curve) {
        this.curves.push(curve);
      };
      _proto.closePath = function closePath() {
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          this.curves.push(new LineCurve2(endPoint, startPoint));
        }
      };
      _proto.getPoint = function getPoint(t) {
        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i2 = 0;
        while (i2 < curveLengths.length) {
          if (curveLengths[i2] >= d) {
            var diff = curveLengths[i2] - d;
            var curve = this.curves[i2];
            var segmentLength = curve.getLength();
            var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u);
          }
          i2++;
        }
        return null;
      };
      _proto.getLength = function getLength() {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
      };
      _proto.updateArcLengths = function updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      };
      _proto.getCurveLengths = function getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        var lengths = [];
        var sums = 0;
        for (var i2 = 0, l = this.curves.length; i2 < l; i2++) {
          sums += this.curves[i2].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      };
      _proto.getSpacedPoints = function getSpacedPoints(divisions) {
        if (divisions === void 0) {
          divisions = 40;
        }
        var points = [];
        for (var i2 = 0; i2 <= divisions; i2++) {
          points.push(this.getPoint(i2 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      };
      _proto.getPoints = function getPoints(divisions) {
        if (divisions === void 0) {
          divisions = 12;
        }
        var points = [];
        var last;
        for (var i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
          var curve = curves[i2];
          var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
          var pts = curve.getPoints(resolution);
          for (var j = 0; j < pts.length; j++) {
            var point = pts[j];
            if (last && last.equals(point))
              continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      };
      _proto.copy = function copy(source) {
        _Curve.prototype.copy.call(this, source);
        this.curves = [];
        for (var i2 = 0, l = source.curves.length; i2 < l; i2++) {
          var curve = source.curves[i2];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for (var i2 = 0, l = this.curves.length; i2 < l; i2++) {
          var curve = this.curves[i2];
          data.curves.push(curve.toJSON());
        }
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (var i2 = 0, l = json.curves.length; i2 < l; i2++) {
          var curve = json.curves[i2];
          this.curves.push(new Curves2[curve.type]().fromJSON(curve));
        }
        return this;
      };
      return CurvePath3;
    }(Curve2);
    var Path2 = /* @__PURE__ */ function(_CurvePath) {
      _inheritsLoose(Path3, _CurvePath);
      function Path3(points) {
        var _this;
        _this = _CurvePath.call(this) || this;
        _this.type = "Path";
        _this.currentPoint = new Vector22();
        if (points) {
          _this.setFromPoints(points);
        }
        return _this;
      }
      var _proto = Path3.prototype;
      _proto.setFromPoints = function setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for (var i2 = 1, l = points.length; i2 < l; i2++) {
          this.lineTo(points[i2].x, points[i2].y);
        }
        return this;
      };
      _proto.moveTo = function moveTo(x, y) {
        this.currentPoint.set(x, y);
        return this;
      };
      _proto.lineTo = function lineTo(x, y) {
        var curve = new LineCurve2(this.currentPoint.clone(), new Vector22(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
      };
      _proto.quadraticCurveTo = function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve2(this.currentPoint.clone(), new Vector22(aCPx, aCPy), new Vector22(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      };
      _proto.bezierCurveTo = function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve2(this.currentPoint.clone(), new Vector22(aCP1x, aCP1y), new Vector22(aCP2x, aCP2y), new Vector22(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      };
      _proto.splineThru = function splineThru(pts) {
        var npts = [this.currentPoint.clone()].concat(pts);
        var curve = new SplineCurve2(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      };
      _proto.arc = function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      };
      _proto.absarc = function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      };
      _proto.ellipse = function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      };
      _proto.absellipse = function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve2(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          var firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      };
      _proto.copy = function copy(source) {
        _CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      };
      return Path3;
    }(CurvePath2);
    var Shape2 = /* @__PURE__ */ function(_Path) {
      _inheritsLoose(Shape3, _Path);
      function Shape3(points) {
        var _this;
        _this = _Path.call(this, points) || this;
        _this.uuid = MathUtils2.generateUUID();
        _this.type = "Shape";
        _this.holes = [];
        return _this;
      }
      var _proto = Shape3.prototype;
      _proto.getPointsHoles = function getPointsHoles(divisions) {
        var holesPts = [];
        for (var i2 = 0, l = this.holes.length; i2 < l; i2++) {
          holesPts[i2] = this.holes[i2].getPoints(divisions);
        }
        return holesPts;
      };
      _proto.extractPoints = function extractPoints(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      };
      _proto.copy = function copy(source) {
        _Path.prototype.copy.call(this, source);
        this.holes = [];
        for (var i2 = 0, l = source.holes.length; i2 < l; i2++) {
          var hole = source.holes[i2];
          this.holes.push(hole.clone());
        }
        return this;
      };
      _proto.toJSON = function toJSON2() {
        var data = _Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for (var i2 = 0, l = this.holes.length; i2 < l; i2++) {
          var hole = this.holes[i2];
          data.holes.push(hole.toJSON());
        }
        return data;
      };
      _proto.fromJSON = function fromJSON(json) {
        _Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for (var i2 = 0, l = json.holes.length; i2 < l; i2++) {
          var hole = json.holes[i2];
          this.holes.push(new Path2().fromJSON(hole));
        }
        return this;
      };
      return Shape3;
    }(Path2);
    var Light2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(Light3, _Object3D);
      function Light3(color, intensity) {
        var _this;
        if (intensity === void 0) {
          intensity = 1;
        }
        _this = _Object3D.call(this) || this;
        _this.type = "Light";
        _this.color = new Color5(color);
        _this.intensity = intensity;
        return _this;
      }
      var _proto = Light3.prototype;
      _proto.copy = function copy(source) {
        _Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = _Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      };
      return Light3;
    }(Object3D2);
    Light2.prototype.isLight = true;
    var HemisphereLight2 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(HemisphereLight3, _Light);
      function HemisphereLight3(skyColor, groundColor, intensity) {
        var _this;
        _this = _Light.call(this, skyColor, intensity) || this;
        _this.type = "HemisphereLight";
        _this.position.copy(Object3D2.DefaultUp);
        _this.updateMatrix();
        _this.groundColor = new Color5(groundColor);
        return _this;
      }
      var _proto = HemisphereLight3.prototype;
      _proto.copy = function copy(source) {
        Light2.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
      };
      return HemisphereLight3;
    }(Light2);
    HemisphereLight2.prototype.isHemisphereLight = true;
    var _projScreenMatrix2 = /* @__PURE__ */ new Matrix43();
    var _lightPositionWorld2 = /* @__PURE__ */ new Vector32();
    var _lookTarget2 = /* @__PURE__ */ new Vector32();
    var LightShadow2 = /* @__PURE__ */ function() {
      function LightShadow3(camera2) {
        this.camera = camera2;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.mapSize = new Vector22(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix43();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum2();
        this._frameExtents = new Vector22(1, 1);
        this._viewportCount = 1;
        this._viewports = [new Vector42(0, 0, 1, 1)];
      }
      var _proto = LightShadow3.prototype;
      _proto.getViewportCount = function getViewportCount() {
        return this._viewportCount;
      };
      _proto.getFrustum = function getFrustum() {
        return this._frustum;
      };
      _proto.updateMatrices = function updateMatrices(light) {
        var shadowCamera = this.camera;
        var shadowMatrix = this.matrix;
        _lightPositionWorld2.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld2);
        _lookTarget2.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget2);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix2.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix2);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      };
      _proto.getViewport = function getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      };
      _proto.getFrameExtents = function getFrameExtents() {
        return this._frameExtents;
      };
      _proto.copy = function copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.toJSON = function toJSON2() {
        var object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.normalBias !== 0)
          object.normalBias = this.normalBias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      };
      return LightShadow3;
    }();
    var SpotLightShadow2 = /* @__PURE__ */ function(_LightShadow) {
      _inheritsLoose(SpotLightShadow3, _LightShadow);
      function SpotLightShadow3() {
        var _this;
        _this = _LightShadow.call(this, new PerspectiveCamera3(50, 1, 0.5, 500)) || this;
        _this.focus = 1;
        return _this;
      }
      var _proto = SpotLightShadow3.prototype;
      _proto.updateMatrices = function updateMatrices(light) {
        var camera2 = this.camera;
        var fov3 = MathUtils2.RAD2DEG * 2 * light.angle * this.focus;
        var aspect3 = this.mapSize.width / this.mapSize.height;
        var far = light.distance || camera2.far;
        if (fov3 !== camera2.fov || aspect3 !== camera2.aspect || far !== camera2.far) {
          camera2.fov = fov3;
          camera2.aspect = aspect3;
          camera2.far = far;
          camera2.updateProjectionMatrix();
        }
        _LightShadow.prototype.updateMatrices.call(this, light);
      };
      return SpotLightShadow3;
    }(LightShadow2);
    SpotLightShadow2.prototype.isSpotLightShadow = true;
    var SpotLight2 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(SpotLight3, _Light);
      function SpotLight3(color, intensity, distance, angle, penumbra, decay) {
        var _this;
        if (distance === void 0) {
          distance = 0;
        }
        if (angle === void 0) {
          angle = Math.PI / 3;
        }
        if (penumbra === void 0) {
          penumbra = 0;
        }
        if (decay === void 0) {
          decay = 1;
        }
        _this = _Light.call(this, color, intensity) || this;
        _this.type = "SpotLight";
        _this.position.copy(Object3D2.DefaultUp);
        _this.updateMatrix();
        _this.target = new Object3D2();
        _this.distance = distance;
        _this.angle = angle;
        _this.penumbra = penumbra;
        _this.decay = decay;
        _this.shadow = new SpotLightShadow2();
        return _this;
      }
      var _proto = SpotLight3.prototype;
      _proto.copy = function copy(source) {
        _Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      };
      _createClass(SpotLight3, [{
        key: "power",
        get: function get() {
          return this.intensity * Math.PI;
        },
        set: function set(power) {
          this.intensity = power / Math.PI;
        }
      }]);
      return SpotLight3;
    }(Light2);
    SpotLight2.prototype.isSpotLight = true;
    var _projScreenMatrix$12 = /* @__PURE__ */ new Matrix43();
    var _lightPositionWorld$12 = /* @__PURE__ */ new Vector32();
    var _lookTarget$12 = /* @__PURE__ */ new Vector32();
    var PointLightShadow2 = /* @__PURE__ */ function(_LightShadow) {
      _inheritsLoose(PointLightShadow3, _LightShadow);
      function PointLightShadow3() {
        var _this;
        _this = _LightShadow.call(this, new PerspectiveCamera3(90, 1, 0.5, 500)) || this;
        _this._frameExtents = new Vector22(4, 2);
        _this._viewportCount = 6;
        _this._viewports = [
          new Vector42(2, 1, 1, 1),
          new Vector42(0, 1, 1, 1),
          new Vector42(3, 1, 1, 1),
          new Vector42(1, 1, 1, 1),
          new Vector42(3, 0, 1, 1),
          new Vector42(1, 0, 1, 1)
        ];
        _this._cubeDirections = [new Vector32(1, 0, 0), new Vector32(-1, 0, 0), new Vector32(0, 0, 1), new Vector32(0, 0, -1), new Vector32(0, 1, 0), new Vector32(0, -1, 0)];
        _this._cubeUps = [new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 0, 1), new Vector32(0, 0, -1)];
        return _this;
      }
      var _proto = PointLightShadow3.prototype;
      _proto.updateMatrices = function updateMatrices(light, viewportIndex) {
        if (viewportIndex === void 0) {
          viewportIndex = 0;
        }
        var camera2 = this.camera;
        var shadowMatrix = this.matrix;
        _lightPositionWorld$12.setFromMatrixPosition(light.matrixWorld);
        camera2.position.copy(_lightPositionWorld$12);
        _lookTarget$12.copy(camera2.position);
        _lookTarget$12.add(this._cubeDirections[viewportIndex]);
        camera2.up.copy(this._cubeUps[viewportIndex]);
        camera2.lookAt(_lookTarget$12);
        camera2.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld$12.x, -_lightPositionWorld$12.y, -_lightPositionWorld$12.z);
        _projScreenMatrix$12.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$12);
      };
      return PointLightShadow3;
    }(LightShadow2);
    PointLightShadow2.prototype.isPointLightShadow = true;
    var PointLight2 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(PointLight3, _Light);
      function PointLight3(color, intensity, distance, decay) {
        var _this;
        if (distance === void 0) {
          distance = 0;
        }
        if (decay === void 0) {
          decay = 1;
        }
        _this = _Light.call(this, color, intensity) || this;
        _this.type = "PointLight";
        _this.distance = distance;
        _this.decay = decay;
        _this.shadow = new PointLightShadow2();
        return _this;
      }
      var _proto = PointLight3.prototype;
      _proto.copy = function copy(source) {
        _Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      };
      _createClass(PointLight3, [{
        key: "power",
        get: function get() {
          return this.intensity * 4 * Math.PI;
        },
        set: function set(power) {
          this.intensity = power / (4 * Math.PI);
        }
      }]);
      return PointLight3;
    }(Light2);
    PointLight2.prototype.isPointLight = true;
    var OrthographicCamera2 = /* @__PURE__ */ function(_Camera) {
      _inheritsLoose(OrthographicCamera3, _Camera);
      function OrthographicCamera3(left, right, top, bottom, near, far) {
        var _this;
        if (left === void 0) {
          left = -1;
        }
        if (right === void 0) {
          right = 1;
        }
        if (top === void 0) {
          top = 1;
        }
        if (bottom === void 0) {
          bottom = -1;
        }
        if (near === void 0) {
          near = 0.1;
        }
        if (far === void 0) {
          far = 2e3;
        }
        _this = _Camera.call(this) || this;
        _this.type = "OrthographicCamera";
        _this.zoom = 1;
        _this.view = null;
        _this.left = left;
        _this.right = right;
        _this.top = top;
        _this.bottom = bottom;
        _this.near = near;
        _this.far = far;
        _this.updateProjectionMatrix();
        return _this;
      }
      var _proto = OrthographicCamera3.prototype;
      _proto.copy = function copy(source, recursive) {
        _Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      };
      _proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      };
      _proto.clearViewOffset = function clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      };
      _proto.updateProjectionMatrix = function updateProjectionMatrix() {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = Object3D2.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      };
      return OrthographicCamera3;
    }(Camera2);
    OrthographicCamera2.prototype.isOrthographicCamera = true;
    var DirectionalLightShadow2 = /* @__PURE__ */ function(_LightShadow) {
      _inheritsLoose(DirectionalLightShadow3, _LightShadow);
      function DirectionalLightShadow3() {
        return _LightShadow.call(this, new OrthographicCamera2(-5, 5, 5, -5, 0.5, 500)) || this;
      }
      return DirectionalLightShadow3;
    }(LightShadow2);
    DirectionalLightShadow2.prototype.isDirectionalLightShadow = true;
    var DirectionalLight3 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(DirectionalLight4, _Light);
      function DirectionalLight4(color, intensity) {
        var _this;
        _this = _Light.call(this, color, intensity) || this;
        _this.type = "DirectionalLight";
        _this.position.copy(Object3D2.DefaultUp);
        _this.updateMatrix();
        _this.target = new Object3D2();
        _this.shadow = new DirectionalLightShadow2();
        return _this;
      }
      var _proto = DirectionalLight4.prototype;
      _proto.copy = function copy(source) {
        _Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      };
      return DirectionalLight4;
    }(Light2);
    DirectionalLight3.prototype.isDirectionalLight = true;
    var AmbientLight3 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(AmbientLight4, _Light);
      function AmbientLight4(color, intensity) {
        var _this;
        _this = _Light.call(this, color, intensity) || this;
        _this.type = "AmbientLight";
        return _this;
      }
      return AmbientLight4;
    }(Light2);
    AmbientLight3.prototype.isAmbientLight = true;
    var RectAreaLight2 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(RectAreaLight3, _Light);
      function RectAreaLight3(color, intensity, width, height) {
        var _this;
        if (width === void 0) {
          width = 10;
        }
        if (height === void 0) {
          height = 10;
        }
        _this = _Light.call(this, color, intensity) || this;
        _this.type = "RectAreaLight";
        _this.width = width;
        _this.height = height;
        return _this;
      }
      var _proto = RectAreaLight3.prototype;
      _proto.copy = function copy(source) {
        _Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = _Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      };
      return RectAreaLight3;
    }(Light2);
    RectAreaLight2.prototype.isRectAreaLight = true;
    var SphericalHarmonics32 = /* @__PURE__ */ function() {
      function SphericalHarmonics33() {
        this.coefficients = [];
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients.push(new Vector32());
        }
      }
      var _proto = SphericalHarmonics33.prototype;
      _proto.set = function set(coefficients) {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].copy(coefficients[i2]);
        }
        return this;
      };
      _proto.zero = function zero() {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].set(0, 0, 0);
        }
        return this;
      };
      _proto.getAt = function getAt(normal, target) {
        var x = normal.x, y = normal.y, z = normal.z;
        var coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
      };
      _proto.getIrradianceAt = function getIrradianceAt(normal, target) {
        var x = normal.x, y = normal.y, z = normal.z;
        var coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 2 * 0.511664 * y);
        target.addScaledVector(coeff[2], 2 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2 * 0.511664 * x);
        target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
        target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
        return target;
      };
      _proto.add = function add(sh) {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].add(sh.coefficients[i2]);
        }
        return this;
      };
      _proto.addScaledSH = function addScaledSH(sh, s) {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
        }
        return this;
      };
      _proto.scale = function scale(s) {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].multiplyScalar(s);
        }
        return this;
      };
      _proto.lerp = function lerp(sh, alpha) {
        for (var i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
        }
        return this;
      };
      _proto.equals = function equals3(sh) {
        for (var i2 = 0; i2 < 9; i2++) {
          if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
            return false;
          }
        }
        return true;
      };
      _proto.copy = function copy(sh) {
        return this.set(sh.coefficients);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.fromArray = function fromArray(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var coefficients = this.coefficients;
        for (var i2 = 0; i2 < 9; i2++) {
          coefficients[i2].fromArray(array, offset + i2 * 3);
        }
        return this;
      };
      _proto.toArray = function toArray(array, offset) {
        if (array === void 0) {
          array = [];
        }
        if (offset === void 0) {
          offset = 0;
        }
        var coefficients = this.coefficients;
        for (var i2 = 0; i2 < 9; i2++) {
          coefficients[i2].toArray(array, offset + i2 * 3);
        }
        return array;
      };
      SphericalHarmonics33.getBasisAt = function getBasisAt(normal, shBasis) {
        var x = normal.x, y = normal.y, z = normal.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
      };
      return SphericalHarmonics33;
    }();
    SphericalHarmonics32.prototype.isSphericalHarmonics3 = true;
    var LightProbe2 = /* @__PURE__ */ function(_Light) {
      _inheritsLoose(LightProbe3, _Light);
      function LightProbe3(sh, intensity) {
        var _this;
        if (sh === void 0) {
          sh = new SphericalHarmonics32();
        }
        if (intensity === void 0) {
          intensity = 1;
        }
        _this = _Light.call(this, void 0, intensity) || this;
        _this.sh = sh;
        return _this;
      }
      var _proto = LightProbe3.prototype;
      _proto.copy = function copy(source) {
        _Light.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
      };
      _proto.fromJSON = function fromJSON(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
      };
      _proto.toJSON = function toJSON2(meta) {
        var data = _Light.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
      };
      return LightProbe3;
    }(Light2);
    LightProbe2.prototype.isLightProbe = true;
    var MaterialLoader = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(MaterialLoader2, _Loader);
      function MaterialLoader2(manager) {
        var _this;
        _this = _Loader.call(this, manager) || this;
        _this.textures = {};
        return _this;
      }
      var _proto = MaterialLoader2.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader2(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      };
      _proto.parse = function parse(json) {
        var textures = this.textures;
        function getTexture(name3) {
          if (textures[name3] === void 0) {
            console.warn("THREE.MaterialLoader: Undefined texture", name3);
          }
          return textures[name3];
        }
        var material = new Materials[json.type]();
        if (json.uuid !== void 0)
          material.uuid = json.uuid;
        if (json.name !== void 0)
          material.name = json.name;
        if (json.color !== void 0 && material.color !== void 0)
          material.color.setHex(json.color);
        if (json.roughness !== void 0)
          material.roughness = json.roughness;
        if (json.metalness !== void 0)
          material.metalness = json.metalness;
        if (json.sheen !== void 0)
          material.sheen = new Color5().setHex(json.sheen);
        if (json.emissive !== void 0 && material.emissive !== void 0)
          material.emissive.setHex(json.emissive);
        if (json.specular !== void 0 && material.specular !== void 0)
          material.specular.setHex(json.specular);
        if (json.shininess !== void 0)
          material.shininess = json.shininess;
        if (json.clearcoat !== void 0)
          material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== void 0)
          material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== void 0)
          material.fog = json.fog;
        if (json.flatShading !== void 0)
          material.flatShading = json.flatShading;
        if (json.blending !== void 0)
          material.blending = json.blending;
        if (json.combine !== void 0)
          material.combine = json.combine;
        if (json.side !== void 0)
          material.side = json.side;
        if (json.opacity !== void 0)
          material.opacity = json.opacity;
        if (json.transparent !== void 0)
          material.transparent = json.transparent;
        if (json.alphaTest !== void 0)
          material.alphaTest = json.alphaTest;
        if (json.depthTest !== void 0)
          material.depthTest = json.depthTest;
        if (json.depthWrite !== void 0)
          material.depthWrite = json.depthWrite;
        if (json.colorWrite !== void 0)
          material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== void 0)
          material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== void 0)
          material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== void 0)
          material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== void 0)
          material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== void 0)
          material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== void 0)
          material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== void 0)
          material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== void 0)
          material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== void 0)
          material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== void 0)
          material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== void 0)
          material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== void 0)
          material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== void 0)
          material.rotation = json.rotation;
        if (json.linewidth !== 1)
          material.linewidth = json.linewidth;
        if (json.dashSize !== void 0)
          material.dashSize = json.dashSize;
        if (json.gapSize !== void 0)
          material.gapSize = json.gapSize;
        if (json.scale !== void 0)
          material.scale = json.scale;
        if (json.polygonOffset !== void 0)
          material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== void 0)
          material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== void 0)
          material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== void 0)
          material.skinning = json.skinning;
        if (json.morphTargets !== void 0)
          material.morphTargets = json.morphTargets;
        if (json.morphNormals !== void 0)
          material.morphNormals = json.morphNormals;
        if (json.dithering !== void 0)
          material.dithering = json.dithering;
        if (json.vertexTangents !== void 0)
          material.vertexTangents = json.vertexTangents;
        if (json.visible !== void 0)
          material.visible = json.visible;
        if (json.toneMapped !== void 0)
          material.toneMapped = json.toneMapped;
        if (json.userData !== void 0)
          material.userData = json.userData;
        if (json.vertexColors !== void 0) {
          if (typeof json.vertexColors === "number") {
            material.vertexColors = json.vertexColors > 0 ? true : false;
          } else {
            material.vertexColors = json.vertexColors;
          }
        }
        if (json.uniforms !== void 0) {
          for (var name2 in json.uniforms) {
            var uniform = json.uniforms[name2];
            material.uniforms[name2] = {};
            switch (uniform.type) {
              case "t":
                material.uniforms[name2].value = getTexture(uniform.value);
                break;
              case "c":
                material.uniforms[name2].value = new Color5().setHex(uniform.value);
                break;
              case "v2":
                material.uniforms[name2].value = new Vector22().fromArray(uniform.value);
                break;
              case "v3":
                material.uniforms[name2].value = new Vector32().fromArray(uniform.value);
                break;
              case "v4":
                material.uniforms[name2].value = new Vector42().fromArray(uniform.value);
                break;
              case "m3":
                material.uniforms[name2].value = new Matrix32().fromArray(uniform.value);
                break;
              case "m4":
                material.uniforms[name2].value = new Matrix43().fromArray(uniform.value);
                break;
              default:
                material.uniforms[name2].value = uniform.value;
            }
          }
        }
        if (json.defines !== void 0)
          material.defines = json.defines;
        if (json.vertexShader !== void 0)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== void 0)
          material.fragmentShader = json.fragmentShader;
        if (json.extensions !== void 0) {
          for (var key in json.extensions) {
            material.extensions[key] = json.extensions[key];
          }
        }
        if (json.shading !== void 0)
          material.flatShading = json.shading === 1;
        if (json.size !== void 0)
          material.size = json.size;
        if (json.sizeAttenuation !== void 0)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== void 0)
          material.map = getTexture(json.map);
        if (json.matcap !== void 0)
          material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== void 0)
          material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== void 0)
          material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== void 0)
          material.bumpScale = json.bumpScale;
        if (json.normalMap !== void 0)
          material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== void 0)
          material.normalMapType = json.normalMapType;
        if (json.normalScale !== void 0) {
          var normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            normalScale = [normalScale, normalScale];
          }
          material.normalScale = new Vector22().fromArray(normalScale);
        }
        if (json.displacementMap !== void 0)
          material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== void 0)
          material.displacementScale = json.displacementScale;
        if (json.displacementBias !== void 0)
          material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== void 0)
          material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== void 0)
          material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== void 0)
          material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== void 0)
          material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== void 0)
          material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== void 0)
          material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== void 0)
          material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== void 0)
          material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== void 0)
          material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== void 0)
          material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== void 0)
          material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== void 0)
          material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== void 0)
          material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== void 0)
          material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== void 0)
          material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== void 0)
          material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== void 0)
          material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== void 0)
          material.clearcoatNormalScale = new Vector22().fromArray(json.clearcoatNormalScale);
        if (json.transmission !== void 0)
          material.transmission = json.transmission;
        if (json.transmissionMap !== void 0)
          material.transmissionMap = getTexture(json.transmissionMap);
        return material;
      };
      _proto.setTextures = function setTextures(value) {
        this.textures = value;
        return this;
      };
      return MaterialLoader2;
    }(Loader2);
    var LoaderUtils2 = {
      decodeText: function decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        var s = "";
        for (var i2 = 0, il = array.length; i2 < il; i2++) {
          s += String.fromCharCode(array[i2]);
        }
        try {
          return decodeURIComponent(escape(s));
        } catch (e) {
          return s;
        }
      },
      extractUrlBase: function extractUrlBase(url) {
        var index = url.lastIndexOf("/");
        if (index === -1)
          return "./";
        return url.substr(0, index + 1);
      }
    };
    function InstancedBufferGeometry2() {
      BufferGeometry3.call(this);
      this.type = "InstancedBufferGeometry";
      this.instanceCount = Infinity;
    }
    InstancedBufferGeometry2.prototype = Object.assign(Object.create(BufferGeometry3.prototype), {
      constructor: InstancedBufferGeometry2,
      isInstancedBufferGeometry: true,
      copy: function copy(source) {
        BufferGeometry3.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
      },
      clone: function clone() {
        return new this.constructor().copy(this);
      },
      toJSON: function toJSON2() {
        var data = BufferGeometry3.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    });
    function InstancedBufferAttribute2(array, itemSize, normalized, meshPerAttribute) {
      if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
      }
      BufferAttribute3.call(this, array, itemSize, normalized);
      this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute2.prototype = Object.assign(Object.create(BufferAttribute3.prototype), {
      constructor: InstancedBufferAttribute2,
      isInstancedBufferAttribute: true,
      copy: function copy(source) {
        BufferAttribute3.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      },
      toJSON: function toJSON2() {
        var data = BufferAttribute3.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    });
    var BufferGeometryLoader = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(BufferGeometryLoader2, _Loader);
      function BufferGeometryLoader2(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = BufferGeometryLoader2.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader2(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      };
      _proto.parse = function parse(json) {
        var interleavedBufferMap = {};
        var arrayBufferMap = {};
        function getInterleavedBuffer(json2, uuid) {
          if (interleavedBufferMap[uuid] !== void 0)
            return interleavedBufferMap[uuid];
          var interleavedBuffers = json2.interleavedBuffers;
          var interleavedBuffer2 = interleavedBuffers[uuid];
          var buffer = getArrayBuffer(json2, interleavedBuffer2.buffer);
          var array2 = getTypedArray(interleavedBuffer2.type, buffer);
          var ib = new InterleavedBuffer3(array2, interleavedBuffer2.stride);
          ib.uuid = interleavedBuffer2.uuid;
          interleavedBufferMap[uuid] = ib;
          return ib;
        }
        function getArrayBuffer(json2, uuid) {
          if (arrayBufferMap[uuid] !== void 0)
            return arrayBufferMap[uuid];
          var arrayBuffers = json2.arrayBuffers;
          var arrayBuffer = arrayBuffers[uuid];
          var ab = new Uint32Array(arrayBuffer).buffer;
          arrayBufferMap[uuid] = ab;
          return ab;
        }
        var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry2() : new BufferGeometry3();
        var index = json.data.index;
        if (index !== void 0) {
          var typedArray = getTypedArray(index.type, index.array);
          geometry.setIndex(new BufferAttribute3(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var bufferAttribute = void 0;
          if (attribute.isInterleavedBufferAttribute) {
            var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute3(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            var _typedArray = getTypedArray(attribute.type, attribute.array);
            var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute2 : BufferAttribute3;
            bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          geometry.setAttribute(key, bufferAttribute);
        }
        var morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (var _key in morphAttributes) {
            var attributeArray = morphAttributes[_key];
            var array = [];
            for (var i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              var _attribute = attributeArray[i2];
              var _bufferAttribute = void 0;
              if (_attribute.isInterleavedBufferAttribute) {
                var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute.data);
                _bufferAttribute = new InterleavedBufferAttribute3(_interleavedBuffer, _attribute.itemSize, _attribute.offset, _attribute.normalized);
              } else {
                var _typedArray2 = getTypedArray(_attribute.type, _attribute.array);
                _bufferAttribute = new BufferAttribute3(_typedArray2, _attribute.itemSize, _attribute.normalized);
              }
              if (_attribute.name !== void 0)
                _bufferAttribute.name = _attribute.name;
              array.push(_bufferAttribute);
            }
            geometry.morphAttributes[_key] = array;
          }
        }
        var morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== void 0) {
          for (var _i = 0, n = groups.length; _i !== n; ++_i) {
            var group = groups[_i];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== void 0) {
          var center = new Vector32();
          if (boundingSphere.center !== void 0) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere2(center, boundingSphere.radius);
        }
        if (json.name)
          geometry.name = json.name;
        if (json.userData)
          geometry.userData = json.userData;
        return geometry;
      };
      return BufferGeometryLoader2;
    }(Loader2);
    var ObjectLoader = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(ObjectLoader2, _Loader);
      function ObjectLoader2(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = ObjectLoader2.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === "" ? LoaderUtils2.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          var json = null;
          try {
            json = JSON.parse(text);
          } catch (error) {
            if (onError !== void 0)
              onError(error);
            console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
            return;
          }
          var metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            console.error("THREE.ObjectLoader: Can't load " + url);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      };
      _proto.parse = function parse(json, onLoad) {
        var animations = this.parseAnimations(json.animations);
        var shapes = this.parseShapes(json.shapes);
        var geometries = this.parseGeometries(json.geometries, shapes);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== void 0)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials, animations);
        var skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        if (onLoad !== void 0) {
          var hasImages = false;
          for (var uuid in images) {
            if (images[uuid] instanceof HTMLImageElement) {
              hasImages = true;
              break;
            }
          }
          if (hasImages === false)
            onLoad(object);
        }
        return object;
      };
      _proto.parseShapes = function parseShapes(json) {
        var shapes = {};
        if (json !== void 0) {
          for (var i2 = 0, l = json.length; i2 < l; i2++) {
            var shape = new Shape2().fromJSON(json[i2]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      };
      _proto.parseSkeletons = function parseSkeletons(json, object) {
        var skeletons = {};
        var bones = {};
        object.traverse(function(child) {
          if (child.isBone)
            bones[child.uuid] = child;
        });
        if (json !== void 0) {
          for (var i2 = 0, l = json.length; i2 < l; i2++) {
            var skeleton = new Skeleton2().fromJSON(json[i2], bones);
            skeletons[skeleton.uuid] = skeleton;
          }
        }
        return skeletons;
      };
      _proto.parseGeometries = function parseGeometries(json, shapes) {
        var geometries = {};
        var geometryShapes;
        if (json !== void 0) {
          var bufferGeometryLoader = new BufferGeometryLoader();
          for (var i2 = 0, l = json.length; i2 < l; i2++) {
            var geometry = void 0;
            var data = json[i2];
            switch (data.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
                geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                geometry = new Geometries[data.type](new Curves2[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                geometryShapes = [];
                for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                  var shape = shapes[data.shapes[j]];
                  geometryShapes.push(shape);
                }
                geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                geometryShapes = [];
                for (var _j = 0, _jl = data.shapes.length; _j < _jl; _j++) {
                  var _shape = shapes[data.shapes[_j]];
                  geometryShapes.push(_shape);
                }
                var extrudePath = data.options.extrudePath;
                if (extrudePath !== void 0) {
                  data.options.extrudePath = new Curves2[extrudePath.type]().fromJSON(extrudePath);
                }
                geometry = new Geometries[data.type](geometryShapes, data.options);
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                geometry = bufferGeometryLoader.parse(data);
                break;
              case "Geometry":
                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                continue;
            }
            geometry.uuid = data.uuid;
            if (data.name !== void 0)
              geometry.name = data.name;
            if (geometry.isBufferGeometry === true && data.userData !== void 0)
              geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      };
      _proto.parseMaterials = function parseMaterials(json, textures) {
        var cache = {};
        var materials = {};
        if (json !== void 0) {
          var loader = new MaterialLoader();
          loader.setTextures(textures);
          for (var i2 = 0, l = json.length; i2 < l; i2++) {
            var data = json[i2];
            if (data.type === "MultiMaterial") {
              var array = [];
              for (var j = 0; j < data.materials.length; j++) {
                var material = data.materials[j];
                if (cache[material.uuid] === void 0) {
                  cache[material.uuid] = loader.parse(material);
                }
                array.push(cache[material.uuid]);
              }
              materials[data.uuid] = array;
            } else {
              if (cache[data.uuid] === void 0) {
                cache[data.uuid] = loader.parse(data);
              }
              materials[data.uuid] = cache[data.uuid];
            }
          }
        }
        return materials;
      };
      _proto.parseAnimations = function parseAnimations(json) {
        var animations = {};
        if (json !== void 0) {
          for (var i2 = 0; i2 < json.length; i2++) {
            var data = json[i2];
            var clip = AnimationClip2.parse(data);
            animations[clip.uuid] = clip;
          }
        }
        return animations;
      };
      _proto.parseImages = function parseImages(json, onLoad) {
        var scope = this;
        var images = {};
        var loader;
        function loadImage(url2) {
          scope.manager.itemStart(url2);
          return loader.load(url2, function() {
            scope.manager.itemEnd(url2);
          }, void 0, function() {
            scope.manager.itemError(url2);
            scope.manager.itemEnd(url2);
          });
        }
        function deserializeImage(image2) {
          if (typeof image2 === "string") {
            var url2 = image2;
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url2) ? url2 : scope.resourcePath + url2;
            return loadImage(path);
          } else {
            if (image2.data) {
              return {
                data: getTypedArray(image2.type, image2.data),
                width: image2.width,
                height: image2.height
              };
            } else {
              return null;
            }
          }
        }
        if (json !== void 0 && json.length > 0) {
          var manager = new LoadingManager2(onLoad);
          loader = new ImageLoader2(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (var i2 = 0, il = json.length; i2 < il; i2++) {
            var image = json[i2];
            var url = image.url;
            if (Array.isArray(url)) {
              images[image.uuid] = [];
              for (var j = 0, jl = url.length; j < jl; j++) {
                var currentUrl = url[j];
                var deserializedImage = deserializeImage(currentUrl);
                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    images[image.uuid].push(deserializedImage);
                  } else {
                    images[image.uuid].push(new DataTexture2(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }
              }
            } else {
              var _deserializedImage = deserializeImage(image.url);
              if (_deserializedImage !== null) {
                images[image.uuid] = _deserializedImage;
              }
            }
          }
        }
        return images;
      };
      _proto.parseTextures = function parseTextures(json, images) {
        function parseConstant(value, type) {
          if (typeof value === "number")
            return value;
          console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
          return type[value];
        }
        var textures = {};
        if (json !== void 0) {
          for (var i2 = 0, l = json.length; i2 < l; i2++) {
            var data = json[i2];
            if (data.image === void 0) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined image", data.image);
            }
            var texture = void 0;
            var image = images[data.image];
            if (Array.isArray(image)) {
              texture = new CubeTexture2(image);
              if (image.length === 6)
                texture.needsUpdate = true;
            } else {
              if (image && image.data) {
                texture = new DataTexture2(image.data, image.width, image.height);
              } else {
                texture = new Texture2(image);
              }
              if (image)
                texture.needsUpdate = true;
            }
            texture.uuid = data.uuid;
            if (data.name !== void 0)
              texture.name = data.name;
            if (data.mapping !== void 0)
              texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== void 0)
              texture.offset.fromArray(data.offset);
            if (data.repeat !== void 0)
              texture.repeat.fromArray(data.repeat);
            if (data.center !== void 0)
              texture.center.fromArray(data.center);
            if (data.rotation !== void 0)
              texture.rotation = data.rotation;
            if (data.wrap !== void 0) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== void 0)
              texture.format = data.format;
            if (data.type !== void 0)
              texture.type = data.type;
            if (data.encoding !== void 0)
              texture.encoding = data.encoding;
            if (data.minFilter !== void 0)
              texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== void 0)
              texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== void 0)
              texture.anisotropy = data.anisotropy;
            if (data.flipY !== void 0)
              texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== void 0)
              texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== void 0)
              texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      };
      _proto.parseObject = function parseObject(data, geometries, materials, animations) {
        var object;
        function getGeometry(name2) {
          if (geometries[name2] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined geometry", name2);
          }
          return geometries[name2];
        }
        function getMaterial(name2) {
          if (name2 === void 0)
            return void 0;
          if (Array.isArray(name2)) {
            var array = [];
            for (var i3 = 0, l2 = name2.length; i3 < l2; i3++) {
              var uuid2 = name2[i3];
              if (materials[uuid2] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined material", uuid2);
              }
              array.push(materials[uuid2]);
            }
            return array;
          }
          if (materials[name2] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", name2);
          }
          return materials[name2];
        }
        var geometry, material;
        switch (data.type) {
          case "Scene":
            object = new Scene3();
            if (data.background !== void 0) {
              if (Number.isInteger(data.background)) {
                object.background = new Color5(data.background);
              }
            }
            if (data.fog !== void 0) {
              if (data.fog.type === "Fog") {
                object.fog = new Fog2(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === "FogExp2") {
                object.fog = new FogExp22(data.fog.color, data.fog.density);
              }
            }
            break;
          case "PerspectiveCamera":
            object = new PerspectiveCamera3(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== void 0)
              object.focus = data.focus;
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.filmGauge !== void 0)
              object.filmGauge = data.filmGauge;
            if (data.filmOffset !== void 0)
              object.filmOffset = data.filmOffset;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "OrthographicCamera":
            object = new OrthographicCamera2(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "AmbientLight":
            object = new AmbientLight3(data.color, data.intensity);
            break;
          case "DirectionalLight":
            object = new DirectionalLight3(data.color, data.intensity);
            break;
          case "PointLight":
            object = new PointLight2(data.color, data.intensity, data.distance, data.decay);
            break;
          case "RectAreaLight":
            object = new RectAreaLight2(data.color, data.intensity, data.width, data.height);
            break;
          case "SpotLight":
            object = new SpotLight2(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            break;
          case "HemisphereLight":
            object = new HemisphereLight2(data.color, data.groundColor, data.intensity);
            break;
          case "LightProbe":
            object = new LightProbe2().fromJSON(data);
            break;
          case "SkinnedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new SkinnedMesh2(geometry, material);
            if (data.bindMode !== void 0)
              object.bindMode = data.bindMode;
            if (data.bindMatrix !== void 0)
              object.bindMatrix.fromArray(data.bindMatrix);
            if (data.skeleton !== void 0)
              object.skeleton = data.skeleton;
            break;
          case "Mesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new Mesh3(geometry, material);
            break;
          case "InstancedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            var count = data.count;
            var instanceMatrix = data.instanceMatrix;
            object = new InstancedMesh2(geometry, material, count);
            object.instanceMatrix = new BufferAttribute3(new Float32Array(instanceMatrix.array), 16);
            break;
          case "LOD":
            object = new LOD2();
            break;
          case "Line":
            object = new Line2(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineLoop":
            object = new LineLoop2(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineSegments":
            object = new LineSegments2(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "PointCloud":
          case "Points":
            object = new Points2(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "Sprite":
            object = new Sprite2(getMaterial(data.material));
            break;
          case "Group":
            object = new Group2();
            break;
          case "Bone":
            object = new Bone2();
            break;
          default:
            object = new Object3D2();
        }
        object.uuid = data.uuid;
        if (data.name !== void 0)
          object.name = data.name;
        if (data.matrix !== void 0) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== void 0)
            object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate)
            object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== void 0)
            object.position.fromArray(data.position);
          if (data.rotation !== void 0)
            object.rotation.fromArray(data.rotation);
          if (data.quaternion !== void 0)
            object.quaternion.fromArray(data.quaternion);
          if (data.scale !== void 0)
            object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== void 0)
          object.castShadow = data.castShadow;
        if (data.receiveShadow !== void 0)
          object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.bias !== void 0)
            object.shadow.bias = data.shadow.bias;
          if (data.shadow.normalBias !== void 0)
            object.shadow.normalBias = data.shadow.normalBias;
          if (data.shadow.radius !== void 0)
            object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== void 0)
            object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== void 0)
            object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== void 0)
          object.visible = data.visible;
        if (data.frustumCulled !== void 0)
          object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== void 0)
          object.renderOrder = data.renderOrder;
        if (data.userData !== void 0)
          object.userData = data.userData;
        if (data.layers !== void 0)
          object.layers.mask = data.layers;
        if (data.children !== void 0) {
          var children = data.children;
          for (var i2 = 0; i2 < children.length; i2++) {
            object.add(this.parseObject(children[i2], geometries, materials, animations));
          }
        }
        if (data.animations !== void 0) {
          var objectAnimations = data.animations;
          for (var _i = 0; _i < objectAnimations.length; _i++) {
            var uuid = objectAnimations[_i];
            object.animations.push(animations[uuid]);
          }
        }
        if (data.type === "LOD") {
          if (data.autoUpdate !== void 0)
            object.autoUpdate = data.autoUpdate;
          var levels = data.levels;
          for (var l = 0; l < levels.length; l++) {
            var level = levels[l];
            var child = object.getObjectByProperty("uuid", level.object);
            if (child !== void 0) {
              object.addLevel(child, level.distance);
            }
          }
        }
        return object;
      };
      _proto.bindSkeletons = function bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0)
          return;
        object.traverse(function(child) {
          if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
            var skeleton = skeletons[child.skeleton];
            if (skeleton === void 0) {
              console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
            } else {
              child.bind(skeleton, child.bindMatrix);
            }
          }
        });
      };
      _proto.setTexturePath = function setTexturePath(value) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value);
      };
      return ObjectLoader2;
    }(Loader2);
    var TEXTURE_MAPPING = {
      UVMapping: UVMapping2,
      CubeReflectionMapping: CubeReflectionMapping2,
      CubeRefractionMapping: CubeRefractionMapping2,
      EquirectangularReflectionMapping: EquirectangularReflectionMapping2,
      EquirectangularRefractionMapping: EquirectangularRefractionMapping2,
      CubeUVReflectionMapping: CubeUVReflectionMapping2,
      CubeUVRefractionMapping: CubeUVRefractionMapping2
    };
    var TEXTURE_WRAPPING = {
      RepeatWrapping: RepeatWrapping2,
      ClampToEdgeWrapping: ClampToEdgeWrapping2,
      MirroredRepeatWrapping: MirroredRepeatWrapping2
    };
    var TEXTURE_FILTER = {
      NearestFilter: NearestFilter2,
      NearestMipmapNearestFilter: NearestMipmapNearestFilter2,
      NearestMipmapLinearFilter: NearestMipmapLinearFilter2,
      LinearFilter: LinearFilter2,
      LinearMipmapNearestFilter: LinearMipmapNearestFilter2,
      LinearMipmapLinearFilter: LinearMipmapLinearFilter2
    };
    function ImageBitmapLoader2(manager) {
      if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
      }
      if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
      }
      Loader2.call(this, manager);
      this.options = {
        premultiplyAlpha: "none"
      };
    }
    ImageBitmapLoader2.prototype = Object.assign(Object.create(Loader2.prototype), {
      constructor: ImageBitmapLoader2,
      isImageBitmapLoader: true,
      setOptions: function setOptions2(options) {
        this.options = options;
        return this;
      },
      load: function load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache2.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        var fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
          return res.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, Object.assign(scope.options, {
            colorSpaceConversion: "none"
          }));
        }).then(function(imageBitmap) {
          Cache2.add(url, imageBitmap);
          if (onLoad)
            onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch(function(e) {
          if (onError)
            onError(e);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
      }
    });
    var ShapePath2 = /* @__PURE__ */ function() {
      function ShapePath3() {
        this.type = "ShapePath";
        this.color = new Color5();
        this.subPaths = [];
        this.currentPath = null;
      }
      var _proto = ShapePath3.prototype;
      _proto.moveTo = function moveTo(x, y) {
        this.currentPath = new Path2();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
      };
      _proto.lineTo = function lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
      };
      _proto.quadraticCurveTo = function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      };
      _proto.bezierCurveTo = function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      };
      _proto.splineThru = function splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
      };
      _proto.toShapes = function toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
          var shapes2 = [];
          for (var i3 = 0, l2 = inSubpaths.length; i3 < l2; i3++) {
            var _tmpPath = inSubpaths[i3];
            var _tmpShape = new Shape2();
            _tmpShape.curves = _tmpPath.curves;
            shapes2.push(_tmpShape);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          var polyLen = inPolygon.length;
          var inside = false;
          for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            var edgeLowPt = inPolygon[p];
            var edgeHighPt = inPolygon[q];
            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                  return true;
              } else {
                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                  return true;
                if (perpEdge < 0)
                  continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y)
                continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
            }
          }
          return inside;
        }
        var isClockWise = ShapeUtils2.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0)
          return [];
        if (noHoles === true)
          return toShapesNoHoles(subPaths);
        var solid, tmpPath, tmpShape;
        var shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape2();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (var i2 = 0, l = subPaths.length; i2 < l; i2++) {
          tmpPath = subPaths[i2];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx])
              mainIdx++;
            newShapes[mainIdx] = {
              s: new Shape2(),
              p: tmpPoints
            };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst)
              mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({
              h: tmpPath,
              p: tmpPoints[0]
            });
          }
        }
        if (!newShapes[0])
          return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          var ambiguous = false;
          var toChange = [];
          for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
            var sho = newShapeHoles[_sIdx];
            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
              var ho = sho[hIdx];
              var hole_unassigned = true;
              for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (_sIdx !== s2Idx)
                    toChange.push({
                      froms: _sIdx,
                      tos: s2Idx,
                      hole: hIdx
                    });
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[_sIdx].push(ho);
              }
            }
          }
          if (toChange.length > 0) {
            if (!ambiguous)
              newShapeHoles = betterShapeHoles;
          }
        }
        var tmpHoles;
        for (var _i = 0, il = newShapes.length; _i < il; _i++) {
          tmpShape = newShapes[_i].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[_i];
          for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }
        return shapes;
      };
      return ShapePath3;
    }();
    var Font2 = /* @__PURE__ */ function() {
      function Font3(data) {
        this.type = "Font";
        this.data = data;
      }
      var _proto = Font3.prototype;
      _proto.generateShapes = function generateShapes(text, size) {
        if (size === void 0) {
          size = 100;
        }
        var shapes = [];
        var paths = createPaths2(text, size, this.data);
        for (var p = 0, pl = paths.length; p < pl; p++) {
          Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
      };
      return Font3;
    }();
    function createPaths2(text, size, data) {
      var chars = Array.from(text);
      var scale = size / data.resolution;
      var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
      var paths = [];
      var offsetX = 0, offsetY = 0;
      for (var i2 = 0; i2 < chars.length; i2++) {
        var char = chars[i2];
        if (char === "\n") {
          offsetX = 0;
          offsetY -= line_height;
        } else {
          var ret = createPath2(char, scale, offsetX, offsetY, data);
          offsetX += ret.offsetX;
          paths.push(ret.path);
        }
      }
      return paths;
    }
    function createPath2(char, scale, offsetX, offsetY, data) {
      var glyph = data.glyphs[char] || data.glyphs["?"];
      if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
        return;
      }
      var path = new ShapePath2();
      var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
      if (glyph.o) {
        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for (var i2 = 0, l = outline.length; i2 < l; ) {
          var action = outline[i2++];
          switch (action) {
            case "m":
              x = outline[i2++] * scale + offsetX;
              y = outline[i2++] * scale + offsetY;
              path.moveTo(x, y);
              break;
            case "l":
              x = outline[i2++] * scale + offsetX;
              y = outline[i2++] * scale + offsetY;
              path.lineTo(x, y);
              break;
            case "q":
              cpx = outline[i2++] * scale + offsetX;
              cpy = outline[i2++] * scale + offsetY;
              cpx1 = outline[i2++] * scale + offsetX;
              cpy1 = outline[i2++] * scale + offsetY;
              path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
              break;
            case "b":
              cpx = outline[i2++] * scale + offsetX;
              cpy = outline[i2++] * scale + offsetY;
              cpx1 = outline[i2++] * scale + offsetX;
              cpy1 = outline[i2++] * scale + offsetY;
              cpx2 = outline[i2++] * scale + offsetX;
              cpy2 = outline[i2++] * scale + offsetY;
              path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
              break;
          }
        }
      }
      return {
        offsetX: glyph.ha * scale,
        path
      };
    }
    Font2.prototype.isFont = true;
    var FontLoader = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(FontLoader2, _Loader);
      function FontLoader2(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = FontLoader2.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
          var json;
          try {
            json = JSON.parse(text);
          } catch (e) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
            json = JSON.parse(text.substring(65, text.length - 2));
          }
          var font = scope.parse(json);
          if (onLoad)
            onLoad(font);
        }, onProgress, onError);
      };
      _proto.parse = function parse(json) {
        return new Font2(json);
      };
      return FontLoader2;
    }(Loader2);
    var _context2;
    var AudioContext2 = {
      getContext: function getContext() {
        if (_context2 === void 0) {
          _context2 = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context2;
      },
      setContext: function setContext(value) {
        _context2 = value;
      }
    };
    var AudioLoader2 = /* @__PURE__ */ function(_Loader) {
      _inheritsLoose(AudioLoader3, _Loader);
      function AudioLoader3(manager) {
        return _Loader.call(this, manager) || this;
      }
      var _proto = AudioLoader3.prototype;
      _proto.load = function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader2(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
          try {
            var bufferCopy = buffer.slice(0);
            var context = AudioContext2.getContext();
            context.decodeAudioData(bufferCopy, function(audioBuffer) {
              onLoad(audioBuffer);
            });
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      };
      return AudioLoader3;
    }(Loader2);
    var HemisphereLightProbe2 = /* @__PURE__ */ function(_LightProbe) {
      _inheritsLoose(HemisphereLightProbe3, _LightProbe);
      function HemisphereLightProbe3(skyColor, groundColor, intensity) {
        var _this;
        if (intensity === void 0) {
          intensity = 1;
        }
        _this = _LightProbe.call(this, void 0, intensity) || this;
        var color1 = new Color5().set(skyColor);
        var color2 = new Color5().set(groundColor);
        var sky = new Vector32(color1.r, color1.g, color1.b);
        var ground = new Vector32(color2.r, color2.g, color2.b);
        var c0 = Math.sqrt(Math.PI);
        var c1 = c0 * Math.sqrt(0.75);
        _this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        _this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        return _this;
      }
      return HemisphereLightProbe3;
    }(LightProbe2);
    HemisphereLightProbe2.prototype.isHemisphereLightProbe = true;
    var AmbientLightProbe2 = /* @__PURE__ */ function(_LightProbe) {
      _inheritsLoose(AmbientLightProbe3, _LightProbe);
      function AmbientLightProbe3(color, intensity) {
        var _this;
        if (intensity === void 0) {
          intensity = 1;
        }
        _this = _LightProbe.call(this, void 0, intensity) || this;
        var color1 = new Color5().set(color);
        _this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        return _this;
      }
      return AmbientLightProbe3;
    }(LightProbe2);
    AmbientLightProbe2.prototype.isAmbientLightProbe = true;
    var _eyeRight2 = new Matrix43();
    var _eyeLeft2 = new Matrix43();
    var StereoCamera = /* @__PURE__ */ function() {
      function StereoCamera2() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera3();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera3();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
        };
      }
      var _proto = StereoCamera2.prototype;
      _proto.update = function update(camera2) {
        var cache = this._cache;
        var needsUpdate = cache.focus !== camera2.focus || cache.fov !== camera2.fov || cache.aspect !== camera2.aspect * this.aspect || cache.near !== camera2.near || cache.far !== camera2.far || cache.zoom !== camera2.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera2.focus;
          cache.fov = camera2.fov;
          cache.aspect = camera2.aspect * this.aspect;
          cache.near = camera2.near;
          cache.far = camera2.far;
          cache.zoom = camera2.zoom;
          cache.eyeSep = this.eyeSep;
          var projectionMatrix = camera2.projectionMatrix.clone();
          var eyeSepHalf = cache.eyeSep / 2;
          var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          var ymax = cache.near * Math.tan(MathUtils2.DEG2RAD * cache.fov * 0.5) / cache.zoom;
          var xmin, xmax;
          _eyeLeft2.elements[12] = -eyeSepHalf;
          _eyeRight2.elements[12] = eyeSepHalf;
          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(projectionMatrix);
          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera2.matrixWorld).multiply(_eyeLeft2);
        this.cameraR.matrixWorld.copy(camera2.matrixWorld).multiply(_eyeRight2);
      };
      return StereoCamera2;
    }();
    var Clock = /* @__PURE__ */ function() {
      function Clock2(autoStart) {
        this.autoStart = autoStart !== void 0 ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
      }
      var _proto = Clock2.prototype;
      _proto.start = function start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      };
      _proto.stop = function stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      };
      _proto.getElapsedTime = function getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      };
      _proto.getDelta = function getDelta() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          var newTime = now();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      };
      return Clock2;
    }();
    function now() {
      return (typeof performance === "undefined" ? Date : performance).now();
    }
    var _position$2 = /* @__PURE__ */ new Vector32();
    var _quaternion$3 = /* @__PURE__ */ new Quaternion2();
    var _scale$1 = /* @__PURE__ */ new Vector32();
    var _orientation = /* @__PURE__ */ new Vector32();
    var AudioListener = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(AudioListener2, _Object3D);
      function AudioListener2() {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "AudioListener";
        _this.context = AudioContext2.getContext();
        _this.gain = _this.context.createGain();
        _this.gain.connect(_this.context.destination);
        _this.filter = null;
        _this.timeDelta = 0;
        _this._clock = new Clock();
        return _this;
      }
      var _proto = AudioListener2.prototype;
      _proto.getInput = function getInput() {
        return this.gain;
      };
      _proto.removeFilter = function removeFilter() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      };
      _proto.getFilter = function getFilter() {
        return this.filter;
      };
      _proto.setFilter = function setFilter(value) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      };
      _proto.getMasterVolume = function getMasterVolume() {
        return this.gain.gain.value;
      };
      _proto.setMasterVolume = function setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      };
      _proto.updateMatrixWorld = function updateMatrixWorld(force) {
        _Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
        _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
        if (listener.positionX) {
          var endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
          listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
        }
      };
      return AudioListener2;
    }(Object3D2);
    var Audio2 = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(Audio3, _Object3D);
      function Audio3(listener) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.type = "Audio";
        _this.listener = listener;
        _this.context = listener.context;
        _this.gain = _this.context.createGain();
        _this.gain.connect(listener.getInput());
        _this.autoplay = false;
        _this.buffer = null;
        _this.detune = 0;
        _this.loop = false;
        _this.loopStart = 0;
        _this.loopEnd = 0;
        _this.offset = 0;
        _this.duration = void 0;
        _this.playbackRate = 1;
        _this.isPlaying = false;
        _this.hasPlaybackControl = true;
        _this.source = null;
        _this.sourceType = "empty";
        _this._startedAt = 0;
        _this._progress = 0;
        _this._connected = false;
        _this.filters = [];
        return _this;
      }
      var _proto = Audio3.prototype;
      _proto.getOutput = function getOutput() {
        return this.gain;
      };
      _proto.setNodeSource = function setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      };
      _proto.setMediaElementSource = function setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      };
      _proto.setMediaStreamSource = function setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      };
      _proto.setBuffer = function setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay)
          this.play();
        return this;
      };
      _proto.play = function play(delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        var source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      };
      _proto.pause = function pause() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      };
      _proto.stop = function stop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
      };
      _proto.connect = function connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (var i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].connect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
      };
      _proto.disconnect = function disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].disconnect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
      };
      _proto.getFilters = function getFilters() {
        return this.filters;
      };
      _proto.setFilters = function setFilters(value) {
        if (!value)
          value = [];
        if (this._connected === true) {
          this.disconnect();
          this.filters = value.slice();
          this.connect();
        } else {
          this.filters = value.slice();
        }
        return this;
      };
      _proto.setDetune = function setDetune(value) {
        this.detune = value;
        if (this.source.detune === void 0)
          return;
        if (this.isPlaying === true) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      };
      _proto.getDetune = function getDetune() {
        return this.detune;
      };
      _proto.getFilter = function getFilter() {
        return this.getFilters()[0];
      };
      _proto.setFilter = function setFilter(filter) {
        return this.setFilters(filter ? [filter] : []);
      };
      _proto.setPlaybackRate = function setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      };
      _proto.getPlaybackRate = function getPlaybackRate() {
        return this.playbackRate;
      };
      _proto.onEnded = function onEnded() {
        this.isPlaying = false;
      };
      _proto.getLoop = function getLoop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      };
      _proto.setLoop = function setLoop(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      };
      _proto.setLoopStart = function setLoopStart(value) {
        this.loopStart = value;
        return this;
      };
      _proto.setLoopEnd = function setLoopEnd(value) {
        this.loopEnd = value;
        return this;
      };
      _proto.getVolume = function getVolume() {
        return this.gain.gain.value;
      };
      _proto.setVolume = function setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      };
      return Audio3;
    }(Object3D2);
    var _position$3 = /* @__PURE__ */ new Vector32();
    var _quaternion$4 = /* @__PURE__ */ new Quaternion2();
    var _scale$2 = /* @__PURE__ */ new Vector32();
    var _orientation$1 = /* @__PURE__ */ new Vector32();
    var PositionalAudio = /* @__PURE__ */ function(_Audio) {
      _inheritsLoose(PositionalAudio2, _Audio);
      function PositionalAudio2(listener) {
        var _this;
        _this = _Audio.call(this, listener) || this;
        _this.panner = _this.context.createPanner();
        _this.panner.panningModel = "HRTF";
        _this.panner.connect(_this.gain);
        return _this;
      }
      var _proto = PositionalAudio2.prototype;
      _proto.getOutput = function getOutput() {
        return this.panner;
      };
      _proto.getRefDistance = function getRefDistance() {
        return this.panner.refDistance;
      };
      _proto.setRefDistance = function setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
      };
      _proto.getRolloffFactor = function getRolloffFactor() {
        return this.panner.rolloffFactor;
      };
      _proto.setRolloffFactor = function setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
      };
      _proto.getDistanceModel = function getDistanceModel() {
        return this.panner.distanceModel;
      };
      _proto.setDistanceModel = function setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
      };
      _proto.getMaxDistance = function getMaxDistance() {
        return this.panner.maxDistance;
      };
      _proto.setMaxDistance = function setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
      };
      _proto.setDirectionalCone = function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      };
      _proto.updateMatrixWorld = function updateMatrixWorld(force) {
        _Audio.prototype.updateMatrixWorld.call(this, force);
        if (this.hasPlaybackControl === true && this.isPlaying === false)
          return;
        this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
        _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
        var panner = this.panner;
        if (panner.positionX) {
          var endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        } else {
          panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
          panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
        }
      };
      return PositionalAudio2;
    }(Audio2);
    var AudioAnalyser2 = /* @__PURE__ */ function() {
      function AudioAnalyser3(audio, fftSize) {
        if (fftSize === void 0) {
          fftSize = 2048;
        }
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
      }
      var _proto = AudioAnalyser3.prototype;
      _proto.getFrequencyData = function getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      };
      _proto.getAverageFrequency = function getAverageFrequency() {
        var value = 0;
        var data = this.getFrequencyData();
        for (var i2 = 0; i2 < data.length; i2++) {
          value += data[i2];
        }
        return value / data.length;
      };
      return AudioAnalyser3;
    }();
    var PropertyMixer2 = /* @__PURE__ */ function() {
      function PropertyMixer3(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var mixFunction, mixFunctionAdditive, setIdentity;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
          case "string":
          case "bool":
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
          default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
      }
      var _proto = PropertyMixer3.prototype;
      _proto.accumulate = function accumulate(accuIndex, weight) {
        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        var currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (var i2 = 0; i2 !== stride; ++i2) {
            buffer[offset + i2] = buffer[i2];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          var mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      };
      _proto.accumulateAdditive = function accumulateAdditive(weight) {
        var buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      };
      _proto.apply = function apply(accuIndex) {
        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          var originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
          this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for (var i2 = stride, e = stride + stride; i2 !== e; ++i2) {
          if (buffer[i2] !== buffer[i2 + stride]) {
            binding.setValue(buffer, offset);
            break;
          }
        }
      };
      _proto.saveOriginalState = function saveOriginalState() {
        var binding = this.binding;
        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for (var i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
          buffer[i2] = buffer[originalValueOffset + i2 % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      };
      _proto.restoreOriginalState = function restoreOriginalState() {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      };
      _proto._setAdditiveIdentityNumeric = function _setAdditiveIdentityNumeric() {
        var startIndex = this._addIndex * this.valueSize;
        var endIndex = startIndex + this.valueSize;
        for (var i2 = startIndex; i2 < endIndex; i2++) {
          this.buffer[i2] = 0;
        }
      };
      _proto._setAdditiveIdentityQuaternion = function _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
      };
      _proto._setAdditiveIdentityOther = function _setAdditiveIdentityOther() {
        var startIndex = this._origIndex * this.valueSize;
        var targetIndex = this._addIndex * this.valueSize;
        for (var i2 = 0; i2 < this.valueSize; i2++) {
          this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
        }
      };
      _proto._select = function _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
          for (var i2 = 0; i2 !== stride; ++i2) {
            buffer[dstOffset + i2] = buffer[srcOffset + i2];
          }
        }
      };
      _proto._slerp = function _slerp(buffer, dstOffset, srcOffset, t) {
        Quaternion2.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
      };
      _proto._slerpAdditive = function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        var workOffset = this._workIndex * stride;
        Quaternion2.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion2.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
      };
      _proto._lerp = function _lerp(buffer, dstOffset, srcOffset, t, stride) {
        var s = 1 - t;
        for (var i2 = 0; i2 !== stride; ++i2) {
          var j = dstOffset + i2;
          buffer[j] = buffer[j] * s + buffer[srcOffset + i2] * t;
        }
      };
      _proto._lerpAdditive = function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for (var i2 = 0; i2 !== stride; ++i2) {
          var j = dstOffset + i2;
          buffer[j] = buffer[j] + buffer[srcOffset + i2] * t;
        }
      };
      return PropertyMixer3;
    }();
    var _RESERVED_CHARS_RE2 = "\\[\\]\\.:\\/";
    var _reservedRe2 = new RegExp("[" + _RESERVED_CHARS_RE2 + "]", "g");
    var _wordChar2 = "[^" + _RESERVED_CHARS_RE2 + "]";
    var _wordCharOrDot2 = "[^" + _RESERVED_CHARS_RE2.replace("\\.", "") + "]";
    var _directoryRe2 = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar2);
    var _nodeRe2 = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot2);
    var _objectRe2 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar2);
    var _propertyRe2 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar2);
    var _trackRe2 = new RegExp("^" + _directoryRe2 + _nodeRe2 + _objectRe2 + _propertyRe2 + "$");
    var _supportedObjectNames2 = ["material", "materials", "bones"];
    function Composite2(targetGroup, path, optionalParsedPath) {
      var parsedPath = optionalParsedPath || PropertyBinding2.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    Object.assign(Composite2.prototype, {
      getValue: function getValue(array, offset) {
        this.bind();
        var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array, offset);
      },
      setValue: function setValue(array, offset) {
        var bindings = this._bindings;
        for (var i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].setValue(array, offset);
        }
      },
      bind: function bind() {
        var bindings = this._bindings;
        for (var i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].bind();
        }
      },
      unbind: function unbind() {
        var bindings = this._bindings;
        for (var i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].unbind();
        }
      }
    });
    function PropertyBinding2(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding2.parseTrackName(path);
      this.node = PropertyBinding2.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
      this.rootNode = rootNode;
    }
    Object.assign(PropertyBinding2, {
      Composite: Composite2,
      create: function create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding2(root, path, parsedPath);
        } else {
          return new PropertyBinding2.Composite(root, path, parsedPath);
        }
      },
      sanitizeNodeName: function sanitizeNodeName(name2) {
        return name2.replace(/\s/g, "_").replace(_reservedRe2, "");
      },
      parseTrackName: function parseTrackName(trackName) {
        var matches = _trackRe2.exec(trackName);
        if (!matches) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        var results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          var objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames2.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      },
      findNode: function findNode(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          var bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          var searchNodeSubtree = function searchNodeSubtree2(children) {
            for (var i2 = 0; i2 < children.length; i2++) {
              var childNode = children[i2];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              var result = searchNodeSubtree2(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          var subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
    });
    Object.assign(PropertyBinding2.prototype, {
      _getValue_unavailable: function _getValue_unavailable() {
      },
      _setValue_unavailable: function _setValue_unavailable() {
      },
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      },
      Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      },
      GetterByBindingType: [function getValue_direct2(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
      }, function getValue_array2(buffer, offset) {
        var source = this.resolvedProperty;
        for (var i2 = 0, n = source.length; i2 !== n; ++i2) {
          buffer[offset++] = source[i2];
        }
      }, function getValue_arrayElement2(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }, function getValue_toArray2(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }],
      SetterByBindingTypeAndVersioning: [[
        function setValue_direct2(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        },
        function setValue_direct_setNeedsUpdate2(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_direct_setMatrixWorldNeedsUpdate2(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ], [
        function setValue_array2(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
        },
        function setValue_array_setNeedsUpdate2(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        },
        function setValue_array_setMatrixWorldNeedsUpdate2(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ], [
        function setValue_arrayElement2(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        },
        function setValue_arrayElement_setNeedsUpdate2(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_arrayElement_setMatrixWorldNeedsUpdate2(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ], [
        function setValue_fromArray2(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        },
        function setValue_fromArray_setNeedsUpdate2(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        },
        function setValue_fromArray_setMatrixWorldNeedsUpdate2(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ]],
      getValue: function getValue_unbound3(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      },
      setValue: function getValue_unbound3(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      },
      bind: function bind() {
        var targetObject = this.node;
        var parsedPath = this.parsedPath;
        var objectName = parsedPath.objectName;
        var propertyName = parsedPath.propertyName;
        var propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding2.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          var objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (var i2 = 0; i2 < targetObject.length; i2++) {
                if (targetObject[i2].name === objectIndex) {
                  objectIndex = i2;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          var nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        var versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (targetObject.geometry.isBufferGeometry) {
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            } else {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              return;
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      },
      unbind: function unbind() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    });
    Object.assign(PropertyBinding2.prototype, {
      _getValue_unbound: PropertyBinding2.prototype.getValue,
      _setValue_unbound: PropertyBinding2.prototype.setValue
    });
    var AnimationObjectGroup2 = /* @__PURE__ */ function() {
      function AnimationObjectGroup3() {
        this.uuid = MathUtils2.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          indices[arguments[i2].uuid] = i2;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
          objects: {
            get total() {
              return scope._objects.length;
            },
            get inUse() {
              return this.total - scope.nCachedObjects_;
            }
          },
          get bindingsPerObject() {
            return scope._bindings.length;
          }
        };
      }
      var _proto = AnimationObjectGroup3.prototype;
      _proto.add = function add() {
        var objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        var knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for (var i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          var object = arguments[i2], uuid = object.uuid;
          var index = indicesByUUID[uuid];
          if (index === void 0) {
            index = nObjects++;
            indicesByUUID[uuid] = index;
            objects.push(object);
            for (var j = 0, m = nBindings; j !== m; ++j) {
              bindings[j].push(new PropertyBinding2(object, paths[j], parsedPaths[j]));
            }
          } else if (index < nCachedObjects) {
            knownObject = objects[index];
            var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (var _j = 0, _m = nBindings; _j !== _m; ++_j) {
              var bindingsForPath = bindings[_j], lastCached = bindingsForPath[firstActiveIndex];
              var binding = bindingsForPath[index];
              bindingsForPath[index] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding2(object, paths[_j], parsedPaths[_j]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      };
      _proto.remove = function remove() {
        var objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        var nCachedObjects = this.nCachedObjects_;
        for (var i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          var object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0 && index >= nCachedObjects) {
            var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index;
            objects[index] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
              bindingsForPath[index] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      };
      _proto.uncache = function uncache() {
        var objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        var nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for (var i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          var object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0) {
            delete indicesByUUID[uuid];
            if (index < nCachedObjects) {
              var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (var j = 0, m = nBindings; j !== m; ++j) {
                var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              var _lastIndex = --nObjects, _lastObject = objects[_lastIndex];
              if (_lastIndex > 0) {
                indicesByUUID[_lastObject.uuid] = index;
              }
              objects[index] = _lastObject;
              objects.pop();
              for (var _j2 = 0, _m2 = nBindings; _j2 !== _m2; ++_j2) {
                var _bindingsForPath = bindings[_j2];
                _bindingsForPath[index] = _bindingsForPath[_lastIndex];
                _bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      };
      _proto.subscribe_ = function subscribe_(path, parsedPath) {
        var indicesByPath = this._bindingsIndicesByPath;
        var index = indicesByPath[path];
        var bindings = this._bindings;
        if (index !== void 0)
          return bindings[index];
        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (var i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
          var object = objects[i2];
          bindingsForPath[i2] = new PropertyBinding2(object, path, parsedPath);
        }
        return bindingsForPath;
      };
      _proto.unsubscribe_ = function unsubscribe_(path) {
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== void 0) {
          var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index;
          bindings[index] = lastBindings;
          bindings.pop();
          parsedPaths[index] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index] = paths[lastBindingsIndex];
          paths.pop();
        }
      };
      return AnimationObjectGroup3;
    }();
    AnimationObjectGroup2.prototype.isAnimationObjectGroup = true;
    var AnimationAction2 = /* @__PURE__ */ function() {
      function AnimationAction3(mixer, clip, localRoot, blendMode) {
        if (localRoot === void 0) {
          localRoot = null;
        }
        if (blendMode === void 0) {
          blendMode = clip.blendMode;
        }
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        var interpolantSettings = {
          endingStart: ZeroCurvatureEnding2,
          endingEnd: ZeroCurvatureEnding2
        };
        for (var i2 = 0; i2 !== nTracks; ++i2) {
          var interpolant = tracks[i2].createInterpolant(null);
          interpolants[i2] = interpolant;
          interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat2;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
      }
      var _proto = AnimationAction3.prototype;
      _proto.play = function play() {
        this._mixer._activateAction(this);
        return this;
      };
      _proto.stop = function stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
      };
      _proto.reset = function reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      };
      _proto.isRunning = function isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      };
      _proto.isScheduled = function isScheduled() {
        return this._mixer._isActiveAction(this);
      };
      _proto.startAt = function startAt(time) {
        this._startTime = time;
        return this;
      };
      _proto.setLoop = function setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      };
      _proto.setEffectiveWeight = function setEffectiveWeight(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      };
      _proto.getEffectiveWeight = function getEffectiveWeight() {
        return this._effectiveWeight;
      };
      _proto.fadeIn = function fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
      };
      _proto.fadeOut = function fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
      };
      _proto.crossFadeFrom = function crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      };
      _proto.crossFadeTo = function crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      };
      _proto.stopFading = function stopFading() {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      };
      _proto.setEffectiveTimeScale = function setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      };
      _proto.getEffectiveTimeScale = function getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      };
      _proto.setDuration = function setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      };
      _proto.syncWith = function syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      };
      _proto.halt = function halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      };
      _proto.warp = function warp(startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        times[1] = now2 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      };
      _proto.stopWarping = function stopWarping() {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      };
      _proto.getMixer = function getMixer() {
        return this._mixer;
      };
      _proto.getClip = function getClip() {
        return this._clip;
      };
      _proto.getRoot = function getRoot() {
        return this._localRoot || this._mixer._root;
      };
      _proto._update = function _update(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time);
          return;
        }
        var startTime = this._startTime;
        if (startTime !== null) {
          var timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            return;
          }
          this._startTime = null;
          deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        var clipTime = this._updateTime(deltaTime);
        var weight = this._updateWeight(time);
        if (weight > 0) {
          var _interpolants = this._interpolants;
          var propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode2:
              for (var j = 0, m = _interpolants.length; j !== m; ++j) {
                _interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode2:
            default:
              for (var _j = 0, _m = _interpolants.length; _j !== _m; ++_j) {
                _interpolants[_j].evaluate(clipTime);
                propertyMixers[_j].accumulate(accuIndex, weight);
              }
          }
        }
      };
      _proto._updateWeight = function _updateWeight(time) {
        var weight = 0;
        if (this.enabled) {
          weight = this.weight;
          var interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      };
      _proto._updateTimeScale = function _updateTimeScale(time) {
        var timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          var interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      };
      _proto._updateTime = function _updateTime(deltaTime) {
        var duration = this._clip.duration;
        var loop = this.loop;
        var time = this.time + deltaTime;
        var loopCount = this._loopCount;
        var pingPong = loop === LoopPingPong2;
        if (deltaTime === 0) {
          if (loopCount === -1)
            return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce2) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            var loopDelta = Math.floor(time / duration);
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            var pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                var atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time;
          }
        }
        return time;
      };
      _proto._setEndings = function _setEndings(atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding2;
          settings.endingEnd = ZeroSlopeEnding2;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding2 : ZeroCurvatureEnding2;
          } else {
            settings.endingStart = WrapAroundEnding2;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding2 : ZeroCurvatureEnding2;
          } else {
            settings.endingEnd = WrapAroundEnding2;
          }
        }
      };
      _proto._scheduleFading = function _scheduleFading(duration, weightNow, weightThen) {
        var mixer = this._mixer, now2 = mixer.time;
        var interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        values[0] = weightNow;
        times[1] = now2 + duration;
        values[1] = weightThen;
        return this;
      };
      return AnimationAction3;
    }();
    var AnimationMixer2 = /* @__PURE__ */ function(_EventDispatcher) {
      _inheritsLoose(AnimationMixer3, _EventDispatcher);
      function AnimationMixer3(root) {
        var _this;
        _this = _EventDispatcher.call(this) || this;
        _this._root = root;
        _this._initMemoryManager();
        _this._accuIndex = 0;
        _this.time = 0;
        _this.timeScale = 1;
        return _this;
      }
      var _proto = AnimationMixer3.prototype;
      _proto._bindAction = function _bindAction(action, prototypeAction) {
        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        var bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (var i2 = 0; i2 !== nTracks; ++i2) {
          var track = tracks[i2], trackName = track.name;
          var binding = bindingsByName[trackName];
          if (binding !== void 0) {
            bindings[i2] = binding;
          } else {
            binding = bindings[i2];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            var path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
            binding = new PropertyMixer2(PropertyBinding2.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i2] = binding;
          }
          interpolants[i2].resultBuffer = binding.buffer;
        }
      };
      _proto._activateAction = function _activateAction(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          var bindings = action._propertyBindings;
          for (var i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            var binding = bindings[i2];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      };
      _proto._deactivateAction = function _deactivateAction(action) {
        if (this._isActiveAction(action)) {
          var bindings = action._propertyBindings;
          for (var i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            var binding = bindings[i2];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      };
      _proto._initMemoryManager = function _initMemoryManager() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      };
      _proto._isActiveAction = function _isActiveAction(action) {
        var index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
      };
      _proto._addInactiveAction = function _addInactiveAction(action, clipUuid, rootUuid) {
        var actions = this._actions, actionsByClip = this._actionsByClip;
        var actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          var knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      };
      _proto._removeInactiveAction = function _removeInactiveAction(action) {
        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      };
      _proto._removeInactiveBindingsForAction = function _removeInactiveBindingsForAction(action) {
        var bindings = action._propertyBindings;
        for (var i2 = 0, n = bindings.length; i2 !== n; ++i2) {
          var binding = bindings[i2];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      };
      _proto._lendAction = function _lendAction(action) {
        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      };
      _proto._takeBackAction = function _takeBackAction(action) {
        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      };
      _proto._addInactiveBinding = function _addInactiveBinding(binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        var bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      };
      _proto._removeInactiveBinding = function _removeInactiveBinding(binding) {
        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      };
      _proto._lendBinding = function _lendBinding(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      };
      _proto._takeBackBinding = function _takeBackBinding(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      };
      _proto._lendControlInterpolant = function _lendControlInterpolant() {
        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        var interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant2(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      };
      _proto._takeBackControlInterpolant = function _takeBackControlInterpolant(interpolant) {
        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      };
      _proto.clipAction = function clipAction(clip, optionalRoot, blendMode) {
        var root = optionalRoot || this._root, rootUuid = root.uuid;
        var clipObject = typeof clip === "string" ? AnimationClip2.findByName(root, clip) : clip;
        var clipUuid = clipObject !== null ? clipObject.uuid : clip;
        var actionsForClip = this._actionsByClip[clipUuid];
        var prototypeAction = null;
        if (blendMode === void 0) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode2;
          }
        }
        if (actionsForClip !== void 0) {
          var existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
          return null;
        var newAction = new AnimationAction2(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      };
      _proto.existingAction = function existingAction(clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip2.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      };
      _proto.stopAllAction = function stopAllAction() {
        var actions = this._actions, nActions = this._nActiveActions;
        for (var i2 = nActions - 1; i2 >= 0; --i2) {
          actions[i2].stop();
        }
        return this;
      };
      _proto.update = function update(deltaTime) {
        deltaTime *= this.timeScale;
        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (var i2 = 0; i2 !== nActions; ++i2) {
          var action = actions[i2];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }
        var bindings = this._bindings, nBindings = this._nActiveBindings;
        for (var _i = 0; _i !== nBindings; ++_i) {
          bindings[_i].apply(accuIndex);
        }
        return this;
      };
      _proto.setTime = function setTime(timeInSeconds) {
        this.time = 0;
        for (var i2 = 0; i2 < this._actions.length; i2++) {
          this._actions[i2].time = 0;
        }
        return this.update(timeInSeconds);
      };
      _proto.getRoot = function getRoot() {
        return this._root;
      };
      _proto.uncacheClip = function uncacheClip(clip) {
        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          var actionsToRemove = actionsForClip.knownActions;
          for (var i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
            var action = actionsToRemove[i2];
            this._deactivateAction(action);
            var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      };
      _proto.uncacheRoot = function uncacheRoot(root) {
        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (var clipUuid in actionsByClip) {
          var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (var trackName in bindingByName) {
            var binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      };
      _proto.uncacheAction = function uncacheAction(clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      };
      return AnimationMixer3;
    }(EventDispatcher2);
    AnimationMixer2.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    var Uniform2 = /* @__PURE__ */ function() {
      function Uniform3(value) {
        if (typeof value === "string") {
          console.warn("THREE.Uniform: Type parameter is no longer needed.");
          value = arguments[1];
        }
        this.value = value;
      }
      var _proto = Uniform3.prototype;
      _proto.clone = function clone() {
        return new Uniform3(this.value.clone === void 0 ? this.value : this.value.clone());
      };
      return Uniform3;
    }();
    function InstancedInterleavedBuffer2(array, stride, meshPerAttribute) {
      InterleavedBuffer3.call(this, array, stride);
      this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer2.prototype = Object.assign(Object.create(InterleavedBuffer3.prototype), {
      constructor: InstancedInterleavedBuffer2,
      isInstancedInterleavedBuffer: true,
      copy: function copy(source) {
        InterleavedBuffer3.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      },
      clone: function clone(data) {
        var ib = InterleavedBuffer3.prototype.clone.call(this, data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      },
      toJSON: function toJSON2(data) {
        var json = InterleavedBuffer3.prototype.toJSON.call(this, data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    });
    function GLBufferAttribute2(buffer, type, itemSize, elementSize, count) {
      this.buffer = buffer;
      this.type = type;
      this.itemSize = itemSize;
      this.elementSize = elementSize;
      this.count = count;
      this.version = 0;
    }
    Object.defineProperty(GLBufferAttribute2.prototype, "needsUpdate", {
      set: function set(value) {
        if (value === true)
          this.version++;
      }
    });
    Object.assign(GLBufferAttribute2.prototype, {
      isGLBufferAttribute: true,
      setBuffer: function setBuffer(buffer) {
        this.buffer = buffer;
        return this;
      },
      setType: function setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
      },
      setItemSize: function setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
      },
      setCount: function setCount(count) {
        this.count = count;
        return this;
      }
    });
    function Raycaster2(origin, direction, near, far) {
      if (near === void 0) {
        near = 0;
      }
      if (far === void 0) {
        far = Infinity;
      }
      this.ray = new Ray2(origin, direction);
      this.near = near;
      this.far = far;
      this.camera = null;
      this.layers = new Layers2();
      this.params = {
        Mesh: {},
        Line: {
          threshold: 1
        },
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function get() {
            console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
            return this.Points;
          }
        }
      });
    }
    function ascSort2(a, b) {
      return a.distance - b.distance;
    }
    function _intersectObject(object, raycaster, intersects3, recursive) {
      if (object.layers.test(raycaster.layers)) {
        object.raycast(raycaster, intersects3);
      }
      if (recursive === true) {
        var children = object.children;
        for (var i2 = 0, l = children.length; i2 < l; i2++) {
          _intersectObject(children[i2], raycaster, intersects3, true);
        }
      }
    }
    Object.assign(Raycaster2.prototype, {
      set: function set(origin, direction) {
        this.ray.set(origin, direction);
      },
      setFromCamera: function setFromCamera(coords, camera2) {
        if (camera2 && camera2.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera2.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera2).sub(this.ray.origin).normalize();
          this.camera = camera2;
        } else if (camera2 && camera2.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera2.near + camera2.far) / (camera2.near - camera2.far)).unproject(camera2);
          this.ray.direction.set(0, 0, -1).transformDirection(camera2.matrixWorld);
          this.camera = camera2;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type: " + camera2.type);
        }
      },
      intersectObject: function intersectObject2(object, recursive, intersects3) {
        if (recursive === void 0) {
          recursive = false;
        }
        if (intersects3 === void 0) {
          intersects3 = [];
        }
        _intersectObject(object, this, intersects3, recursive);
        intersects3.sort(ascSort2);
        return intersects3;
      },
      intersectObjects: function intersectObjects(objects, recursive, intersects3) {
        if (recursive === void 0) {
          recursive = false;
        }
        if (intersects3 === void 0) {
          intersects3 = [];
        }
        for (var i2 = 0, l = objects.length; i2 < l; i2++) {
          _intersectObject(objects[i2], this, intersects3, recursive);
        }
        intersects3.sort(ascSort2);
        return intersects3;
      }
    });
    var Spherical2 = /* @__PURE__ */ function() {
      function Spherical3(radius, phi, theta) {
        if (radius === void 0) {
          radius = 1;
        }
        if (phi === void 0) {
          phi = 0;
        }
        if (theta === void 0) {
          theta = 0;
        }
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      var _proto = Spherical3.prototype;
      _proto.set = function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      };
      _proto.copy = function copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      };
      _proto.makeSafe = function makeSafe() {
        var EPS = 1e-6;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      };
      _proto.setFromVector3 = function setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      };
      _proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(MathUtils2.clamp(y / this.radius, -1, 1));
        }
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Spherical3;
    }();
    var Cylindrical = /* @__PURE__ */ function() {
      function Cylindrical2(radius, theta, y) {
        if (radius === void 0) {
          radius = 1;
        }
        if (theta === void 0) {
          theta = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
      }
      var _proto = Cylindrical2.prototype;
      _proto.set = function set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
      };
      _proto.copy = function copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      };
      _proto.setFromVector3 = function setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      };
      _proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Cylindrical2;
    }();
    var _vector$82 = /* @__PURE__ */ new Vector22();
    var Box22 = /* @__PURE__ */ function() {
      function Box23(min, max) {
        if (min === void 0) {
          min = new Vector22(Infinity, Infinity);
        }
        if (max === void 0) {
          max = new Vector22(-Infinity, -Infinity);
        }
        this.min = min;
        this.max = max;
      }
      var _proto = Box23.prototype;
      _proto.set = function set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      };
      _proto.setFromPoints = function setFromPoints(points) {
        this.makeEmpty();
        for (var i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      };
      _proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
        var halfSize = _vector$82.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      _proto.copy = function copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      };
      _proto.makeEmpty = function makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      };
      _proto.isEmpty = function isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      };
      _proto.getCenter = function getCenter(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getCenter() target is now required");
          target = new Vector22();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      };
      _proto.getSize = function getSize(target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getSize() target is now required");
          target = new Vector22();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      };
      _proto.expandByPoint = function expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      };
      _proto.expandByVector = function expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      };
      _proto.expandByScalar = function expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      };
      _proto.containsPoint = function containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
      };
      _proto.containsBox = function containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      };
      _proto.getParameter = function getParameter(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .getParameter() target is now required");
          target = new Vector22();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      };
      _proto.intersectsBox = function intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
      };
      _proto.clampPoint = function clampPoint(point, target) {
        if (target === void 0) {
          console.warn("THREE.Box2: .clampPoint() target is now required");
          target = new Vector22();
        }
        return target.copy(point).clamp(this.min, this.max);
      };
      _proto.distanceToPoint = function distanceToPoint(point) {
        var clampedPoint = _vector$82.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
      _proto.intersect = function intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      };
      _proto.union = function union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      };
      _proto.translate = function translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      };
      _proto.equals = function equals3(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      };
      return Box23;
    }();
    Box22.prototype.isBox2 = true;
    var _startP2 = /* @__PURE__ */ new Vector32();
    var _startEnd2 = /* @__PURE__ */ new Vector32();
    var Line32 = /* @__PURE__ */ function() {
      function Line33(start, end) {
        if (start === void 0) {
          start = new Vector32();
        }
        if (end === void 0) {
          end = new Vector32();
        }
        this.start = start;
        this.end = end;
      }
      var _proto = Line33.prototype;
      _proto.set = function set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      };
      _proto.copy = function copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      };
      _proto.getCenter = function getCenter(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .getCenter() target is now required");
          target = new Vector32();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      };
      _proto.delta = function delta(target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .delta() target is now required");
          target = new Vector32();
        }
        return target.subVectors(this.end, this.start);
      };
      _proto.distanceSq = function distanceSq() {
        return this.start.distanceToSquared(this.end);
      };
      _proto.distance = function distance() {
        return this.start.distanceTo(this.end);
      };
      _proto.at = function at(t, target) {
        if (target === void 0) {
          console.warn("THREE.Line3: .at() target is now required");
          target = new Vector32();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
      };
      _proto.closestPointToPointParameter = function closestPointToPointParameter(point, clampToLine) {
        _startP2.subVectors(point, this.start);
        _startEnd2.subVectors(this.end, this.start);
        var startEnd2 = _startEnd2.dot(_startEnd2);
        var startEnd_startP = _startEnd2.dot(_startP2);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = MathUtils2.clamp(t, 0, 1);
        }
        return t;
      };
      _proto.closestPointToPoint = function closestPointToPoint(point, clampToLine, target) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        if (target === void 0) {
          console.warn("THREE.Line3: .closestPointToPoint() target is now required");
          target = new Vector32();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
      };
      _proto.applyMatrix4 = function applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      };
      _proto.equals = function equals3(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      };
      _proto.clone = function clone() {
        return new this.constructor().copy(this);
      };
      return Line33;
    }();
    function ImmediateRenderObject2(material) {
      Object3D2.call(this);
      this.material = material;
      this.render = function() {
      };
      this.hasPositions = false;
      this.hasNormals = false;
      this.hasColors = false;
      this.hasUvs = false;
      this.positionArray = null;
      this.normalArray = null;
      this.colorArray = null;
      this.uvArray = null;
      this.count = 0;
    }
    ImmediateRenderObject2.prototype = Object.create(Object3D2.prototype);
    ImmediateRenderObject2.prototype.constructor = ImmediateRenderObject2;
    ImmediateRenderObject2.prototype.isImmediateRenderObject = true;
    var _vector$9 = /* @__PURE__ */ new Vector32();
    var SpotLightHelper = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(SpotLightHelper2, _Object3D);
      function SpotLightHelper2(light, color) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.light = light;
        _this.light.updateMatrixWorld();
        _this.matrix = light.matrixWorld;
        _this.matrixAutoUpdate = false;
        _this.color = color;
        var geometry = new BufferGeometry3();
        var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i2 = 0, j = 1, l = 32; i2 < l; i2++, j++) {
          var p1 = i2 / l * Math.PI * 2;
          var p2 = j / l * Math.PI * 2;
          positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
        var material = new LineBasicMaterial2({
          fog: false,
          toneMapped: false
        });
        _this.cone = new LineSegments2(geometry, material);
        _this.add(_this.cone);
        _this.update();
        return _this;
      }
      var _proto = SpotLightHelper2.prototype;
      _proto.dispose = function dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      };
      _proto.update = function update() {
        this.light.updateMatrixWorld();
        var coneLength = this.light.distance ? this.light.distance : 1e3;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$9);
        if (this.color !== void 0) {
          this.cone.material.color.set(this.color);
        } else {
          this.cone.material.color.copy(this.light.color);
        }
      };
      return SpotLightHelper2;
    }(Object3D2);
    var _vector$a2 = /* @__PURE__ */ new Vector32();
    var _boneMatrix2 = /* @__PURE__ */ new Matrix43();
    var _matrixWorldInv2 = /* @__PURE__ */ new Matrix43();
    var SkeletonHelper2 = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(SkeletonHelper3, _LineSegments);
      function SkeletonHelper3(object) {
        var _this;
        var bones = getBoneList2(object);
        var geometry = new BufferGeometry3();
        var vertices = [];
        var colors = [];
        var color1 = new Color5(0, 0, 1);
        var color2 = new Color5(0, 1, 0);
        for (var i2 = 0; i2 < bones.length; i2++) {
          var bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
          }
        }
        geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
        var material = new LineBasicMaterial2({
          vertexColors: true,
          depthTest: false,
          depthWrite: false,
          toneMapped: false,
          transparent: true
        });
        _this = _LineSegments.call(this, geometry, material) || this;
        _this.type = "SkeletonHelper";
        _this.isSkeletonHelper = true;
        _this.root = object;
        _this.bones = bones;
        _this.matrix = object.matrixWorld;
        _this.matrixAutoUpdate = false;
        return _this;
      }
      var _proto = SkeletonHelper3.prototype;
      _proto.updateMatrixWorld = function updateMatrixWorld(force) {
        var bones = this.bones;
        var geometry = this.geometry;
        var position = geometry.getAttribute("position");
        _matrixWorldInv2.copy(this.root.matrixWorld).invert();
        for (var i2 = 0, j = 0; i2 < bones.length; i2++) {
          var bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            _boneMatrix2.multiplyMatrices(_matrixWorldInv2, bone.matrixWorld);
            _vector$a2.setFromMatrixPosition(_boneMatrix2);
            position.setXYZ(j, _vector$a2.x, _vector$a2.y, _vector$a2.z);
            _boneMatrix2.multiplyMatrices(_matrixWorldInv2, bone.parent.matrixWorld);
            _vector$a2.setFromMatrixPosition(_boneMatrix2);
            position.setXYZ(j + 1, _vector$a2.x, _vector$a2.y, _vector$a2.z);
            j += 2;
          }
        }
        geometry.getAttribute("position").needsUpdate = true;
        _LineSegments.prototype.updateMatrixWorld.call(this, force);
      };
      return SkeletonHelper3;
    }(LineSegments2);
    function getBoneList2(object) {
      var boneList = [];
      if (object && object.isBone) {
        boneList.push(object);
      }
      for (var i2 = 0; i2 < object.children.length; i2++) {
        boneList.push.apply(boneList, getBoneList2(object.children[i2]));
      }
      return boneList;
    }
    var PointLightHelper = /* @__PURE__ */ function(_Mesh) {
      _inheritsLoose(PointLightHelper2, _Mesh);
      function PointLightHelper2(light, sphereSize, color) {
        var _this;
        var geometry = new SphereGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial2({
          wireframe: true,
          fog: false,
          toneMapped: false
        });
        _this = _Mesh.call(this, geometry, material) || this;
        _this.light = light;
        _this.light.updateMatrixWorld();
        _this.color = color;
        _this.type = "PointLightHelper";
        _this.matrix = _this.light.matrixWorld;
        _this.matrixAutoUpdate = false;
        _this.update();
        return _this;
      }
      var _proto = PointLightHelper2.prototype;
      _proto.dispose = function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      };
      _proto.update = function update() {
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          this.material.color.copy(this.light.color);
        }
      };
      return PointLightHelper2;
    }(Mesh3);
    var _vector$b = /* @__PURE__ */ new Vector32();
    var _color1 = /* @__PURE__ */ new Color5();
    var _color2 = /* @__PURE__ */ new Color5();
    var HemisphereLightHelper = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(HemisphereLightHelper2, _Object3D);
      function HemisphereLightHelper2(light, size, color) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.light = light;
        _this.light.updateMatrixWorld();
        _this.matrix = light.matrixWorld;
        _this.matrixAutoUpdate = false;
        _this.color = color;
        var geometry = new OctahedronGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        _this.material = new MeshBasicMaterial2({
          wireframe: true,
          fog: false,
          toneMapped: false
        });
        if (_this.color === void 0)
          _this.material.vertexColors = true;
        var position = geometry.getAttribute("position");
        var colors = new Float32Array(position.count * 3);
        geometry.setAttribute("color", new BufferAttribute3(colors, 3));
        _this.add(new Mesh3(geometry, _this.material));
        _this.update();
        return _this;
      }
      var _proto = HemisphereLightHelper2.prototype;
      _proto.dispose = function dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      };
      _proto.update = function update() {
        var mesh = this.children[0];
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          var colors = mesh.geometry.getAttribute("color");
          _color1.copy(this.light.color);
          _color2.copy(this.light.groundColor);
          for (var i2 = 0, l = colors.count; i2 < l; i2++) {
            var color = i2 < l / 2 ? _color1 : _color2;
            colors.setXYZ(i2, color.r, color.g, color.b);
          }
          colors.needsUpdate = true;
        }
        mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
      };
      return HemisphereLightHelper2;
    }(Object3D2);
    var GridHelper2 = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(GridHelper3, _LineSegments);
      function GridHelper3(size, divisions, color1, color2) {
        var _this;
        if (size === void 0) {
          size = 10;
        }
        if (divisions === void 0) {
          divisions = 10;
        }
        if (color1 === void 0) {
          color1 = 4473924;
        }
        if (color2 === void 0) {
          color2 = 8947848;
        }
        color1 = new Color5(color1);
        color2 = new Color5(color2);
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
        var vertices = [], colors = [];
        for (var i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
          vertices.push(-halfSize, 0, k, halfSize, 0, k);
          vertices.push(k, 0, -halfSize, k, 0, halfSize);
          var color = i2 === center ? color1 : color2;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
        }
        var geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
        var material = new LineBasicMaterial2({
          vertexColors: true,
          toneMapped: false
        });
        _this = _LineSegments.call(this, geometry, material) || this;
        _this.type = "GridHelper";
        return _this;
      }
      return GridHelper3;
    }(LineSegments2);
    var PolarGridHelper = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(PolarGridHelper2, _LineSegments);
      function PolarGridHelper2(radius, radials, circles, divisions, color1, color2) {
        var _this;
        if (radius === void 0) {
          radius = 10;
        }
        if (radials === void 0) {
          radials = 16;
        }
        if (circles === void 0) {
          circles = 8;
        }
        if (divisions === void 0) {
          divisions = 64;
        }
        if (color1 === void 0) {
          color1 = 4473924;
        }
        if (color2 === void 0) {
          color2 = 8947848;
        }
        color1 = new Color5(color1);
        color2 = new Color5(color2);
        var vertices = [];
        var colors = [];
        for (var i2 = 0; i2 <= radials; i2++) {
          var v = i2 / radials * (Math.PI * 2);
          var x = Math.sin(v) * radius;
          var z = Math.cos(v) * radius;
          vertices.push(0, 0, 0);
          vertices.push(x, 0, z);
          var color = i2 & 1 ? color1 : color2;
          colors.push(color.r, color.g, color.b);
          colors.push(color.r, color.g, color.b);
        }
        for (var _i = 0; _i <= circles; _i++) {
          var _color = _i & 1 ? color1 : color2;
          var r = radius - radius / circles * _i;
          for (var j = 0; j < divisions; j++) {
            var _v = j / divisions * (Math.PI * 2);
            var _x3 = Math.sin(_v) * r;
            var _z3 = Math.cos(_v) * r;
            vertices.push(_x3, 0, _z3);
            colors.push(_color.r, _color.g, _color.b);
            _v = (j + 1) / divisions * (Math.PI * 2);
            _x3 = Math.sin(_v) * r;
            _z3 = Math.cos(_v) * r;
            vertices.push(_x3, 0, _z3);
            colors.push(_color.r, _color.g, _color.b);
          }
        }
        var geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
        var material = new LineBasicMaterial2({
          vertexColors: true,
          toneMapped: false
        });
        _this = _LineSegments.call(this, geometry, material) || this;
        _this.type = "PolarGridHelper";
        return _this;
      }
      return PolarGridHelper2;
    }(LineSegments2);
    var _v1$6 = /* @__PURE__ */ new Vector32();
    var _v2$3 = /* @__PURE__ */ new Vector32();
    var _v3$1 = /* @__PURE__ */ new Vector32();
    var DirectionalLightHelper = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(DirectionalLightHelper2, _Object3D);
      function DirectionalLightHelper2(light, size, color) {
        var _this;
        _this = _Object3D.call(this) || this;
        _this.light = light;
        _this.light.updateMatrixWorld();
        _this.matrix = light.matrixWorld;
        _this.matrixAutoUpdate = false;
        _this.color = color;
        if (size === void 0)
          size = 1;
        var geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
        var material = new LineBasicMaterial2({
          fog: false,
          toneMapped: false
        });
        _this.lightPlane = new Line2(geometry, material);
        _this.add(_this.lightPlane);
        geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 0, 1], 3));
        _this.targetLine = new Line2(geometry, material);
        _this.add(_this.targetLine);
        _this.update();
        return _this;
      }
      var _proto = DirectionalLightHelper2.prototype;
      _proto.dispose = function dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
      };
      _proto.update = function update() {
        _v1$6.setFromMatrixPosition(this.light.matrixWorld);
        _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3$1.subVectors(_v2$3, _v1$6);
        this.lightPlane.lookAt(_v2$3);
        if (this.color !== void 0) {
          this.lightPlane.material.color.set(this.color);
          this.targetLine.material.color.set(this.color);
        } else {
          this.lightPlane.material.color.copy(this.light.color);
          this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2$3);
        this.targetLine.scale.z = _v3$1.length();
      };
      return DirectionalLightHelper2;
    }(Object3D2);
    var _vector$c = /* @__PURE__ */ new Vector32();
    var _camera = /* @__PURE__ */ new Camera2();
    var CameraHelper = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(CameraHelper2, _LineSegments);
      function CameraHelper2(camera2) {
        var _this;
        var geometry = new BufferGeometry3();
        var material = new LineBasicMaterial2({
          color: 16777215,
          vertexColors: true,
          toneMapped: false
        });
        var vertices = [];
        var colors = [];
        var pointMap = {};
        var colorFrustum = new Color5(16755200);
        var colorCone = new Color5(16711680);
        var colorUp = new Color5(43775);
        var colorTarget = new Color5(16777215);
        var colorCross = new Color5(3355443);
        addLine("n1", "n2", colorFrustum);
        addLine("n2", "n4", colorFrustum);
        addLine("n4", "n3", colorFrustum);
        addLine("n3", "n1", colorFrustum);
        addLine("f1", "f2", colorFrustum);
        addLine("f2", "f4", colorFrustum);
        addLine("f4", "f3", colorFrustum);
        addLine("f3", "f1", colorFrustum);
        addLine("n1", "f1", colorFrustum);
        addLine("n2", "f2", colorFrustum);
        addLine("n3", "f3", colorFrustum);
        addLine("n4", "f4", colorFrustum);
        addLine("p", "n1", colorCone);
        addLine("p", "n2", colorCone);
        addLine("p", "n3", colorCone);
        addLine("p", "n4", colorCone);
        addLine("u1", "u2", colorUp);
        addLine("u2", "u3", colorUp);
        addLine("u3", "u1", colorUp);
        addLine("c", "t", colorTarget);
        addLine("p", "c", colorCross);
        addLine("cn1", "cn2", colorCross);
        addLine("cn3", "cn4", colorCross);
        addLine("cf1", "cf2", colorCross);
        addLine("cf3", "cf4", colorCross);
        function addLine(a, b, color) {
          addPoint(a, color);
          addPoint(b, color);
        }
        function addPoint(id, color) {
          vertices.push(0, 0, 0);
          colors.push(color.r, color.g, color.b);
          if (pointMap[id] === void 0) {
            pointMap[id] = [];
          }
          pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
        _this = _LineSegments.call(this, geometry, material) || this;
        _this.type = "CameraHelper";
        _this.camera = camera2;
        if (_this.camera.updateProjectionMatrix)
          _this.camera.updateProjectionMatrix();
        _this.matrix = camera2.matrixWorld;
        _this.matrixAutoUpdate = false;
        _this.pointMap = pointMap;
        _this.update();
        return _this;
      }
      var _proto = CameraHelper2.prototype;
      _proto.update = function update() {
        var geometry = this.geometry;
        var pointMap = this.pointMap;
        var w = 1, h = 1;
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
        setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
        setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
        setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
        setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
        setPoint("n4", pointMap, geometry, _camera, w, h, -1);
        setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
        setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
        setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
        setPoint("f4", pointMap, geometry, _camera, w, h, 1);
        setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
        setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
        setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
        setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
        setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
        setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
        setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
        setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
        setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
        setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
        setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
        geometry.getAttribute("position").needsUpdate = true;
      };
      return CameraHelper2;
    }(LineSegments2);
    function setPoint(point, pointMap, geometry, camera2, x, y, z) {
      _vector$c.set(x, y, z).unproject(camera2);
      var points = pointMap[point];
      if (points !== void 0) {
        var position = geometry.getAttribute("position");
        for (var i2 = 0, l = points.length; i2 < l; i2++) {
          position.setXYZ(points[i2], _vector$c.x, _vector$c.y, _vector$c.z);
        }
      }
    }
    var _box$3 = /* @__PURE__ */ new Box32();
    var BoxHelper = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(BoxHelper2, _LineSegments);
      function BoxHelper2(object, color) {
        var _this;
        if (color === void 0) {
          color = 16776960;
        }
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry3();
        geometry.setIndex(new BufferAttribute3(indices, 1));
        geometry.setAttribute("position", new BufferAttribute3(positions, 3));
        _this = _LineSegments.call(this, geometry, new LineBasicMaterial2({
          color,
          toneMapped: false
        })) || this;
        _this.object = object;
        _this.type = "BoxHelper";
        _this.matrixAutoUpdate = false;
        _this.update();
        return _this;
      }
      var _proto = BoxHelper2.prototype;
      _proto.update = function update(object) {
        if (object !== void 0) {
          console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        }
        if (this.object !== void 0) {
          _box$3.setFromObject(this.object);
        }
        if (_box$3.isEmpty())
          return;
        var min = _box$3.min;
        var max = _box$3.max;
        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      };
      _proto.setFromObject = function setFromObject(object) {
        this.object = object;
        this.update();
        return this;
      };
      _proto.copy = function copy(source) {
        LineSegments2.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
      };
      return BoxHelper2;
    }(LineSegments2);
    var Box3Helper = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(Box3Helper2, _LineSegments);
      function Box3Helper2(box, color) {
        var _this;
        if (color === void 0) {
          color = 16776960;
        }
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        var geometry = new BufferGeometry3();
        geometry.setIndex(new BufferAttribute3(indices, 1));
        geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
        _this = _LineSegments.call(this, geometry, new LineBasicMaterial2({
          color,
          toneMapped: false
        })) || this;
        _this.box = box;
        _this.type = "Box3Helper";
        _this.geometry.computeBoundingSphere();
        return _this;
      }
      var _proto = Box3Helper2.prototype;
      _proto.updateMatrixWorld = function updateMatrixWorld(force) {
        var box = this.box;
        if (box.isEmpty())
          return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        _LineSegments.prototype.updateMatrixWorld.call(this, force);
      };
      return Box3Helper2;
    }(LineSegments2);
    var PlaneHelper = /* @__PURE__ */ function(_Line) {
      _inheritsLoose(PlaneHelper2, _Line);
      function PlaneHelper2(plane, size, hex) {
        var _this;
        if (size === void 0) {
          size = 1;
        }
        if (hex === void 0) {
          hex = 16776960;
        }
        var color = hex;
        var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
        var geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
        geometry.computeBoundingSphere();
        _this = _Line.call(this, geometry, new LineBasicMaterial2({
          color,
          toneMapped: false
        })) || this;
        _this.type = "PlaneHelper";
        _this.plane = plane;
        _this.size = size;
        var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
        var geometry2 = new BufferGeometry3();
        geometry2.setAttribute("position", new Float32BufferAttribute2(positions2, 3));
        geometry2.computeBoundingSphere();
        _this.add(new Mesh3(geometry2, new MeshBasicMaterial2({
          color,
          opacity: 0.2,
          transparent: true,
          depthWrite: false,
          toneMapped: false
        })));
        return _this;
      }
      var _proto = PlaneHelper2.prototype;
      _proto.updateMatrixWorld = function updateMatrixWorld(force) {
        var scale = -this.plane.constant;
        if (Math.abs(scale) < 1e-8)
          scale = 1e-8;
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? BackSide2 : FrontSide2;
        this.lookAt(this.plane.normal);
        _Line.prototype.updateMatrixWorld.call(this, force);
      };
      return PlaneHelper2;
    }(Line2);
    var _axis = /* @__PURE__ */ new Vector32();
    var _lineGeometry, _coneGeometry;
    var ArrowHelper = /* @__PURE__ */ function(_Object3D) {
      _inheritsLoose(ArrowHelper2, _Object3D);
      function ArrowHelper2(dir, origin, length, color, headLength, headWidth) {
        var _this;
        if (dir === void 0) {
          dir = new Vector32(0, 0, 1);
        }
        if (origin === void 0) {
          origin = new Vector32(0, 0, 0);
        }
        if (length === void 0) {
          length = 1;
        }
        if (color === void 0) {
          color = 16776960;
        }
        if (headLength === void 0) {
          headLength = length * 0.2;
        }
        if (headWidth === void 0) {
          headWidth = headLength * 0.2;
        }
        _this = _Object3D.call(this) || this;
        _this.type = "ArrowHelper";
        if (_lineGeometry === void 0) {
          _lineGeometry = new BufferGeometry3();
          _lineGeometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 1, 0], 3));
          _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
          _coneGeometry.translate(0, -0.5, 0);
        }
        _this.position.copy(origin);
        _this.line = new Line2(_lineGeometry, new LineBasicMaterial2({
          color,
          toneMapped: false
        }));
        _this.line.matrixAutoUpdate = false;
        _this.add(_this.line);
        _this.cone = new Mesh3(_coneGeometry, new MeshBasicMaterial2({
          color,
          toneMapped: false
        }));
        _this.cone.matrixAutoUpdate = false;
        _this.add(_this.cone);
        _this.setDirection(dir);
        _this.setLength(length, headLength, headWidth);
        return _this;
      }
      var _proto = ArrowHelper2.prototype;
      _proto.setDirection = function setDirection(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          _axis.set(dir.z, 0, -dir.x).normalize();
          var radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(_axis, radians);
        }
      };
      _proto.setLength = function setLength(length, headLength, headWidth) {
        if (headLength === void 0) {
          headLength = length * 0.2;
        }
        if (headWidth === void 0) {
          headWidth = headLength * 0.2;
        }
        this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
      };
      _proto.setColor = function setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
      };
      _proto.copy = function copy(source) {
        _Object3D.prototype.copy.call(this, source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
      };
      return ArrowHelper2;
    }(Object3D2);
    var AxesHelper = /* @__PURE__ */ function(_LineSegments) {
      _inheritsLoose(AxesHelper2, _LineSegments);
      function AxesHelper2(size) {
        var _this;
        if (size === void 0) {
          size = 1;
        }
        var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
        var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
        var geometry = new BufferGeometry3();
        geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
        var material = new LineBasicMaterial2({
          vertexColors: true,
          toneMapped: false
        });
        _this = _LineSegments.call(this, geometry, material) || this;
        _this.type = "AxesHelper";
        return _this;
      }
      return AxesHelper2;
    }(LineSegments2);
    var _floatView2 = new Float32Array(1);
    var _int32View2 = new Int32Array(_floatView2.buffer);
    var DataUtils = {
      toHalfFloat: function toHalfFloat(val) {
        _floatView2[0] = val;
        var x = _int32View2[0];
        var bits = x >> 16 & 32768;
        var m = x >> 12 & 2047;
        var e = x >> 23 & 255;
        if (e < 103)
          return bits;
        if (e > 142) {
          bits |= 31744;
          bits |= (e == 255 ? 0 : 1) && x & 8388607;
          return bits;
        }
        if (e < 113) {
          m |= 2048;
          bits |= (m >> 114 - e) + (m >> 113 - e & 1);
          return bits;
        }
        bits |= e - 112 << 10 | m >> 1;
        bits += m & 1;
        return bits;
      }
    };
    var _ENCODINGS;
    var LOD_MIN2 = 4;
    var LOD_MAX2 = 8;
    var SIZE_MAX2 = Math.pow(2, LOD_MAX2);
    var EXTRA_LOD_SIGMA2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    var TOTAL_LODS2 = LOD_MAX2 - LOD_MIN2 + 1 + EXTRA_LOD_SIGMA2.length;
    var MAX_SAMPLES = 20;
    var ENCODINGS2 = (_ENCODINGS = {}, _ENCODINGS[LinearEncoding2] = 0, _ENCODINGS[sRGBEncoding2] = 1, _ENCODINGS[RGBEEncoding2] = 2, _ENCODINGS[RGBM7Encoding2] = 3, _ENCODINGS[RGBM16Encoding2] = 4, _ENCODINGS[RGBDEncoding2] = 5, _ENCODINGS[GammaEncoding2] = 6, _ENCODINGS);
    var backgroundMaterial2 = new MeshBasicMaterial2({
      side: BackSide2,
      depthWrite: false,
      depthTest: false
    });
    var backgroundBox2 = new Mesh3(new BoxGeometry2(), backgroundMaterial2);
    var _flatCamera = /* @__PURE__ */ new OrthographicCamera2();
    var _createPlanes2 = /* @__PURE__ */ _createPlanes(), _lodPlanes = _createPlanes2._lodPlanes, _sizeLods = _createPlanes2._sizeLods, _sigmas = _createPlanes2._sigmas;
    var _clearColor = /* @__PURE__ */ new Color5();
    var _oldTarget = null;
    var PHI2 = (1 + Math.sqrt(5)) / 2;
    var INV_PHI2 = 1 / PHI2;
    var _axisDirections2 = [/* @__PURE__ */ new Vector32(1, 1, 1), /* @__PURE__ */ new Vector32(-1, 1, 1), /* @__PURE__ */ new Vector32(1, 1, -1), /* @__PURE__ */ new Vector32(-1, 1, -1), /* @__PURE__ */ new Vector32(0, PHI2, INV_PHI2), /* @__PURE__ */ new Vector32(0, PHI2, -INV_PHI2), /* @__PURE__ */ new Vector32(INV_PHI2, 0, PHI2), /* @__PURE__ */ new Vector32(-INV_PHI2, 0, PHI2), /* @__PURE__ */ new Vector32(PHI2, INV_PHI2, 0), /* @__PURE__ */ new Vector32(-PHI2, INV_PHI2, 0)];
    function convertLinearToRGBE(color) {
      var maxComponent = Math.max(color.r, color.g, color.b);
      var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
      color.multiplyScalar(Math.pow(2, -fExp));
      var alpha = (fExp + 128) / 255;
      return alpha;
    }
    var PMREMGenerator = /* @__PURE__ */ function() {
      function PMREMGenerator2(renderer2) {
        this._renderer = renderer2;
        this._pingPongRenderTarget = null;
        this._blurMaterial = _getBlurShader(MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
      }
      var _proto = PMREMGenerator2.prototype;
      _proto.fromScene = function fromScene(scene2, sigma, near, far) {
        if (sigma === void 0) {
          sigma = 0;
        }
        if (near === void 0) {
          near = 0.1;
        }
        if (far === void 0) {
          far = 100;
        }
        _oldTarget = this._renderer.getRenderTarget();
        var cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene2, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          this._blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      };
      _proto.fromEquirectangular = function fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
      };
      _proto.fromCubemap = function fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
      };
      _proto.compileCubemapShader = function compileCubemapShader() {
        if (this._cubemapShader === null) {
          this._cubemapShader = _getCubemapShader();
          this._compileMaterial(this._cubemapShader);
        }
      };
      _proto.compileEquirectangularShader = function compileEquirectangularShader() {
        if (this._equirectShader === null) {
          this._equirectShader = _getEquirectShader();
          this._compileMaterial(this._equirectShader);
        }
      };
      _proto.dispose = function dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null)
          this._cubemapShader.dispose();
        if (this._equirectShader !== null)
          this._equirectShader.dispose();
        for (var i2 = 0; i2 < _lodPlanes.length; i2++) {
          _lodPlanes[i2].dispose();
        }
      };
      _proto._cleanup = function _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
      };
      _proto._fromTexture = function _fromTexture(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        var cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      };
      _proto._allocateTargets = function _allocateTargets(texture) {
        var params = {
          magFilter: NearestFilter2,
          minFilter: NearestFilter2,
          generateMipmaps: false,
          type: UnsignedByteType2,
          format: RGBEFormat,
          encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding2,
          depthBuffer: false
        };
        var cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
      };
      _proto._compileMaterial = function _compileMaterial(material) {
        var tmpMesh = new Mesh3(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
      };
      _proto._sceneToCubeUV = function _sceneToCubeUV(scene2, near, far, cubeUVRenderTarget) {
        var fov3 = 90;
        var aspect3 = 1;
        var cubeCamera = new PerspectiveCamera3(fov3, aspect3, near, far);
        var upSign = [1, -1, 1, 1, 1, 1];
        var forwardSign = [1, 1, 1, -1, -1, -1];
        var renderer2 = this._renderer;
        var originalAutoClear = renderer2.autoClear;
        var outputEncoding = renderer2.outputEncoding;
        var toneMapping = renderer2.toneMapping;
        renderer2.getClearColor(_clearColor);
        renderer2.toneMapping = NoToneMapping2;
        renderer2.outputEncoding = LinearEncoding2;
        renderer2.autoClear = false;
        var useSolidColor = false;
        var background = scene2.background;
        if (background) {
          if (background.isColor) {
            backgroundMaterial2.color.copy(background).convertSRGBToLinear();
            scene2.background = null;
            var alpha = convertLinearToRGBE(backgroundMaterial2.color);
            backgroundMaterial2.opacity = alpha;
            useSolidColor = true;
          }
        } else {
          backgroundMaterial2.color.copy(_clearColor).convertSRGBToLinear();
          var _alpha = convertLinearToRGBE(backgroundMaterial2.color);
          backgroundMaterial2.opacity = _alpha;
          useSolidColor = true;
        }
        for (var i2 = 0; i2 < 6; i2++) {
          var col = i2 % 3;
          if (col == 0) {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(forwardSign[i2], 0, 0);
          } else if (col == 1) {
            cubeCamera.up.set(0, 0, upSign[i2]);
            cubeCamera.lookAt(0, forwardSign[i2], 0);
          } else {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(0, 0, forwardSign[i2]);
          }
          _setViewport(cubeUVRenderTarget, col * SIZE_MAX2, i2 > 2 ? SIZE_MAX2 : 0, SIZE_MAX2, SIZE_MAX2);
          renderer2.setRenderTarget(cubeUVRenderTarget);
          if (useSolidColor) {
            renderer2.render(backgroundBox2, cubeCamera);
          }
          renderer2.render(scene2, cubeCamera);
        }
        renderer2.toneMapping = toneMapping;
        renderer2.outputEncoding = outputEncoding;
        renderer2.autoClear = originalAutoClear;
      };
      _proto._textureToCubeUV = function _textureToCubeUV(texture, cubeUVRenderTarget) {
        var renderer2 = this._renderer;
        if (texture.isCubeTexture) {
          if (this._cubemapShader == null) {
            this._cubemapShader = _getCubemapShader();
          }
        } else {
          if (this._equirectShader == null) {
            this._equirectShader = _getEquirectShader();
          }
        }
        var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        var mesh = new Mesh3(_lodPlanes[0], material);
        var uniforms = material.uniforms;
        uniforms["envMap"].value = texture;
        if (!texture.isCubeTexture) {
          uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
        }
        uniforms["inputEncoding"].value = ENCODINGS2[texture.encoding];
        uniforms["outputEncoding"].value = ENCODINGS2[cubeUVRenderTarget.texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX2, 2 * SIZE_MAX2);
        renderer2.setRenderTarget(cubeUVRenderTarget);
        renderer2.render(mesh, _flatCamera);
      };
      _proto._applyPMREM = function _applyPMREM(cubeUVRenderTarget) {
        var renderer2 = this._renderer;
        var autoClear = renderer2.autoClear;
        renderer2.autoClear = false;
        for (var i2 = 1; i2 < TOTAL_LODS2; i2++) {
          var sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
          var poleAxis = _axisDirections2[(i2 - 1) % _axisDirections2.length];
          this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
        }
        renderer2.autoClear = autoClear;
      };
      _proto._blur = function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        var pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
      };
      _proto._halfBlur = function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        var renderer2 = this._renderer;
        var blurMaterial = this._blurMaterial;
        if (direction !== "latitudinal" && direction !== "longitudinal") {
          console.error("blur direction must be either latitudinal or longitudinal!");
        }
        var STANDARD_DEVIATIONS = 3;
        var blurMesh = new Mesh3(_lodPlanes[lodOut], blurMaterial);
        var blurUniforms = blurMaterial.uniforms;
        var pixels = _sizeLods[lodIn] - 1;
        var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        var sigmaPixels = sigmaRadians / radiansPerPixel;
        var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
          console.warn("sigmaRadians, " + sigmaRadians + ", is too large and will clip, as it requested " + samples + " samples when the maximum is set to " + MAX_SAMPLES);
        }
        var weights = [];
        var sum = 0;
        for (var i2 = 0; i2 < MAX_SAMPLES; ++i2) {
          var _x3 = i2 / sigmaPixels;
          var weight = Math.exp(-_x3 * _x3 / 2);
          weights.push(weight);
          if (i2 == 0) {
            sum += weight;
          } else if (i2 < samples) {
            sum += 2 * weight;
          }
        }
        for (var _i = 0; _i < weights.length; _i++) {
          weights[_i] = weights[_i] / sum;
        }
        blurUniforms["envMap"].value = targetIn.texture;
        blurUniforms["samples"].value = samples;
        blurUniforms["weights"].value = weights;
        blurUniforms["latitudinal"].value = direction === "latitudinal";
        if (poleAxis) {
          blurUniforms["poleAxis"].value = poleAxis;
        }
        blurUniforms["dTheta"].value = radiansPerPixel;
        blurUniforms["mipInt"].value = LOD_MAX2 - lodIn;
        blurUniforms["inputEncoding"].value = ENCODINGS2[targetIn.texture.encoding];
        blurUniforms["outputEncoding"].value = ENCODINGS2[targetIn.texture.encoding];
        var outputSize = _sizeLods[lodOut];
        var x = 3 * Math.max(0, SIZE_MAX2 - 2 * outputSize);
        var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX2) + 2 * outputSize * (lodOut > LOD_MAX2 - LOD_MIN2 ? lodOut - LOD_MAX2 + LOD_MIN2 : 0);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer2.setRenderTarget(targetOut);
        renderer2.render(blurMesh, _flatCamera);
      };
      return PMREMGenerator2;
    }();
    function _isLDR(texture) {
      if (texture === void 0 || texture.type !== UnsignedByteType2)
        return false;
      return texture.encoding === LinearEncoding2 || texture.encoding === sRGBEncoding2 || texture.encoding === GammaEncoding2;
    }
    function _createPlanes() {
      var _lodPlanes2 = [];
      var _sizeLods2 = [];
      var _sigmas2 = [];
      var lod = LOD_MAX2;
      for (var i2 = 0; i2 < TOTAL_LODS2; i2++) {
        var sizeLod = Math.pow(2, lod);
        _sizeLods2.push(sizeLod);
        var sigma = 1 / sizeLod;
        if (i2 > LOD_MAX2 - LOD_MIN2) {
          sigma = EXTRA_LOD_SIGMA2[i2 - LOD_MAX2 + LOD_MIN2 - 1];
        } else if (i2 == 0) {
          sigma = 0;
        }
        _sigmas2.push(sigma);
        var texelSize = 1 / (sizeLod - 1);
        var min = -texelSize / 2;
        var max = 1 + texelSize / 2;
        var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
        var cubeFaces = 6;
        var vertices = 6;
        var positionSize = 3;
        var uvSize = 2;
        var faceIndexSize = 1;
        var position = new Float32Array(positionSize * vertices * cubeFaces);
        var uv = new Float32Array(uvSize * vertices * cubeFaces);
        var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for (var face = 0; face < cubeFaces; face++) {
          var x = face % 3 * 2 / 3 - 1;
          var y = face > 2 ? 0 : -1;
          var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
          position.set(coordinates, positionSize * vertices * face);
          uv.set(uv1, uvSize * vertices * face);
          var fill = [face, face, face, face, face, face];
          faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        var planes = new BufferGeometry3();
        planes.setAttribute("position", new BufferAttribute3(position, positionSize));
        planes.setAttribute("uv", new BufferAttribute3(uv, uvSize));
        planes.setAttribute("faceIndex", new BufferAttribute3(faceIndex, faceIndexSize));
        _lodPlanes2.push(planes);
        if (lod > LOD_MIN2) {
          lod--;
        }
      }
      return {
        _lodPlanes: _lodPlanes2,
        _sizeLods: _sizeLods2,
        _sigmas: _sigmas2
      };
    }
    function _createRenderTarget(params) {
      var cubeUVRenderTarget = new WebGLRenderTarget2(3 * SIZE_MAX2, 3 * SIZE_MAX2, params);
      cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping2;
      cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
      cubeUVRenderTarget.scissorTest = true;
      return cubeUVRenderTarget;
    }
    function _setViewport(target, x, y, width, height) {
      target.viewport.set(x, y, width, height);
      target.scissor.set(x, y, width, height);
    }
    function _getBlurShader(maxSamples) {
      var weights = new Float32Array(maxSamples);
      var poleAxis = new Vector32(0, 1, 0);
      var shaderMaterial = new RawShaderMaterial2({
        name: "SphericalGaussianBlur",
        defines: {
          n: maxSamples
        },
        uniforms: {
          envMap: {
            value: null
          },
          samples: {
            value: 1
          },
          weights: {
            value: weights
          },
          latitudinal: {
            value: false
          },
          dTheta: {
            value: 0
          },
          mipInt: {
            value: 0
          },
          poleAxis: {
            value: poleAxis
          },
          inputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          },
          outputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			" + _getEncodings() + "\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		",
        blending: NoBlending2,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getEquirectShader() {
      var texelSize = new Vector22(1, 1);
      var shaderMaterial = new RawShaderMaterial2({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          texelSize: {
            value: texelSize
          },
          inputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          },
          outputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform vec2 texelSize;\n\n			" + _getEncodings() + "\n\n			#include <common>\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				vec2 f = fract( uv / texelSize - 0.5 );\n				uv -= f * texelSize;\n				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x += texelSize.x;\n				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.y += texelSize.y;\n				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x -= texelSize.x;\n				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n				vec3 tm = mix( tl, tr, f.x );\n				vec3 bm = mix( bl, br, f.x );\n				gl_FragColor.rgb = mix( tm, bm, f.y );\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		",
        blending: NoBlending2,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getCubemapShader() {
      var shaderMaterial = new RawShaderMaterial2({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          inputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          },
          outputEncoding: {
            value: ENCODINGS2[LinearEncoding2]
          }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			" + _getEncodings() + "\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		",
        blending: NoBlending2,
        depthTest: false,
        depthWrite: false
      });
      return shaderMaterial;
    }
    function _getCommonVertexShader() {
      return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
    }
    function _getEncodings() {
      return "\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	";
    }
    var LineStrip = 0;
    var LinePieces = 1;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    function MeshFaceMaterial(materials) {
      console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
      return materials;
    }
    function MultiMaterial(materials) {
      if (materials === void 0) {
        materials = [];
      }
      console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
      materials.isMultiMaterial = true;
      materials.materials = materials;
      materials.clone = function() {
        return materials.slice();
      };
      return materials;
    }
    function PointCloud(geometry, material) {
      console.warn("THREE.PointCloud has been renamed to THREE.Points.");
      return new Points2(geometry, material);
    }
    function Particle(material) {
      console.warn("THREE.Particle has been renamed to THREE.Sprite.");
      return new Sprite2(material);
    }
    function ParticleSystem(geometry, material) {
      console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
      return new Points2(geometry, material);
    }
    function PointCloudMaterial(parameters) {
      console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial2(parameters);
    }
    function ParticleBasicMaterial(parameters) {
      console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial2(parameters);
    }
    function ParticleSystemMaterial(parameters) {
      console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
      return new PointsMaterial2(parameters);
    }
    function Vertex(x, y, z) {
      console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
      return new Vector32(x, y, z);
    }
    function DynamicBufferAttribute(array, itemSize) {
      console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
      return new BufferAttribute3(array, itemSize).setUsage(DynamicDrawUsage2);
    }
    function Int8Attribute(array, itemSize) {
      console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
      return new Int8BufferAttribute2(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
      console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
      return new Uint8BufferAttribute2(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
      console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
      return new Uint8ClampedBufferAttribute2(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
      console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
      return new Int16BufferAttribute2(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
      console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
      return new Uint16BufferAttribute2(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
      console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
      return new Int32BufferAttribute2(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
      console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
      return new Uint32BufferAttribute2(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
      console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
      return new Float32BufferAttribute2(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
      console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
      return new Float64BufferAttribute2(array, itemSize);
    }
    Curve2.create = function(construct, getPoint) {
      console.log("THREE.Curve.create() has been deprecated");
      construct.prototype = Object.create(Curve2.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;
      return construct;
    };
    Path2.prototype.fromPoints = function(points) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
      return this.setFromPoints(points);
    };
    function AxisHelper(size) {
      console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
      return new AxesHelper(size);
    }
    function BoundingBoxHelper(object, color) {
      console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
      return new BoxHelper(object, color);
    }
    function EdgesHelper(object, hex) {
      console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
      return new LineSegments2(new EdgesGeometry(object.geometry), new LineBasicMaterial2({
        color: hex !== void 0 ? hex : 16777215
      }));
    }
    GridHelper2.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    };
    SkeletonHelper2.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    };
    function WireframeHelper(object, hex) {
      console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
      return new LineSegments2(new WireframeGeometry(object.geometry), new LineBasicMaterial2({
        color: hex !== void 0 ? hex : 16777215
      }));
    }
    Loader2.prototype.extractUrlBase = function(url) {
      console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
      return LoaderUtils2.extractUrlBase(url);
    };
    Loader2.Handlers = {
      add: function add() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      },
      get: function get() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      }
    };
    function XHRLoader(manager) {
      console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
      return new FileLoader2(manager);
    }
    function BinaryTextureLoader(manager) {
      console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
      return new DataTextureLoader2(manager);
    }
    Box22.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box22.prototype.empty = function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box22.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box22.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Box32.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box32.prototype.empty = function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box32.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box32.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Box32.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Sphere2.prototype.empty = function() {
      console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Frustum2.prototype.setFromMatrix = function(m) {
      console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
      return this.setFromProjectionMatrix(m);
    };
    Line32.prototype.center = function(optionalTarget) {
      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    MathUtils2.random16 = function() {
      console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
      return Math.random();
    };
    MathUtils2.nearestPowerOfTwo = function(value) {
      console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
      return MathUtils2.floorPowerOfTwo(value);
    };
    MathUtils2.nextPowerOfTwo = function(value) {
      console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
      return MathUtils2.ceilPowerOfTwo(value);
    };
    Matrix32.prototype.flattenToArrayOffset = function(array, offset) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    };
    Matrix32.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return vector.applyMatrix3(this);
    };
    Matrix32.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    };
    Matrix32.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
      return attribute.applyMatrix3(this);
    };
    Matrix32.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    };
    Matrix32.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Matrix43.prototype.extractPosition = function(m) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(m);
    };
    Matrix43.prototype.flattenToArrayOffset = function(array, offset) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    };
    Matrix43.prototype.getPosition = function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return new Vector32().setFromMatrixColumn(this, 3);
    };
    Matrix43.prototype.setRotationFromQuaternion = function(q) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(q);
    };
    Matrix43.prototype.multiplyToArray = function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    };
    Matrix43.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix43.prototype.multiplyVector4 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix43.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    };
    Matrix43.prototype.rotateAxis = function(v) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      v.transformDirection(this);
    };
    Matrix43.prototype.crossVector = function(vector) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix43.prototype.translate = function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    };
    Matrix43.prototype.rotateX = function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    };
    Matrix43.prototype.rotateY = function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    };
    Matrix43.prototype.rotateZ = function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    };
    Matrix43.prototype.rotateByAxis = function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    };
    Matrix43.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
      return attribute.applyMatrix4(this);
    };
    Matrix43.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    };
    Matrix43.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(left, right, top, bottom, near, far);
    };
    Matrix43.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Plane2.prototype.isIntersectionLine = function(line) {
      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
      return this.intersectsLine(line);
    };
    Quaternion2.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    };
    Quaternion2.prototype.inverse = function() {
      console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
      return this.invert();
    };
    Ray2.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Ray2.prototype.isIntersectionPlane = function(plane) {
      console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
      return this.intersectsPlane(plane);
    };
    Ray2.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Triangle2.prototype.area = function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    };
    Triangle2.prototype.barycoordFromPoint = function(point, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return this.getBarycoord(point, target);
    };
    Triangle2.prototype.midpoint = function(target) {
      console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
      return this.getMidpoint(target);
    };
    Triangle2.prototypenormal = function(target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return this.getNormal(target);
    };
    Triangle2.prototype.plane = function(target) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(target);
    };
    Triangle2.barycoordFromPoint = function(point, a, b, c, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return Triangle2.getBarycoord(point, a, b, c, target);
    };
    Triangle2.normal = function(a, b, c, target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return Triangle2.getNormal(a, b, c, target);
    };
    Shape2.prototype.extractAllPoints = function(divisions) {
      console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
      return this.extractPoints(divisions);
    };
    Shape2.prototype.extrude = function(options) {
      console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
      return new ExtrudeGeometry2(this, options);
    };
    Shape2.prototype.makeGeometry = function(options) {
      console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
      return new ShapeGeometry2(this, options);
    };
    Vector22.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector22.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector22.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector32.prototype.setEulerFromRotationMatrix = function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    };
    Vector32.prototype.setEulerFromQuaternion = function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    };
    Vector32.prototype.getPositionFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(m);
    };
    Vector32.prototype.getScaleFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(m);
    };
    Vector32.prototype.getColumnFromMatrix = function(index, matrix) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(matrix, index);
    };
    Vector32.prototype.applyProjection = function(m) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(m);
    };
    Vector32.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector32.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector32.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector42.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector42.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Object3D2.prototype.getChildByName = function(name2) {
      console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
      return this.getObjectByName(name2);
    };
    Object3D2.prototype.renderDepth = function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    };
    Object3D2.prototype.translate = function(distance, axis) {
      console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
      return this.translateOnAxis(axis, distance);
    };
    Object3D2.prototype.getWorldRotation = function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    };
    Object3D2.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(Object3D2.prototype, {
      eulerOrder: {
        get: function get() {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          return this.rotation.order;
        },
        set: function set(value) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          this.rotation.order = value;
        }
      },
      useQuaternion: {
        get: function get() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function set() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
      }
    });
    Mesh3.prototype.setDrawMode = function() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    };
    Object.defineProperties(Mesh3.prototype, {
      drawMode: {
        get: function get() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
          return TrianglesDrawMode2;
        },
        set: function set() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
      }
    });
    Object.defineProperties(LOD2.prototype, {
      objects: {
        get: function get() {
          console.warn("THREE.LOD: .objects has been renamed to .levels.");
          return this.levels;
        }
      }
    });
    Object.defineProperty(Skeleton2.prototype, "useVertexTexture", {
      get: function get() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
      set: function set() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      }
    });
    SkinnedMesh2.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    };
    Object.defineProperty(Curve2.prototype, "__arcLengthDivisions", {
      get: function get() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions;
      },
      set: function set(value) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = value;
      }
    });
    PerspectiveCamera3.prototype.setLens = function(focalLength, filmGauge) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
      if (filmGauge !== void 0)
        this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light2.prototype, {
      onlyShadow: {
        set: function set() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        }
      },
      shadowCameraFov: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
          this.shadow.camera.fov = value;
        }
      },
      shadowCameraLeft: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
          this.shadow.camera.left = value;
        }
      },
      shadowCameraRight: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
          this.shadow.camera.right = value;
        }
      },
      shadowCameraTop: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
          this.shadow.camera.top = value;
        }
      },
      shadowCameraBottom: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
          this.shadow.camera.bottom = value;
        }
      },
      shadowCameraNear: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
          this.shadow.camera.near = value;
        }
      },
      shadowCameraFar: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
          this.shadow.camera.far = value;
        }
      },
      shadowCameraVisible: {
        set: function set() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
      },
      shadowBias: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
          this.shadow.bias = value;
        }
      },
      shadowDarkness: {
        set: function set() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
      },
      shadowMapWidth: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
          this.shadow.mapSize.width = value;
        }
      },
      shadowMapHeight: {
        set: function set(value) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
          this.shadow.mapSize.height = value;
        }
      }
    });
    Object.defineProperties(BufferAttribute3.prototype, {
      length: {
        get: function get() {
          console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
          return this.array.length;
        }
      },
      dynamic: {
        get: function get() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage2;
        },
        set: function set() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          this.setUsage(DynamicDrawUsage2);
        }
      }
    });
    BufferAttribute3.prototype.setDynamic = function(value) {
      console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage2 : StaticDrawUsage2);
      return this;
    };
    BufferAttribute3.prototype.copyIndicesArray = function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, BufferAttribute3.prototype.setArray = function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    BufferGeometry3.prototype.addIndex = function(index) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
      this.setIndex(index);
    };
    BufferGeometry3.prototype.addAttribute = function(name2, attribute) {
      console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
        return this.setAttribute(name2, new BufferAttribute3(arguments[1], arguments[2]));
      }
      if (name2 === "index") {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
        this.setIndex(attribute);
        return this;
      }
      return this.setAttribute(name2, attribute);
    };
    BufferGeometry3.prototype.addDrawCall = function(start, count, indexOffset) {
      if (indexOffset !== void 0) {
        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
      }
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(start, count);
    };
    BufferGeometry3.prototype.clearDrawCalls = function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
      this.clearGroups();
    };
    BufferGeometry3.prototype.computeOffsets = function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    };
    BufferGeometry3.prototype.removeAttribute = function(name2) {
      console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
      return this.deleteAttribute(name2);
    };
    BufferGeometry3.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(BufferGeometry3.prototype, {
      drawcalls: {
        get: function get() {
          console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
          return this.groups;
        }
      },
      offsets: {
        get: function get() {
          console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
          return this.groups;
        }
      }
    });
    Object.defineProperties(InstancedBufferGeometry2.prototype, {
      maxInstancedCount: {
        get: function get() {
          console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
          return this.instanceCount;
        },
        set: function set(value) {
          console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
          this.instanceCount = value;
        }
      }
    });
    Object.defineProperties(Raycaster2.prototype, {
      linePrecision: {
        get: function get() {
          console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
          return this.params.Line.threshold;
        },
        set: function set(value) {
          console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
          this.params.Line.threshold = value;
        }
      }
    });
    Object.defineProperties(InterleavedBuffer3.prototype, {
      dynamic: {
        get: function get() {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage2;
        },
        set: function set(value) {
          console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
          this.setUsage(value);
        }
      }
    });
    InterleavedBuffer3.prototype.setDynamic = function(value) {
      console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage2 : StaticDrawUsage2);
      return this;
    };
    InterleavedBuffer3.prototype.setArray = function() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    ExtrudeGeometry2.prototype.getArrays = function() {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
    };
    ExtrudeGeometry2.prototype.addShapeList = function() {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
    };
    ExtrudeGeometry2.prototype.addShape = function() {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
    };
    Scene3.prototype.dispose = function() {
      console.error("THREE.Scene: .dispose() has been removed.");
    };
    Object.defineProperties(Uniform2.prototype, {
      dynamic: {
        set: function set() {
          console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        }
      },
      onUpdate: {
        value: function value() {
          console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
          return this;
        }
      }
    });
    Object.defineProperties(Material2.prototype, {
      wrapAround: {
        get: function get() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function set() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }
      },
      overdraw: {
        get: function get() {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function set() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }
      },
      wrapRGB: {
        get: function get() {
          console.warn("THREE.Material: .wrapRGB has been removed.");
          return new Color5();
        }
      },
      shading: {
        get: function get() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function set(value) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = value === FlatShading2;
        }
      },
      stencilMask: {
        get: function get() {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          return this.stencilFuncMask;
        },
        set: function set(value) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          this.stencilFuncMask = value;
        }
      }
    });
    Object.defineProperties(MeshPhongMaterial3.prototype, {
      metal: {
        get: function get() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
          return false;
        },
        set: function set() {
          console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
      }
    });
    Object.defineProperties(MeshPhysicalMaterial2.prototype, {
      transparency: {
        get: function get() {
          console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
          return this.transmission;
        },
        set: function set(value) {
          console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
          this.transmission = value;
        }
      }
    });
    Object.defineProperties(ShaderMaterial2.prototype, {
      derivatives: {
        get: function get() {
          console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          return this.extensions.derivatives;
        },
        set: function set(value) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          this.extensions.derivatives = value;
        }
      }
    });
    WebGLRenderer3.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    };
    WebGLRenderer3.prototype.animate = function(callback) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(callback);
    };
    WebGLRenderer3.prototype.getCurrentRenderTarget = function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    };
    WebGLRenderer3.prototype.getMaxAnisotropy = function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    };
    WebGLRenderer3.prototype.getPrecision = function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    };
    WebGLRenderer3.prototype.resetGLState = function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    };
    WebGLRenderer3.prototype.supportsFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    };
    WebGLRenderer3.prototype.supportsHalfFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    };
    WebGLRenderer3.prototype.supportsStandardDerivatives = function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    };
    WebGLRenderer3.prototype.supportsCompressedTextureS3TC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    };
    WebGLRenderer3.prototype.supportsCompressedTexturePVRTC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    };
    WebGLRenderer3.prototype.supportsBlendMinMax = function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    };
    WebGLRenderer3.prototype.supportsVertexTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    };
    WebGLRenderer3.prototype.supportsInstancedArrays = function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    };
    WebGLRenderer3.prototype.enableScissorTest = function(boolean) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(boolean);
    };
    WebGLRenderer3.prototype.initMaterial = function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    };
    WebGLRenderer3.prototype.addPrePlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    };
    WebGLRenderer3.prototype.addPostPlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    };
    WebGLRenderer3.prototype.updateShadowMap = function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
    WebGLRenderer3.prototype.setFaceCulling = function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    };
    WebGLRenderer3.prototype.allocTextureUnit = function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    };
    WebGLRenderer3.prototype.setTexture = function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    };
    WebGLRenderer3.prototype.setTexture2D = function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    };
    WebGLRenderer3.prototype.setTextureCube = function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    };
    WebGLRenderer3.prototype.getActiveMipMapLevel = function() {
      console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
      return this.getActiveMipmapLevel();
    };
    Object.defineProperties(WebGLRenderer3.prototype, {
      shadowMapEnabled: {
        get: function get() {
          return this.shadowMap.enabled;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
          this.shadowMap.enabled = value;
        }
      },
      shadowMapType: {
        get: function get() {
          return this.shadowMap.type;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
          this.shadowMap.type = value;
        }
      },
      shadowMapCullFace: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      context: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
          return this.getContext();
        }
      },
      vr: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
          return this.xr;
        }
      },
      gammaInput: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          return false;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
      },
      gammaOutput: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          return false;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          this.outputEncoding = value === true ? sRGBEncoding2 : LinearEncoding2;
        }
      },
      toneMappingWhitePoint: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          return 1;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
      }
    });
    Object.defineProperties(WebGLShadowMap2.prototype, {
      cullFace: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      renderReverseSided: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
      },
      renderSingleSided: {
        get: function get() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function set() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
      }
    });
    function WebGLRenderTargetCube(width, height, options) {
      console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
      return new WebGLCubeRenderTarget2(width, options);
    }
    Object.defineProperties(WebGLRenderTarget2.prototype, {
      wrapS: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          return this.texture.wrapS;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          this.texture.wrapS = value;
        }
      },
      wrapT: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          return this.texture.wrapT;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          this.texture.wrapT = value;
        }
      },
      magFilter: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          return this.texture.magFilter;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          this.texture.magFilter = value;
        }
      },
      minFilter: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          return this.texture.minFilter;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          this.texture.minFilter = value;
        }
      },
      anisotropy: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          return this.texture.anisotropy;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          this.texture.anisotropy = value;
        }
      },
      offset: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          return this.texture.offset;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          this.texture.offset = value;
        }
      },
      repeat: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          return this.texture.repeat;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          this.texture.repeat = value;
        }
      },
      format: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          return this.texture.format;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          this.texture.format = value;
        }
      },
      type: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          return this.texture.type;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          this.texture.type = value;
        }
      },
      generateMipmaps: {
        get: function get() {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          return this.texture.generateMipmaps;
        },
        set: function set(value) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          this.texture.generateMipmaps = value;
        }
      }
    });
    Object.defineProperties(Audio2.prototype, {
      load: {
        value: function value(file) {
          console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
          var scope = this;
          var audioLoader = new AudioLoader2();
          audioLoader.load(file, function(buffer) {
            scope.setBuffer(buffer);
          });
          return this;
        }
      },
      startTime: {
        set: function set() {
          console.warn("THREE.Audio: .startTime is now .play( delay ).");
        }
      }
    });
    AudioAnalyser2.prototype.getData = function() {
      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
      return this.getFrequencyData();
    };
    CubeCamera2.prototype.updateCubeMap = function(renderer2, scene2) {
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
      return this.update(renderer2, scene2);
    };
    CubeCamera2.prototype.clear = function(renderer2, color, depth, stencil) {
      console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
      return this.renderTarget.clear(renderer2, color, depth, stencil);
    };
    ImageUtils2.crossOrigin = void 0;
    ImageUtils2.loadTexture = function(url, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      var loader = new TextureLoader2();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(url, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils2.loadTextureCube = function(urls, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      var loader = new CubeTextureLoader2();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(urls, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils2.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils2.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    function CanvasRenderer() {
      console.error("THREE.CanvasRenderer has been removed");
    }
    function JSONLoader() {
      console.error("THREE.JSONLoader has been removed.");
    }
    var SceneUtils = {
      createMultiMaterialObject: function createMultiMaterialObject() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      },
      detach: function detach() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      },
      attach: function attach() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }
    };
    function LensFlare() {
      console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
    }
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: REVISION2
        }
      }));
    }
    if (typeof window !== "undefined") {
      if (window.__THREE__) {
        console.warn("WARNING: Multiple instances of Three.js being imported.");
      } else {
        window.__THREE__ = REVISION2;
      }
    }
    exports3.ACESFilmicToneMapping = ACESFilmicToneMapping2;
    exports3.AddEquation = AddEquation2;
    exports3.AddOperation = AddOperation2;
    exports3.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode2;
    exports3.AdditiveBlending = AdditiveBlending2;
    exports3.AlphaFormat = AlphaFormat2;
    exports3.AlwaysDepth = AlwaysDepth2;
    exports3.AlwaysStencilFunc = AlwaysStencilFunc2;
    exports3.AmbientLight = AmbientLight3;
    exports3.AmbientLightProbe = AmbientLightProbe2;
    exports3.AnimationClip = AnimationClip2;
    exports3.AnimationLoader = AnimationLoader;
    exports3.AnimationMixer = AnimationMixer2;
    exports3.AnimationObjectGroup = AnimationObjectGroup2;
    exports3.AnimationUtils = AnimationUtils2;
    exports3.ArcCurve = ArcCurve2;
    exports3.ArrayCamera = ArrayCamera2;
    exports3.ArrowHelper = ArrowHelper;
    exports3.Audio = Audio2;
    exports3.AudioAnalyser = AudioAnalyser2;
    exports3.AudioContext = AudioContext2;
    exports3.AudioListener = AudioListener;
    exports3.AudioLoader = AudioLoader2;
    exports3.AxesHelper = AxesHelper;
    exports3.AxisHelper = AxisHelper;
    exports3.BackSide = BackSide2;
    exports3.BasicDepthPacking = BasicDepthPacking2;
    exports3.BasicShadowMap = BasicShadowMap;
    exports3.BinaryTextureLoader = BinaryTextureLoader;
    exports3.Bone = Bone2;
    exports3.BooleanKeyframeTrack = BooleanKeyframeTrack2;
    exports3.BoundingBoxHelper = BoundingBoxHelper;
    exports3.Box2 = Box22;
    exports3.Box3 = Box32;
    exports3.Box3Helper = Box3Helper;
    exports3.BoxBufferGeometry = BoxGeometry2;
    exports3.BoxGeometry = BoxGeometry2;
    exports3.BoxHelper = BoxHelper;
    exports3.BufferAttribute = BufferAttribute3;
    exports3.BufferGeometry = BufferGeometry3;
    exports3.BufferGeometryLoader = BufferGeometryLoader;
    exports3.ByteType = ByteType2;
    exports3.Cache = Cache2;
    exports3.Camera = Camera2;
    exports3.CameraHelper = CameraHelper;
    exports3.CanvasRenderer = CanvasRenderer;
    exports3.CanvasTexture = CanvasTexture2;
    exports3.CatmullRomCurve3 = CatmullRomCurve32;
    exports3.CineonToneMapping = CineonToneMapping2;
    exports3.CircleBufferGeometry = CircleGeometry;
    exports3.CircleGeometry = CircleGeometry;
    exports3.ClampToEdgeWrapping = ClampToEdgeWrapping2;
    exports3.Clock = Clock;
    exports3.Color = Color5;
    exports3.ColorKeyframeTrack = ColorKeyframeTrack2;
    exports3.CompressedTexture = CompressedTexture2;
    exports3.CompressedTextureLoader = CompressedTextureLoader2;
    exports3.ConeBufferGeometry = ConeGeometry;
    exports3.ConeGeometry = ConeGeometry;
    exports3.CubeCamera = CubeCamera2;
    exports3.CubeReflectionMapping = CubeReflectionMapping2;
    exports3.CubeRefractionMapping = CubeRefractionMapping2;
    exports3.CubeTexture = CubeTexture2;
    exports3.CubeTextureLoader = CubeTextureLoader2;
    exports3.CubeUVReflectionMapping = CubeUVReflectionMapping2;
    exports3.CubeUVRefractionMapping = CubeUVRefractionMapping2;
    exports3.CubicBezierCurve = CubicBezierCurve2;
    exports3.CubicBezierCurve3 = CubicBezierCurve32;
    exports3.CubicInterpolant = CubicInterpolant2;
    exports3.CullFaceBack = CullFaceBack2;
    exports3.CullFaceFront = CullFaceFront2;
    exports3.CullFaceFrontBack = CullFaceFrontBack;
    exports3.CullFaceNone = CullFaceNone2;
    exports3.Curve = Curve2;
    exports3.CurvePath = CurvePath2;
    exports3.CustomBlending = CustomBlending2;
    exports3.CustomToneMapping = CustomToneMapping2;
    exports3.CylinderBufferGeometry = CylinderGeometry;
    exports3.CylinderGeometry = CylinderGeometry;
    exports3.Cylindrical = Cylindrical;
    exports3.DataTexture = DataTexture2;
    exports3.DataTexture2DArray = DataTexture2DArray2;
    exports3.DataTexture3D = DataTexture3D2;
    exports3.DataTextureLoader = DataTextureLoader2;
    exports3.DataUtils = DataUtils;
    exports3.DecrementStencilOp = DecrementStencilOp;
    exports3.DecrementWrapStencilOp = DecrementWrapStencilOp;
    exports3.DefaultLoadingManager = DefaultLoadingManager2;
    exports3.DepthFormat = DepthFormat2;
    exports3.DepthStencilFormat = DepthStencilFormat2;
    exports3.DepthTexture = DepthTexture2;
    exports3.DirectionalLight = DirectionalLight3;
    exports3.DirectionalLightHelper = DirectionalLightHelper;
    exports3.DiscreteInterpolant = DiscreteInterpolant2;
    exports3.DodecahedronBufferGeometry = DodecahedronGeometry;
    exports3.DodecahedronGeometry = DodecahedronGeometry;
    exports3.DoubleSide = DoubleSide3;
    exports3.DstAlphaFactor = DstAlphaFactor2;
    exports3.DstColorFactor = DstColorFactor2;
    exports3.DynamicBufferAttribute = DynamicBufferAttribute;
    exports3.DynamicCopyUsage = DynamicCopyUsage;
    exports3.DynamicDrawUsage = DynamicDrawUsage2;
    exports3.DynamicReadUsage = DynamicReadUsage;
    exports3.EdgesGeometry = EdgesGeometry;
    exports3.EdgesHelper = EdgesHelper;
    exports3.EllipseCurve = EllipseCurve2;
    exports3.EqualDepth = EqualDepth2;
    exports3.EqualStencilFunc = EqualStencilFunc;
    exports3.EquirectangularReflectionMapping = EquirectangularReflectionMapping2;
    exports3.EquirectangularRefractionMapping = EquirectangularRefractionMapping2;
    exports3.Euler = Euler2;
    exports3.EventDispatcher = EventDispatcher2;
    exports3.ExtrudeBufferGeometry = ExtrudeGeometry2;
    exports3.ExtrudeGeometry = ExtrudeGeometry2;
    exports3.FaceColors = FaceColors;
    exports3.FileLoader = FileLoader2;
    exports3.FlatShading = FlatShading2;
    exports3.Float16BufferAttribute = Float16BufferAttribute2;
    exports3.Float32Attribute = Float32Attribute;
    exports3.Float32BufferAttribute = Float32BufferAttribute2;
    exports3.Float64Attribute = Float64Attribute;
    exports3.Float64BufferAttribute = Float64BufferAttribute2;
    exports3.FloatType = FloatType2;
    exports3.Fog = Fog2;
    exports3.FogExp2 = FogExp22;
    exports3.Font = Font2;
    exports3.FontLoader = FontLoader;
    exports3.FrontSide = FrontSide2;
    exports3.Frustum = Frustum2;
    exports3.GLBufferAttribute = GLBufferAttribute2;
    exports3.GLSL1 = GLSL1;
    exports3.GLSL3 = GLSL32;
    exports3.GammaEncoding = GammaEncoding2;
    exports3.GreaterDepth = GreaterDepth2;
    exports3.GreaterEqualDepth = GreaterEqualDepth2;
    exports3.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
    exports3.GreaterStencilFunc = GreaterStencilFunc;
    exports3.GridHelper = GridHelper2;
    exports3.Group = Group2;
    exports3.HalfFloatType = HalfFloatType2;
    exports3.HemisphereLight = HemisphereLight2;
    exports3.HemisphereLightHelper = HemisphereLightHelper;
    exports3.HemisphereLightProbe = HemisphereLightProbe2;
    exports3.IcosahedronBufferGeometry = IcosahedronGeometry;
    exports3.IcosahedronGeometry = IcosahedronGeometry;
    exports3.ImageBitmapLoader = ImageBitmapLoader2;
    exports3.ImageLoader = ImageLoader2;
    exports3.ImageUtils = ImageUtils2;
    exports3.ImmediateRenderObject = ImmediateRenderObject2;
    exports3.IncrementStencilOp = IncrementStencilOp;
    exports3.IncrementWrapStencilOp = IncrementWrapStencilOp;
    exports3.InstancedBufferAttribute = InstancedBufferAttribute2;
    exports3.InstancedBufferGeometry = InstancedBufferGeometry2;
    exports3.InstancedInterleavedBuffer = InstancedInterleavedBuffer2;
    exports3.InstancedMesh = InstancedMesh2;
    exports3.Int16Attribute = Int16Attribute;
    exports3.Int16BufferAttribute = Int16BufferAttribute2;
    exports3.Int32Attribute = Int32Attribute;
    exports3.Int32BufferAttribute = Int32BufferAttribute2;
    exports3.Int8Attribute = Int8Attribute;
    exports3.Int8BufferAttribute = Int8BufferAttribute2;
    exports3.IntType = IntType2;
    exports3.InterleavedBuffer = InterleavedBuffer3;
    exports3.InterleavedBufferAttribute = InterleavedBufferAttribute3;
    exports3.Interpolant = Interpolant2;
    exports3.InterpolateDiscrete = InterpolateDiscrete2;
    exports3.InterpolateLinear = InterpolateLinear2;
    exports3.InterpolateSmooth = InterpolateSmooth2;
    exports3.InvertStencilOp = InvertStencilOp;
    exports3.JSONLoader = JSONLoader;
    exports3.KeepStencilOp = KeepStencilOp2;
    exports3.KeyframeTrack = KeyframeTrack2;
    exports3.LOD = LOD2;
    exports3.LatheBufferGeometry = LatheGeometry;
    exports3.LatheGeometry = LatheGeometry;
    exports3.Layers = Layers2;
    exports3.LensFlare = LensFlare;
    exports3.LessDepth = LessDepth2;
    exports3.LessEqualDepth = LessEqualDepth2;
    exports3.LessEqualStencilFunc = LessEqualStencilFunc;
    exports3.LessStencilFunc = LessStencilFunc;
    exports3.Light = Light2;
    exports3.LightProbe = LightProbe2;
    exports3.Line = Line2;
    exports3.Line3 = Line32;
    exports3.LineBasicMaterial = LineBasicMaterial2;
    exports3.LineCurve = LineCurve2;
    exports3.LineCurve3 = LineCurve32;
    exports3.LineDashedMaterial = LineDashedMaterial2;
    exports3.LineLoop = LineLoop2;
    exports3.LinePieces = LinePieces;
    exports3.LineSegments = LineSegments2;
    exports3.LineStrip = LineStrip;
    exports3.LinearEncoding = LinearEncoding2;
    exports3.LinearFilter = LinearFilter2;
    exports3.LinearInterpolant = LinearInterpolant2;
    exports3.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports3.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports3.LinearMipmapLinearFilter = LinearMipmapLinearFilter2;
    exports3.LinearMipmapNearestFilter = LinearMipmapNearestFilter2;
    exports3.LinearToneMapping = LinearToneMapping2;
    exports3.Loader = Loader2;
    exports3.LoaderUtils = LoaderUtils2;
    exports3.LoadingManager = LoadingManager2;
    exports3.LogLuvEncoding = LogLuvEncoding2;
    exports3.LoopOnce = LoopOnce2;
    exports3.LoopPingPong = LoopPingPong2;
    exports3.LoopRepeat = LoopRepeat2;
    exports3.LuminanceAlphaFormat = LuminanceAlphaFormat2;
    exports3.LuminanceFormat = LuminanceFormat2;
    exports3.MOUSE = MOUSE2;
    exports3.Material = Material2;
    exports3.MaterialLoader = MaterialLoader;
    exports3.Math = MathUtils2;
    exports3.MathUtils = MathUtils2;
    exports3.Matrix3 = Matrix32;
    exports3.Matrix4 = Matrix43;
    exports3.MaxEquation = MaxEquation2;
    exports3.Mesh = Mesh3;
    exports3.MeshBasicMaterial = MeshBasicMaterial2;
    exports3.MeshDepthMaterial = MeshDepthMaterial2;
    exports3.MeshDistanceMaterial = MeshDistanceMaterial2;
    exports3.MeshFaceMaterial = MeshFaceMaterial;
    exports3.MeshLambertMaterial = MeshLambertMaterial2;
    exports3.MeshMatcapMaterial = MeshMatcapMaterial2;
    exports3.MeshNormalMaterial = MeshNormalMaterial2;
    exports3.MeshPhongMaterial = MeshPhongMaterial3;
    exports3.MeshPhysicalMaterial = MeshPhysicalMaterial2;
    exports3.MeshStandardMaterial = MeshStandardMaterial2;
    exports3.MeshToonMaterial = MeshToonMaterial2;
    exports3.MinEquation = MinEquation2;
    exports3.MirroredRepeatWrapping = MirroredRepeatWrapping2;
    exports3.MixOperation = MixOperation2;
    exports3.MultiMaterial = MultiMaterial;
    exports3.MultiplyBlending = MultiplyBlending2;
    exports3.MultiplyOperation = MultiplyOperation2;
    exports3.NearestFilter = NearestFilter2;
    exports3.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports3.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports3.NearestMipmapLinearFilter = NearestMipmapLinearFilter2;
    exports3.NearestMipmapNearestFilter = NearestMipmapNearestFilter2;
    exports3.NeverDepth = NeverDepth2;
    exports3.NeverStencilFunc = NeverStencilFunc;
    exports3.NoBlending = NoBlending2;
    exports3.NoColors = NoColors;
    exports3.NoToneMapping = NoToneMapping2;
    exports3.NormalAnimationBlendMode = NormalAnimationBlendMode2;
    exports3.NormalBlending = NormalBlending2;
    exports3.NotEqualDepth = NotEqualDepth2;
    exports3.NotEqualStencilFunc = NotEqualStencilFunc;
    exports3.NumberKeyframeTrack = NumberKeyframeTrack2;
    exports3.Object3D = Object3D2;
    exports3.ObjectLoader = ObjectLoader;
    exports3.ObjectSpaceNormalMap = ObjectSpaceNormalMap2;
    exports3.OctahedronBufferGeometry = OctahedronGeometry;
    exports3.OctahedronGeometry = OctahedronGeometry;
    exports3.OneFactor = OneFactor2;
    exports3.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor2;
    exports3.OneMinusDstColorFactor = OneMinusDstColorFactor2;
    exports3.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor2;
    exports3.OneMinusSrcColorFactor = OneMinusSrcColorFactor2;
    exports3.OrthographicCamera = OrthographicCamera2;
    exports3.PCFShadowMap = PCFShadowMap2;
    exports3.PCFSoftShadowMap = PCFSoftShadowMap2;
    exports3.PMREMGenerator = PMREMGenerator;
    exports3.ParametricBufferGeometry = ParametricGeometry2;
    exports3.ParametricGeometry = ParametricGeometry2;
    exports3.Particle = Particle;
    exports3.ParticleBasicMaterial = ParticleBasicMaterial;
    exports3.ParticleSystem = ParticleSystem;
    exports3.ParticleSystemMaterial = ParticleSystemMaterial;
    exports3.Path = Path2;
    exports3.PerspectiveCamera = PerspectiveCamera3;
    exports3.Plane = Plane2;
    exports3.PlaneBufferGeometry = PlaneGeometry2;
    exports3.PlaneGeometry = PlaneGeometry2;
    exports3.PlaneHelper = PlaneHelper;
    exports3.PointCloud = PointCloud;
    exports3.PointCloudMaterial = PointCloudMaterial;
    exports3.PointLight = PointLight2;
    exports3.PointLightHelper = PointLightHelper;
    exports3.Points = Points2;
    exports3.PointsMaterial = PointsMaterial2;
    exports3.PolarGridHelper = PolarGridHelper;
    exports3.PolyhedronBufferGeometry = PolyhedronGeometry;
    exports3.PolyhedronGeometry = PolyhedronGeometry;
    exports3.PositionalAudio = PositionalAudio;
    exports3.PropertyBinding = PropertyBinding2;
    exports3.PropertyMixer = PropertyMixer2;
    exports3.QuadraticBezierCurve = QuadraticBezierCurve2;
    exports3.QuadraticBezierCurve3 = QuadraticBezierCurve32;
    exports3.Quaternion = Quaternion2;
    exports3.QuaternionKeyframeTrack = QuaternionKeyframeTrack2;
    exports3.QuaternionLinearInterpolant = QuaternionLinearInterpolant2;
    exports3.REVISION = REVISION2;
    exports3.RGBADepthPacking = RGBADepthPacking2;
    exports3.RGBAFormat = RGBAFormat2;
    exports3.RGBAIntegerFormat = RGBAIntegerFormat2;
    exports3.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format2;
    exports3.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format2;
    exports3.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format2;
    exports3.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format2;
    exports3.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format2;
    exports3.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format2;
    exports3.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format2;
    exports3.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format2;
    exports3.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format2;
    exports3.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format2;
    exports3.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format2;
    exports3.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format2;
    exports3.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format2;
    exports3.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format2;
    exports3.RGBA_BPTC_Format = RGBA_BPTC_Format2;
    exports3.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format2;
    exports3.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format2;
    exports3.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format2;
    exports3.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format2;
    exports3.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format2;
    exports3.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format2;
    exports3.RGBDEncoding = RGBDEncoding2;
    exports3.RGBEEncoding = RGBEEncoding2;
    exports3.RGBEFormat = RGBEFormat;
    exports3.RGBFormat = RGBFormat2;
    exports3.RGBIntegerFormat = RGBIntegerFormat2;
    exports3.RGBM16Encoding = RGBM16Encoding2;
    exports3.RGBM7Encoding = RGBM7Encoding2;
    exports3.RGB_ETC1_Format = RGB_ETC1_Format2;
    exports3.RGB_ETC2_Format = RGB_ETC2_Format2;
    exports3.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format2;
    exports3.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format2;
    exports3.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format2;
    exports3.RGFormat = RGFormat2;
    exports3.RGIntegerFormat = RGIntegerFormat2;
    exports3.RawShaderMaterial = RawShaderMaterial2;
    exports3.Ray = Ray2;
    exports3.Raycaster = Raycaster2;
    exports3.RectAreaLight = RectAreaLight2;
    exports3.RedFormat = RedFormat2;
    exports3.RedIntegerFormat = RedIntegerFormat2;
    exports3.ReinhardToneMapping = ReinhardToneMapping2;
    exports3.RepeatWrapping = RepeatWrapping2;
    exports3.ReplaceStencilOp = ReplaceStencilOp;
    exports3.ReverseSubtractEquation = ReverseSubtractEquation2;
    exports3.RingBufferGeometry = RingGeometry;
    exports3.RingGeometry = RingGeometry;
    exports3.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format2;
    exports3.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format2;
    exports3.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format2;
    exports3.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format2;
    exports3.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format2;
    exports3.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format2;
    exports3.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format2;
    exports3.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format2;
    exports3.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format2;
    exports3.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format2;
    exports3.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format2;
    exports3.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format2;
    exports3.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format2;
    exports3.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format2;
    exports3.Scene = Scene3;
    exports3.SceneUtils = SceneUtils;
    exports3.ShaderChunk = ShaderChunk2;
    exports3.ShaderLib = ShaderLib2;
    exports3.ShaderMaterial = ShaderMaterial2;
    exports3.ShadowMaterial = ShadowMaterial2;
    exports3.Shape = Shape2;
    exports3.ShapeBufferGeometry = ShapeGeometry2;
    exports3.ShapeGeometry = ShapeGeometry2;
    exports3.ShapePath = ShapePath2;
    exports3.ShapeUtils = ShapeUtils2;
    exports3.ShortType = ShortType2;
    exports3.Skeleton = Skeleton2;
    exports3.SkeletonHelper = SkeletonHelper2;
    exports3.SkinnedMesh = SkinnedMesh2;
    exports3.SmoothShading = SmoothShading;
    exports3.Sphere = Sphere2;
    exports3.SphereBufferGeometry = SphereGeometry;
    exports3.SphereGeometry = SphereGeometry;
    exports3.Spherical = Spherical2;
    exports3.SphericalHarmonics3 = SphericalHarmonics32;
    exports3.SplineCurve = SplineCurve2;
    exports3.SpotLight = SpotLight2;
    exports3.SpotLightHelper = SpotLightHelper;
    exports3.Sprite = Sprite2;
    exports3.SpriteMaterial = SpriteMaterial2;
    exports3.SrcAlphaFactor = SrcAlphaFactor2;
    exports3.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor2;
    exports3.SrcColorFactor = SrcColorFactor2;
    exports3.StaticCopyUsage = StaticCopyUsage;
    exports3.StaticDrawUsage = StaticDrawUsage2;
    exports3.StaticReadUsage = StaticReadUsage;
    exports3.StereoCamera = StereoCamera;
    exports3.StreamCopyUsage = StreamCopyUsage;
    exports3.StreamDrawUsage = StreamDrawUsage;
    exports3.StreamReadUsage = StreamReadUsage;
    exports3.StringKeyframeTrack = StringKeyframeTrack2;
    exports3.SubtractEquation = SubtractEquation2;
    exports3.SubtractiveBlending = SubtractiveBlending2;
    exports3.TOUCH = TOUCH2;
    exports3.TangentSpaceNormalMap = TangentSpaceNormalMap2;
    exports3.TetrahedronBufferGeometry = TetrahedronGeometry;
    exports3.TetrahedronGeometry = TetrahedronGeometry;
    exports3.TextBufferGeometry = TextGeometry;
    exports3.TextGeometry = TextGeometry;
    exports3.Texture = Texture2;
    exports3.TextureLoader = TextureLoader2;
    exports3.TorusBufferGeometry = TorusGeometry;
    exports3.TorusGeometry = TorusGeometry;
    exports3.TorusKnotBufferGeometry = TorusKnotGeometry;
    exports3.TorusKnotGeometry = TorusKnotGeometry;
    exports3.Triangle = Triangle2;
    exports3.TriangleFanDrawMode = TriangleFanDrawMode;
    exports3.TriangleStripDrawMode = TriangleStripDrawMode;
    exports3.TrianglesDrawMode = TrianglesDrawMode2;
    exports3.TubeBufferGeometry = TubeGeometry;
    exports3.TubeGeometry = TubeGeometry;
    exports3.UVMapping = UVMapping2;
    exports3.Uint16Attribute = Uint16Attribute;
    exports3.Uint16BufferAttribute = Uint16BufferAttribute2;
    exports3.Uint32Attribute = Uint32Attribute;
    exports3.Uint32BufferAttribute = Uint32BufferAttribute2;
    exports3.Uint8Attribute = Uint8Attribute;
    exports3.Uint8BufferAttribute = Uint8BufferAttribute2;
    exports3.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports3.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute2;
    exports3.Uniform = Uniform2;
    exports3.UniformsLib = UniformsLib2;
    exports3.UniformsUtils = UniformsUtils2;
    exports3.UnsignedByteType = UnsignedByteType2;
    exports3.UnsignedInt248Type = UnsignedInt248Type2;
    exports3.UnsignedIntType = UnsignedIntType2;
    exports3.UnsignedShort4444Type = UnsignedShort4444Type2;
    exports3.UnsignedShort5551Type = UnsignedShort5551Type2;
    exports3.UnsignedShort565Type = UnsignedShort565Type2;
    exports3.UnsignedShortType = UnsignedShortType2;
    exports3.VSMShadowMap = VSMShadowMap2;
    exports3.Vector2 = Vector22;
    exports3.Vector3 = Vector32;
    exports3.Vector4 = Vector42;
    exports3.VectorKeyframeTrack = VectorKeyframeTrack2;
    exports3.Vertex = Vertex;
    exports3.VertexColors = VertexColors;
    exports3.VideoTexture = VideoTexture2;
    exports3.WebGL1Renderer = WebGL1Renderer2;
    exports3.WebGLCubeRenderTarget = WebGLCubeRenderTarget2;
    exports3.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget2;
    exports3.WebGLRenderTarget = WebGLRenderTarget2;
    exports3.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports3.WebGLRenderer = WebGLRenderer3;
    exports3.WebGLUtils = WebGLUtils2;
    exports3.WireframeGeometry = WireframeGeometry;
    exports3.WireframeHelper = WireframeHelper;
    exports3.WrapAroundEnding = WrapAroundEnding2;
    exports3.XHRLoader = XHRLoader;
    exports3.ZeroCurvatureEnding = ZeroCurvatureEnding2;
    exports3.ZeroFactor = ZeroFactor2;
    exports3.ZeroSlopeEnding = ZeroSlopeEnding2;
    exports3.ZeroStencilOp = ZeroStencilOp;
    exports3.sRGBEncoding = sRGBEncoding2;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// dist/ifc2x4.ts
var IFCACTIONREQUEST = 3821786052;
var IFCACTOR = 2296667514;
var IFCACTORROLE = 3630933823;
var IFCACTUATOR = 4288193352;
var IFCACTUATORTYPE = 2874132201;
var IFCADDRESS = 618182010;
var IFCADVANCEDBREP = 1635779807;
var IFCADVANCEDBREPWITHVOIDS = 2603310189;
var IFCADVANCEDFACE = 3406155212;
var IFCAIRTERMINAL = 1634111441;
var IFCAIRTERMINALBOX = 177149247;
var IFCAIRTERMINALBOXTYPE = 1411407467;
var IFCAIRTERMINALTYPE = 3352864051;
var IFCAIRTOAIRHEATRECOVERY = 2056796094;
var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
var IFCALARM = 3087945054;
var IFCALARMTYPE = 3001207471;
var IFCALIGNMENT = 325726236;
var IFCALIGNMENT2DHORIZONTAL = 749761778;
var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
var IFCALIGNMENT2DSEGMENT = 2483840362;
var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
var IFCALIGNMENT2DVERSEGLINE = 3239324667;
var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
var IFCALIGNMENT2DVERTICAL = 53199957;
var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
var IFCALIGNMENTCURVE = 3512275521;
var IFCANNOTATION = 1674181508;
var IFCANNOTATIONFILLAREA = 669184980;
var IFCAPPLICATION = 639542469;
var IFCAPPLIEDVALUE = 411424972;
var IFCAPPROVAL = 130549933;
var IFCAPPROVALRELATIONSHIP = 3869604511;
var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
var IFCARBITRARYOPENPROFILEDEF = 1310608509;
var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
var IFCASSET = 3460190687;
var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
var IFCAUDIOVISUALAPPLIANCE = 277319702;
var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
var IFCAXIS1PLACEMENT = 4261334040;
var IFCAXIS2PLACEMENT2D = 3125803723;
var IFCAXIS2PLACEMENT3D = 2740243338;
var IFCBSPLINECURVE = 1967976161;
var IFCBSPLINECURVEWITHKNOTS = 2461110595;
var IFCBSPLINESURFACE = 2887950389;
var IFCBSPLINESURFACEWITHKNOTS = 167062518;
var IFCBEAM = 753842376;
var IFCBEAMSTANDARDCASE = 2906023776;
var IFCBEAMTYPE = 819618141;
var IFCBEARING = 4196446775;
var IFCBEARINGTYPE = 3649138523;
var IFCBLOBTEXTURE = 616511568;
var IFCBLOCK = 1334484129;
var IFCBOILER = 32344328;
var IFCBOILERTYPE = 231477066;
var IFCBOOLEANCLIPPINGRESULT = 3649129432;
var IFCBOOLEANRESULT = 2736907675;
var IFCBOUNDARYCONDITION = 4037036970;
var IFCBOUNDARYCURVE = 1136057603;
var IFCBOUNDARYEDGECONDITION = 1560379544;
var IFCBOUNDARYFACECONDITION = 3367102660;
var IFCBOUNDARYNODECONDITION = 1387855156;
var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
var IFCBOUNDEDCURVE = 1260505505;
var IFCBOUNDEDSURFACE = 4182860854;
var IFCBOUNDINGBOX = 2581212453;
var IFCBOXEDHALFSPACE = 2713105998;
var IFCBRIDGE = 644574406;
var IFCBRIDGEPART = 963979645;
var IFCBUILDING = 4031249490;
var IFCBUILDINGELEMENT = 3299480353;
var IFCBUILDINGELEMENTPART = 2979338954;
var IFCBUILDINGELEMENTPARTTYPE = 39481116;
var IFCBUILDINGELEMENTPROXY = 1095909175;
var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
var IFCBUILDINGELEMENTTYPE = 1950629157;
var IFCBUILDINGSTOREY = 3124254112;
var IFCBUILDINGSYSTEM = 1177604601;
var IFCBURNER = 2938176219;
var IFCBURNERTYPE = 2188180465;
var IFCCSHAPEPROFILEDEF = 2898889636;
var IFCCABLECARRIERFITTING = 635142910;
var IFCCABLECARRIERFITTINGTYPE = 395041908;
var IFCCABLECARRIERSEGMENT = 3758799889;
var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
var IFCCABLEFITTING = 1051757585;
var IFCCABLEFITTINGTYPE = 2674252688;
var IFCCABLESEGMENT = 4217484030;
var IFCCABLESEGMENTTYPE = 1285652485;
var IFCCAISSONFOUNDATION = 3999819293;
var IFCCAISSONFOUNDATIONTYPE = 3203706013;
var IFCCARTESIANPOINT = 1123145078;
var IFCCARTESIANPOINTLIST = 574549367;
var IFCCARTESIANPOINTLIST2D = 1675464909;
var IFCCARTESIANPOINTLIST3D = 2059837836;
var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
var IFCCENTERLINEPROFILEDEF = 3150382593;
var IFCCHILLER = 3902619387;
var IFCCHILLERTYPE = 2951183804;
var IFCCHIMNEY = 3296154744;
var IFCCHIMNEYTYPE = 2197970202;
var IFCCIRCLE = 2611217952;
var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
var IFCCIRCLEPROFILEDEF = 1383045692;
var IFCCIRCULARARCSEGMENT2D = 1062206242;
var IFCCIVILELEMENT = 1677625105;
var IFCCIVILELEMENTTYPE = 3893394355;
var IFCCLASSIFICATION = 747523909;
var IFCCLASSIFICATIONREFERENCE = 647927063;
var IFCCLOSEDSHELL = 2205249479;
var IFCCOIL = 639361253;
var IFCCOILTYPE = 2301859152;
var IFCCOLOURRGB = 776857604;
var IFCCOLOURRGBLIST = 3285139300;
var IFCCOLOURSPECIFICATION = 3264961684;
var IFCCOLUMN = 843113511;
var IFCCOLUMNSTANDARDCASE = 905975707;
var IFCCOLUMNTYPE = 300633059;
var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
var IFCCOMPLEXPROPERTY = 2542286263;
var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
var IFCCOMPOSITECURVE = 3732776249;
var IFCCOMPOSITECURVEONSURFACE = 15328376;
var IFCCOMPOSITECURVESEGMENT = 2485617015;
var IFCCOMPOSITEPROFILEDEF = 1485152156;
var IFCCOMPRESSOR = 3571504051;
var IFCCOMPRESSORTYPE = 3850581409;
var IFCCONDENSER = 2272882330;
var IFCCONDENSERTYPE = 2816379211;
var IFCCONIC = 2510884976;
var IFCCONNECTEDFACESET = 370225590;
var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
var IFCCONNECTIONGEOMETRY = 2859738748;
var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
var IFCCONSTRAINT = 1959218052;
var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
var IFCCONSTRUCTIONRESOURCE = 2559216714;
var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
var IFCCONTEXT = 3419103109;
var IFCCONTEXTDEPENDENTUNIT = 3050246964;
var IFCCONTROL = 3293443760;
var IFCCONTROLLER = 25142252;
var IFCCONTROLLERTYPE = 578613899;
var IFCCONVERSIONBASEDUNIT = 2889183280;
var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
var IFCCOOLEDBEAM = 4136498852;
var IFCCOOLEDBEAMTYPE = 335055490;
var IFCCOOLINGTOWER = 3640358203;
var IFCCOOLINGTOWERTYPE = 2954562838;
var IFCCOORDINATEOPERATION = 1785450214;
var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
var IFCCOSTITEM = 3895139033;
var IFCCOSTSCHEDULE = 1419761937;
var IFCCOSTVALUE = 602808272;
var IFCCOVERING = 1973544240;
var IFCCOVERINGTYPE = 1916426348;
var IFCCREWRESOURCE = 3295246426;
var IFCCREWRESOURCETYPE = 1815067380;
var IFCCSGPRIMITIVE3D = 2506170314;
var IFCCSGSOLID = 2147822146;
var IFCCURRENCYRELATIONSHIP = 539742890;
var IFCCURTAINWALL = 3495092785;
var IFCCURTAINWALLTYPE = 1457835157;
var IFCCURVE = 2601014836;
var IFCCURVEBOUNDEDPLANE = 2827736869;
var IFCCURVEBOUNDEDSURFACE = 2629017746;
var IFCCURVESEGMENT2D = 1186437898;
var IFCCURVESTYLE = 3800577675;
var IFCCURVESTYLEFONT = 1105321065;
var IFCCURVESTYLEFONTANDSCALING = 2367409068;
var IFCCURVESTYLEFONTPATTERN = 3510044353;
var IFCCYLINDRICALSURFACE = 1213902940;
var IFCDAMPER = 4074379575;
var IFCDAMPERTYPE = 3961806047;
var IFCDEEPFOUNDATION = 3426335179;
var IFCDEEPFOUNDATIONTYPE = 1306400036;
var IFCDERIVEDPROFILEDEF = 3632507154;
var IFCDERIVEDUNIT = 1765591967;
var IFCDERIVEDUNITELEMENT = 1045800335;
var IFCDIMENSIONALEXPONENTS = 2949456006;
var IFCDIRECTION = 32440307;
var IFCDISCRETEACCESSORY = 1335981549;
var IFCDISCRETEACCESSORYTYPE = 2635815018;
var IFCDISTANCEEXPRESSION = 1945343521;
var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
var IFCDISTRIBUTIONCIRCUIT = 562808652;
var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
var IFCDISTRIBUTIONELEMENT = 1945004755;
var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
var IFCDISTRIBUTIONPORT = 3041715199;
var IFCDISTRIBUTIONSYSTEM = 3205830791;
var IFCDOCUMENTINFORMATION = 1154170062;
var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
var IFCDOCUMENTREFERENCE = 3732053477;
var IFCDOOR = 395920057;
var IFCDOORLININGPROPERTIES = 2963535650;
var IFCDOORPANELPROPERTIES = 1714330368;
var IFCDOORSTANDARDCASE = 3242481149;
var IFCDOORSTYLE = 526551008;
var IFCDOORTYPE = 2323601079;
var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
var IFCDUCTFITTING = 342316401;
var IFCDUCTFITTINGTYPE = 869906466;
var IFCDUCTSEGMENT = 3518393246;
var IFCDUCTSEGMENTTYPE = 3760055223;
var IFCDUCTSILENCER = 1360408905;
var IFCDUCTSILENCERTYPE = 2030761528;
var IFCEDGE = 3900360178;
var IFCEDGECURVE = 476780140;
var IFCEDGELOOP = 1472233963;
var IFCELECTRICAPPLIANCE = 1904799276;
var IFCELECTRICAPPLIANCETYPE = 663422040;
var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
var IFCELECTRICGENERATOR = 264262732;
var IFCELECTRICGENERATORTYPE = 1534661035;
var IFCELECTRICMOTOR = 402227799;
var IFCELECTRICMOTORTYPE = 1217240411;
var IFCELECTRICTIMECONTROL = 1003880860;
var IFCELECTRICTIMECONTROLTYPE = 712377611;
var IFCELEMENT = 1758889154;
var IFCELEMENTASSEMBLY = 4123344466;
var IFCELEMENTASSEMBLYTYPE = 2397081782;
var IFCELEMENTCOMPONENT = 1623761950;
var IFCELEMENTCOMPONENTTYPE = 2590856083;
var IFCELEMENTQUANTITY = 1883228015;
var IFCELEMENTTYPE = 339256511;
var IFCELEMENTARYSURFACE = 2777663545;
var IFCELLIPSE = 1704287377;
var IFCELLIPSEPROFILEDEF = 2835456948;
var IFCENERGYCONVERSIONDEVICE = 1658829314;
var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
var IFCENGINE = 2814081492;
var IFCENGINETYPE = 132023988;
var IFCEVAPORATIVECOOLER = 3747195512;
var IFCEVAPORATIVECOOLERTYPE = 3174744832;
var IFCEVAPORATOR = 484807127;
var IFCEVAPORATORTYPE = 3390157468;
var IFCEVENT = 4148101412;
var IFCEVENTTIME = 211053100;
var IFCEVENTTYPE = 4024345920;
var IFCEXTENDEDPROPERTIES = 297599258;
var IFCEXTERNALINFORMATION = 4294318154;
var IFCEXTERNALREFERENCE = 3200245327;
var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
var IFCEXTERNALSPATIALELEMENT = 1209101575;
var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
var IFCEXTRUDEDAREASOLID = 477187591;
var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
var IFCFACE = 2556980723;
var IFCFACEBASEDSURFACEMODEL = 2047409740;
var IFCFACEBOUND = 1809719519;
var IFCFACEOUTERBOUND = 803316827;
var IFCFACESURFACE = 3008276851;
var IFCFACETEDBREP = 807026263;
var IFCFACETEDBREPWITHVOIDS = 3737207727;
var IFCFACILITY = 24185140;
var IFCFACILITYPART = 1310830890;
var IFCFAILURECONNECTIONCONDITION = 4219587988;
var IFCFAN = 3415622556;
var IFCFANTYPE = 346874300;
var IFCFASTENER = 647756555;
var IFCFASTENERTYPE = 2489546625;
var IFCFEATUREELEMENT = 2827207264;
var IFCFEATUREELEMENTADDITION = 2143335405;
var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
var IFCFILLAREASTYLE = 738692330;
var IFCFILLAREASTYLEHATCHING = 374418227;
var IFCFILLAREASTYLETILES = 315944413;
var IFCFILTER = 819412036;
var IFCFILTERTYPE = 1810631287;
var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
var IFCFLOWCONTROLLER = 2058353004;
var IFCFLOWCONTROLLERTYPE = 3907093117;
var IFCFLOWFITTING = 4278956645;
var IFCFLOWFITTINGTYPE = 3198132628;
var IFCFLOWINSTRUMENT = 182646315;
var IFCFLOWINSTRUMENTTYPE = 4037862832;
var IFCFLOWMETER = 2188021234;
var IFCFLOWMETERTYPE = 3815607619;
var IFCFLOWMOVINGDEVICE = 3132237377;
var IFCFLOWMOVINGDEVICETYPE = 1482959167;
var IFCFLOWSEGMENT = 987401354;
var IFCFLOWSEGMENTTYPE = 1834744321;
var IFCFLOWSTORAGEDEVICE = 707683696;
var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
var IFCFLOWTERMINAL = 2223149337;
var IFCFLOWTERMINALTYPE = 2297155007;
var IFCFLOWTREATMENTDEVICE = 3508470533;
var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
var IFCFOOTING = 900683007;
var IFCFOOTINGTYPE = 1893162501;
var IFCFURNISHINGELEMENT = 263784265;
var IFCFURNISHINGELEMENTTYPE = 4238390223;
var IFCFURNITURE = 1509553395;
var IFCFURNITURETYPE = 1268542332;
var IFCGEOGRAPHICELEMENT = 3493046030;
var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
var IFCGEOMETRICCURVESET = 987898635;
var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
var IFCGEOMETRICSET = 3590301190;
var IFCGRID = 3009204131;
var IFCGRIDAXIS = 852622518;
var IFCGRIDPLACEMENT = 178086475;
var IFCGROUP = 2706460486;
var IFCHALFSPACESOLID = 812098782;
var IFCHEATEXCHANGER = 3319311131;
var IFCHEATEXCHANGERTYPE = 1251058090;
var IFCHUMIDIFIER = 2068733104;
var IFCHUMIDIFIERTYPE = 1806887404;
var IFCISHAPEPROFILEDEF = 1484403080;
var IFCIMAGETEXTURE = 3905492369;
var IFCINDEXEDCOLOURMAP = 3570813810;
var IFCINDEXEDPOLYCURVE = 2571569899;
var IFCINDEXEDPOLYGONALFACE = 178912537;
var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
var IFCINDEXEDTEXTUREMAP = 1437953363;
var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
var IFCINTERCEPTOR = 4175244083;
var IFCINTERCEPTORTYPE = 3946677679;
var IFCINTERSECTIONCURVE = 3113134337;
var IFCINVENTORY = 2391368822;
var IFCIRREGULARTIMESERIES = 3741457305;
var IFCIRREGULARTIMESERIESVALUE = 3020489413;
var IFCJUNCTIONBOX = 2176052936;
var IFCJUNCTIONBOXTYPE = 4288270099;
var IFCLSHAPEPROFILEDEF = 572779678;
var IFCLABORRESOURCE = 3827777499;
var IFCLABORRESOURCETYPE = 428585644;
var IFCLAGTIME = 1585845231;
var IFCLAMP = 76236018;
var IFCLAMPTYPE = 1051575348;
var IFCLIBRARYINFORMATION = 2655187982;
var IFCLIBRARYREFERENCE = 3452421091;
var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
var IFCLIGHTFIXTURE = 629592764;
var IFCLIGHTFIXTURETYPE = 1161773419;
var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
var IFCLIGHTSOURCE = 1402838566;
var IFCLIGHTSOURCEAMBIENT = 125510826;
var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
var IFCLIGHTSOURCESPOT = 3422422726;
var IFCLINE = 1281925730;
var IFCLINESEGMENT2D = 3092502836;
var IFCLINEARPLACEMENT = 388784114;
var IFCLINEARPOSITIONINGELEMENT = 1154579445;
var IFCLOCALPLACEMENT = 2624227202;
var IFCLOOP = 1008929658;
var IFCMANIFOLDSOLIDBREP = 1425443689;
var IFCMAPCONVERSION = 3057273783;
var IFCMAPPEDITEM = 2347385850;
var IFCMATERIAL = 1838606355;
var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
var IFCMATERIALCONSTITUENT = 3708119e3;
var IFCMATERIALCONSTITUENTSET = 2852063980;
var IFCMATERIALDEFINITION = 760658860;
var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
var IFCMATERIALLAYER = 248100487;
var IFCMATERIALLAYERSET = 3303938423;
var IFCMATERIALLAYERSETUSAGE = 1303795690;
var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
var IFCMATERIALLIST = 2199411900;
var IFCMATERIALPROFILE = 2235152071;
var IFCMATERIALPROFILESET = 164193824;
var IFCMATERIALPROFILESETUSAGE = 3079605661;
var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
var IFCMATERIALPROPERTIES = 3265635763;
var IFCMATERIALRELATIONSHIP = 853536259;
var IFCMATERIALUSAGEDEFINITION = 1507914824;
var IFCMEASUREWITHUNIT = 2597039031;
var IFCMECHANICALFASTENER = 377706215;
var IFCMECHANICALFASTENERTYPE = 2108223431;
var IFCMEDICALDEVICE = 1437502449;
var IFCMEDICALDEVICETYPE = 1114901282;
var IFCMEMBER = 1073191201;
var IFCMEMBERSTANDARDCASE = 1911478936;
var IFCMEMBERTYPE = 3181161470;
var IFCMETRIC = 3368373690;
var IFCMIRROREDPROFILEDEF = 2998442950;
var IFCMONETARYUNIT = 2706619895;
var IFCMOTORCONNECTION = 2474470126;
var IFCMOTORCONNECTIONTYPE = 977012517;
var IFCNAMEDUNIT = 1918398963;
var IFCOBJECT = 3888040117;
var IFCOBJECTDEFINITION = 219451334;
var IFCOBJECTPLACEMENT = 3701648758;
var IFCOBJECTIVE = 2251480897;
var IFCOCCUPANT = 4143007308;
var IFCOFFSETCURVE = 590820931;
var IFCOFFSETCURVE2D = 3388369263;
var IFCOFFSETCURVE3D = 3505215534;
var IFCOFFSETCURVEBYDISTANCES = 2485787929;
var IFCOPENSHELL = 2665983363;
var IFCOPENINGELEMENT = 3588315303;
var IFCOPENINGSTANDARDCASE = 3079942009;
var IFCORGANIZATION = 4251960020;
var IFCORGANIZATIONRELATIONSHIP = 1411181986;
var IFCORIENTATIONEXPRESSION = 643959842;
var IFCORIENTEDEDGE = 1029017970;
var IFCOUTERBOUNDARYCURVE = 144952367;
var IFCOUTLET = 3694346114;
var IFCOUTLETTYPE = 2837617999;
var IFCOWNERHISTORY = 1207048766;
var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
var IFCPATH = 2519244187;
var IFCPCURVE = 1682466193;
var IFCPERFORMANCEHISTORY = 2382730787;
var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
var IFCPERMIT = 3327091369;
var IFCPERSON = 2077209135;
var IFCPERSONANDORGANIZATION = 101040310;
var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
var IFCPHYSICALQUANTITY = 2483315170;
var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
var IFCPILE = 1687234759;
var IFCPILETYPE = 1158309216;
var IFCPIPEFITTING = 310824031;
var IFCPIPEFITTINGTYPE = 804291784;
var IFCPIPESEGMENT = 3612865200;
var IFCPIPESEGMENTTYPE = 4231323485;
var IFCPIXELTEXTURE = 597895409;
var IFCPLACEMENT = 2004835150;
var IFCPLANARBOX = 603570806;
var IFCPLANAREXTENT = 1663979128;
var IFCPLANE = 220341763;
var IFCPLATE = 3171933400;
var IFCPLATESTANDARDCASE = 1156407060;
var IFCPLATETYPE = 4017108033;
var IFCPOINT = 2067069095;
var IFCPOINTONCURVE = 4022376103;
var IFCPOINTONSURFACE = 1423911732;
var IFCPOLYLOOP = 2924175390;
var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
var IFCPOLYGONALFACESET = 2839578677;
var IFCPOLYLINE = 3724593414;
var IFCPORT = 3740093272;
var IFCPOSITIONINGELEMENT = 1946335990;
var IFCPOSTALADDRESS = 3355820592;
var IFCPREDEFINEDCOLOUR = 759155922;
var IFCPREDEFINEDCURVEFONT = 2559016684;
var IFCPREDEFINEDITEM = 3727388367;
var IFCPREDEFINEDPROPERTIES = 3778827333;
var IFCPREDEFINEDPROPERTYSET = 3967405729;
var IFCPREDEFINEDTEXTFONT = 1775413392;
var IFCPRESENTATIONITEM = 677532197;
var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
var IFCPRESENTATIONSTYLE = 3119450353;
var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
var IFCPROCEDURE = 2744685151;
var IFCPROCEDURETYPE = 569719735;
var IFCPROCESS = 2945172077;
var IFCPRODUCT = 4208778838;
var IFCPRODUCTDEFINITIONSHAPE = 673634403;
var IFCPRODUCTREPRESENTATION = 2095639259;
var IFCPROFILEDEF = 3958567839;
var IFCPROFILEPROPERTIES = 2802850158;
var IFCPROJECT = 103090709;
var IFCPROJECTLIBRARY = 653396225;
var IFCPROJECTORDER = 2904328755;
var IFCPROJECTEDCRS = 3843373140;
var IFCPROJECTIONELEMENT = 3651124850;
var IFCPROPERTY = 2598011224;
var IFCPROPERTYABSTRACTION = 986844984;
var IFCPROPERTYBOUNDEDVALUE = 871118103;
var IFCPROPERTYDEFINITION = 1680319473;
var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
var IFCPROPERTYENUMERATEDVALUE = 4166981789;
var IFCPROPERTYENUMERATION = 3710013099;
var IFCPROPERTYLISTVALUE = 2752243245;
var IFCPROPERTYREFERENCEVALUE = 941946838;
var IFCPROPERTYSET = 1451395588;
var IFCPROPERTYSETDEFINITION = 3357820518;
var IFCPROPERTYSETTEMPLATE = 492091185;
var IFCPROPERTYSINGLEVALUE = 3650150729;
var IFCPROPERTYTABLEVALUE = 110355661;
var IFCPROPERTYTEMPLATE = 3521284610;
var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
var IFCPROTECTIVEDEVICE = 738039164;
var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
var IFCPROTECTIVEDEVICETYPE = 1842657554;
var IFCPROXY = 3219374653;
var IFCPUMP = 90941305;
var IFCPUMPTYPE = 2250791053;
var IFCQUANTITYAREA = 2044713172;
var IFCQUANTITYCOUNT = 2093928680;
var IFCQUANTITYLENGTH = 931644368;
var IFCQUANTITYSET = 2090586900;
var IFCQUANTITYTIME = 3252649465;
var IFCQUANTITYVOLUME = 2405470396;
var IFCQUANTITYWEIGHT = 825690147;
var IFCRAILING = 2262370178;
var IFCRAILINGTYPE = 2893384427;
var IFCRAMP = 3024970846;
var IFCRAMPFLIGHT = 3283111854;
var IFCRAMPFLIGHTTYPE = 2324767716;
var IFCRAMPTYPE = 1469900589;
var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
var IFCRECTANGLEPROFILEDEF = 3615266464;
var IFCRECTANGULARPYRAMID = 2798486643;
var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
var IFCRECURRENCEPATTERN = 3915482550;
var IFCREFERENCE = 2433181523;
var IFCREFERENT = 4021432810;
var IFCREGULARTIMESERIES = 3413951693;
var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
var IFCREINFORCINGBAR = 979691226;
var IFCREINFORCINGBARTYPE = 2572171363;
var IFCREINFORCINGELEMENT = 3027567501;
var IFCREINFORCINGELEMENTTYPE = 964333572;
var IFCREINFORCINGMESH = 2320036040;
var IFCREINFORCINGMESHTYPE = 2310774935;
var IFCRELAGGREGATES = 160246688;
var IFCRELASSIGNS = 3939117080;
var IFCRELASSIGNSTOACTOR = 1683148259;
var IFCRELASSIGNSTOCONTROL = 2495723537;
var IFCRELASSIGNSTOGROUP = 1307041759;
var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
var IFCRELASSIGNSTOPROCESS = 4278684876;
var IFCRELASSIGNSTOPRODUCT = 2857406711;
var IFCRELASSIGNSTORESOURCE = 205026976;
var IFCRELASSOCIATES = 1865459582;
var IFCRELASSOCIATESAPPROVAL = 4095574036;
var IFCRELASSOCIATESCLASSIFICATION = 919958153;
var IFCRELASSOCIATESCONSTRAINT = 2728634034;
var IFCRELASSOCIATESDOCUMENT = 982818633;
var IFCRELASSOCIATESLIBRARY = 3840914261;
var IFCRELASSOCIATESMATERIAL = 2655215786;
var IFCRELCONNECTS = 826625072;
var IFCRELCONNECTSELEMENTS = 1204542856;
var IFCRELCONNECTSPATHELEMENTS = 3945020480;
var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
var IFCRELCONNECTSPORTS = 3190031847;
var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
var IFCRELCOVERSBLDGELEMENTS = 886880790;
var IFCRELCOVERSSPACES = 2802773753;
var IFCRELDECLARES = 2565941209;
var IFCRELDECOMPOSES = 2551354335;
var IFCRELDEFINES = 693640335;
var IFCRELDEFINESBYOBJECT = 1462361463;
var IFCRELDEFINESBYPROPERTIES = 4186316022;
var IFCRELDEFINESBYTEMPLATE = 307848117;
var IFCRELDEFINESBYTYPE = 781010003;
var IFCRELFILLSELEMENT = 3940055652;
var IFCRELFLOWCONTROLELEMENTS = 279856033;
var IFCRELINTERFERESELEMENTS = 427948657;
var IFCRELNESTS = 3268803585;
var IFCRELPOSITIONS = 1441486842;
var IFCRELPROJECTSELEMENT = 750771296;
var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
var IFCRELSEQUENCE = 4122056220;
var IFCRELSERVICESBUILDINGS = 366585022;
var IFCRELSPACEBOUNDARY = 3451746338;
var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
var IFCRELVOIDSELEMENT = 1401173127;
var IFCRELATIONSHIP = 478536968;
var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
var IFCREPRESENTATION = 1076942058;
var IFCREPRESENTATIONCONTEXT = 3377609919;
var IFCREPRESENTATIONITEM = 3008791417;
var IFCREPRESENTATIONMAP = 1660063152;
var IFCRESOURCE = 2914609552;
var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
var IFCRESOURCETIME = 1042787934;
var IFCREVOLVEDAREASOLID = 1856042241;
var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
var IFCRIGHTCIRCULARCONE = 4158566097;
var IFCRIGHTCIRCULARCYLINDER = 3626867408;
var IFCROOF = 2016517767;
var IFCROOFTYPE = 2781568857;
var IFCROOT = 2341007311;
var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
var IFCSIUNIT = 448429030;
var IFCSANITARYTERMINAL = 3053780830;
var IFCSANITARYTERMINALTYPE = 1768891740;
var IFCSCHEDULINGTIME = 1054537805;
var IFCSEAMCURVE = 2157484638;
var IFCSECTIONPROPERTIES = 2042790032;
var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
var IFCSECTIONEDSOLID = 1862484736;
var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
var IFCSECTIONEDSPINE = 1509187699;
var IFCSENSOR = 4086658281;
var IFCSENSORTYPE = 1783015770;
var IFCSHADINGDEVICE = 1329646415;
var IFCSHADINGDEVICETYPE = 4074543187;
var IFCSHAPEASPECT = 867548509;
var IFCSHAPEMODEL = 3982875396;
var IFCSHAPEREPRESENTATION = 4240577450;
var IFCSHELLBASEDSURFACEMODEL = 4124623270;
var IFCSIMPLEPROPERTY = 3692461612;
var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
var IFCSITE = 4097777520;
var IFCSLAB = 1529196076;
var IFCSLABELEMENTEDCASE = 3127900445;
var IFCSLABSTANDARDCASE = 3027962421;
var IFCSLABTYPE = 2533589738;
var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
var IFCSOLARDEVICE = 3420628829;
var IFCSOLARDEVICETYPE = 1072016465;
var IFCSOLIDMODEL = 723233188;
var IFCSPACE = 3856911033;
var IFCSPACEHEATER = 1999602285;
var IFCSPACEHEATERTYPE = 1305183839;
var IFCSPACETYPE = 3812236995;
var IFCSPATIALELEMENT = 1412071761;
var IFCSPATIALELEMENTTYPE = 710998568;
var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
var IFCSPATIALZONE = 463610769;
var IFCSPATIALZONETYPE = 2481509218;
var IFCSPHERE = 451544542;
var IFCSPHERICALSURFACE = 4015995234;
var IFCSTACKTERMINAL = 1404847402;
var IFCSTACKTERMINALTYPE = 3112655638;
var IFCSTAIR = 331165859;
var IFCSTAIRFLIGHT = 4252922144;
var IFCSTAIRFLIGHTTYPE = 1039846685;
var IFCSTAIRTYPE = 338393293;
var IFCSTRUCTURALACTION = 682877961;
var IFCSTRUCTURALACTIVITY = 3544373492;
var IFCSTRUCTURALANALYSISMODEL = 2515109513;
var IFCSTRUCTURALCONNECTION = 1179482911;
var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
var IFCSTRUCTURALCURVEACTION = 1004757350;
var IFCSTRUCTURALCURVECONNECTION = 4243806635;
var IFCSTRUCTURALCURVEMEMBER = 214636428;
var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
var IFCSTRUCTURALCURVEREACTION = 2757150158;
var IFCSTRUCTURALITEM = 3136571912;
var IFCSTRUCTURALLINEARACTION = 1807405624;
var IFCSTRUCTURALLOAD = 2162789131;
var IFCSTRUCTURALLOADCASE = 385403989;
var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
var IFCSTRUCTURALLOADGROUP = 1252848954;
var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
var IFCSTRUCTURALLOADORRESULT = 609421318;
var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
var IFCSTRUCTURALLOADSTATIC = 2525727697;
var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
var IFCSTRUCTURALMEMBER = 530289379;
var IFCSTRUCTURALPLANARACTION = 1621171031;
var IFCSTRUCTURALPOINTACTION = 2082059205;
var IFCSTRUCTURALPOINTCONNECTION = 734778138;
var IFCSTRUCTURALPOINTREACTION = 1235345126;
var IFCSTRUCTURALREACTION = 3689010777;
var IFCSTRUCTURALRESULTGROUP = 2986769608;
var IFCSTRUCTURALSURFACEACTION = 3657597509;
var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
var IFCSTRUCTURALSURFACEREACTION = 603775116;
var IFCSTYLEMODEL = 2830218821;
var IFCSTYLEDITEM = 3958052878;
var IFCSTYLEDREPRESENTATION = 3049322572;
var IFCSUBCONTRACTRESOURCE = 148013059;
var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
var IFCSUBEDGE = 2233826070;
var IFCSURFACE = 2513912981;
var IFCSURFACECURVE = 699246055;
var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
var IFCSURFACEFEATURE = 3101698114;
var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
var IFCSURFACEOFREVOLUTION = 4124788165;
var IFCSURFACEREINFORCEMENTAREA = 2934153892;
var IFCSURFACESTYLE = 1300840506;
var IFCSURFACESTYLELIGHTING = 3303107099;
var IFCSURFACESTYLEREFRACTION = 1607154358;
var IFCSURFACESTYLERENDERING = 1878645084;
var IFCSURFACESTYLESHADING = 846575682;
var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
var IFCSURFACETEXTURE = 626085974;
var IFCSWEPTAREASOLID = 2247615214;
var IFCSWEPTDISKSOLID = 1260650574;
var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
var IFCSWEPTSURFACE = 230924584;
var IFCSWITCHINGDEVICE = 1162798199;
var IFCSWITCHINGDEVICETYPE = 2315554128;
var IFCSYSTEM = 2254336722;
var IFCSYSTEMFURNITUREELEMENT = 413509423;
var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
var IFCTSHAPEPROFILEDEF = 3071757647;
var IFCTABLE = 985171141;
var IFCTABLECOLUMN = 2043862942;
var IFCTABLEROW = 531007025;
var IFCTANK = 812556717;
var IFCTANKTYPE = 5716631;
var IFCTASK = 3473067441;
var IFCTASKTIME = 1549132990;
var IFCTASKTIMERECURRING = 2771591690;
var IFCTASKTYPE = 3206491090;
var IFCTELECOMADDRESS = 912023232;
var IFCTENDON = 3824725483;
var IFCTENDONANCHOR = 2347447852;
var IFCTENDONANCHORTYPE = 3081323446;
var IFCTENDONCONDUIT = 3663046924;
var IFCTENDONCONDUITTYPE = 2281632017;
var IFCTENDONTYPE = 2415094496;
var IFCTESSELLATEDFACESET = 2387106220;
var IFCTESSELLATEDITEM = 901063453;
var IFCTEXTLITERAL = 4282788508;
var IFCTEXTLITERALWITHEXTENT = 3124975700;
var IFCTEXTSTYLE = 1447204868;
var IFCTEXTSTYLEFONTMODEL = 1983826977;
var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
var IFCTEXTSTYLETEXTMODEL = 1640371178;
var IFCTEXTURECOORDINATE = 280115917;
var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
var IFCTEXTUREMAP = 2552916305;
var IFCTEXTUREVERTEX = 1210645708;
var IFCTEXTUREVERTEXLIST = 3611470254;
var IFCTIMEPERIOD = 1199560280;
var IFCTIMESERIES = 3101149627;
var IFCTIMESERIESVALUE = 581633288;
var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
var IFCTOPOLOGYREPRESENTATION = 1735638870;
var IFCTOROIDALSURFACE = 1935646853;
var IFCTRANSFORMER = 3825984169;
var IFCTRANSFORMERTYPE = 1692211062;
var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
var IFCTRANSPORTELEMENT = 1620046519;
var IFCTRANSPORTELEMENTTYPE = 2097647324;
var IFCTRAPEZIUMPROFILEDEF = 2715220739;
var IFCTRIANGULATEDFACESET = 2916149573;
var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
var IFCTRIMMEDCURVE = 3593883385;
var IFCTUBEBUNDLE = 3026737570;
var IFCTUBEBUNDLETYPE = 1600972822;
var IFCTYPEOBJECT = 1628702193;
var IFCTYPEPROCESS = 3736923433;
var IFCTYPEPRODUCT = 2347495698;
var IFCTYPERESOURCE = 3698973494;
var IFCUSHAPEPROFILEDEF = 427810014;
var IFCUNITASSIGNMENT = 180925521;
var IFCUNITARYCONTROLELEMENT = 630975310;
var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
var IFCUNITARYEQUIPMENT = 4292641817;
var IFCUNITARYEQUIPMENTTYPE = 1911125066;
var IFCVALVE = 4207607924;
var IFCVALVETYPE = 728799441;
var IFCVECTOR = 1417489154;
var IFCVERTEX = 2799835756;
var IFCVERTEXLOOP = 2759199220;
var IFCVERTEXPOINT = 1907098498;
var IFCVIBRATIONDAMPER = 1530820697;
var IFCVIBRATIONDAMPERTYPE = 3956297820;
var IFCVIBRATIONISOLATOR = 2391383451;
var IFCVIBRATIONISOLATORTYPE = 3313531582;
var IFCVIRTUALELEMENT = 2769231204;
var IFCVIRTUALGRIDINTERSECTION = 891718957;
var IFCVOIDINGFEATURE = 926996030;
var IFCWALL = 2391406946;
var IFCWALLELEMENTEDCASE = 4156078855;
var IFCWALLSTANDARDCASE = 3512223829;
var IFCWALLTYPE = 1898987631;
var IFCWASTETERMINAL = 4237592921;
var IFCWASTETERMINALTYPE = 1133259667;
var IFCWINDOW = 3304561284;
var IFCWINDOWLININGPROPERTIES = 336235671;
var IFCWINDOWPANELPROPERTIES = 512836454;
var IFCWINDOWSTANDARDCASE = 486154966;
var IFCWINDOWSTYLE = 1299126871;
var IFCWINDOWTYPE = 4009809668;
var IFCWORKCALENDAR = 4088093105;
var IFCWORKCONTROL = 1028945134;
var IFCWORKPLAN = 4218914973;
var IFCWORKSCHEDULE = 3342526732;
var IFCWORKTIME = 1236880293;
var IFCZSHAPEPROFILEDEF = 2543172580;
var IFCZONE = 1033361043;

// dist/ifc2x4_helper.ts
var FromRawLineData = {};
FromRawLineData[IFCACTIONREQUEST] = (d) => {
  return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTOR] = (d) => {
  return IfcActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTORROLE] = (d) => {
  return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATOR] = (d) => {
  return IfcActuator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATORTYPE] = (d) => {
  return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADDRESS] = (d) => {
  return IfcAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREP] = (d) => {
  return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
  return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDFACE] = (d) => {
  return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINAL] = (d) => {
  return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
  return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
  return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
  return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
  return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
  return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARM] = (d) => {
  return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARMTYPE] = (d) => {
  return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT] = (d) => {
  return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
  return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
  return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
  return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
  return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
  return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
  return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
  return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
  return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
  return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATION] = (d) => {
  return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
  return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLICATION] = (d) => {
  return IfcApplication.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
  return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVAL] = (d) => {
  return IfcApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
  return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
  return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
  return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
  return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASSET] = (d) => {
  return IfcAsset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
  return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
  return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
  return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
  return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
  return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
  return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVE] = (d) => {
  return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACE] = (d) => {
  return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAM] = (d) => {
  return IfcBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
  return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMTYPE] = (d) => {
  return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARING] = (d) => {
  return IfcBearing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARINGTYPE] = (d) => {
  return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOBTEXTURE] = (d) => {
  return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOCK] = (d) => {
  return IfcBlock.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILER] = (d) => {
  return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILERTYPE] = (d) => {
  return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
  return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANRESULT] = (d) => {
  return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
  return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
  return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
  return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
  return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
  return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
  return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
  return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
  return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDINGBOX] = (d) => {
  return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
  return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGE] = (d) => {
  return IfcBridge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGEPART] = (d) => {
  return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDING] = (d) => {
  return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
  return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
  return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
  return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
  return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
  return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
  return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
  return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
  return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNER] = (d) => {
  return IfcBurner.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNERTYPE] = (d) => {
  return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
  return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
  return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
  return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
  return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
  return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTING] = (d) => {
  return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
  return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENT] = (d) => {
  return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
  return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
  return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
  return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINT] = (d) => {
  return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
  return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
  return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
  return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
  return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
  return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
  return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
  return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLER] = (d) => {
  return IfcChiller.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLERTYPE] = (d) => {
  return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEY] = (d) => {
  return IfcChimney.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
  return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLE] = (d) => {
  return IfcCircle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
  return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
  return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
  return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENT] = (d) => {
  return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
  return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATION] = (d) => {
  return IfcClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
  return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLOSEDSHELL] = (d) => {
  return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOIL] = (d) => {
  return IfcCoil.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOILTYPE] = (d) => {
  return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGB] = (d) => {
  return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
  return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
  return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMN] = (d) => {
  return IfcColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
  return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNTYPE] = (d) => {
  return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
  return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
  return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
  return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
  return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
  return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
  return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
  return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
  return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSOR] = (d) => {
  return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
  return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSER] = (d) => {
  return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSERTYPE] = (d) => {
  return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONIC] = (d) => {
  return IfcConic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
  return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
  return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
  return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
  return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
  return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
  return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
  return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRAINT] = (d) => {
  return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
  return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
  return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
  return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
  return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
  return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
  return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
  return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
  return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXT] = (d) => {
  return IfcContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
  return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROL] = (d) => {
  return IfcControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLER] = (d) => {
  return IfcController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
  return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
  return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
  return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAM] = (d) => {
  return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
  return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWER] = (d) => {
  return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
  return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
  return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
  return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTITEM] = (d) => {
  return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
  return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTVALUE] = (d) => {
  return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERING] = (d) => {
  return IfcCovering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERINGTYPE] = (d) => {
  return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCE] = (d) => {
  return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
  return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
  return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGSOLID] = (d) => {
  return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
  return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALL] = (d) => {
  return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
  return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVE] = (d) => {
  return IfcCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
  return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
  return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
  return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLE] = (d) => {
  return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
  return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
  return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
  return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
  return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPER] = (d) => {
  return IfcDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPERTYPE] = (d) => {
  return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
  return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
  return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
  return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNIT] = (d) => {
  return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
  return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
  return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIRECTION] = (d) => {
  return IfcDirection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
  return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
  return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
  return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
  return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
  return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
  return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
  return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
  return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
  return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
  return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
  return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
  return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
  return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
  return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
  return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
  return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
  return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOOR] = (d) => {
  return IfcDoor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
  return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
  return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
  return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTYLE] = (d) => {
  return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORTYPE] = (d) => {
  return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
  return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
  return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTING] = (d) => {
  return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
  return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENT] = (d) => {
  return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
  return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCER] = (d) => {
  return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
  return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGE] = (d) => {
  return IfcEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGECURVE] = (d) => {
  return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGELOOP] = (d) => {
  return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
  return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
  return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
  return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
  return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
  return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
  return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
  return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTOR] = (d) => {
  return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
  return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
  return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
  return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENT] = (d) => {
  return IfcElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
  return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
  return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
  return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
  return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
  return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTTYPE] = (d) => {
  return IfcElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
  return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSE] = (d) => {
  return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
  return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
  return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
  return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINE] = (d) => {
  return IfcEngine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINETYPE] = (d) => {
  return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
  return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
  return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATOR] = (d) => {
  return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
  return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENT] = (d) => {
  return IfcEvent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTIME] = (d) => {
  return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTYPE] = (d) => {
  return IfcEventType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
  return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
  return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
  return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
  return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
  return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
  return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
  return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
  return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
  return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
  return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACE] = (d) => {
  return IfcFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
  return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBOUND] = (d) => {
  return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
  return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACESURFACE] = (d) => {
  return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREP] = (d) => {
  return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
  return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITY] = (d) => {
  return IfcFacility.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITYPART] = (d) => {
  return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
  return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAN] = (d) => {
  return IfcFan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFANTYPE] = (d) => {
  return IfcFanType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENER] = (d) => {
  return IfcFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENERTYPE] = (d) => {
  return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENT] = (d) => {
  return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
  return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
  return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLE] = (d) => {
  return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
  return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
  return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTER] = (d) => {
  return IfcFilter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTERTYPE] = (d) => {
  return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
  return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
  return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
  return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
  return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
  return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTING] = (d) => {
  return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
  return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
  return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
  return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETER] = (d) => {
  return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
  return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
  return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
  return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENT] = (d) => {
  return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
  return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
  return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINAL] = (d) => {
  return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
  return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
  return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
  return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTING] = (d) => {
  return IfcFooting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTINGTYPE] = (d) => {
  return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
  return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
  return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURE] = (d) => {
  return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURETYPE] = (d) => {
  return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
  return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
  return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
  return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
  return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
  return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
  return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICSET] = (d) => {
  return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRID] = (d) => {
  return IfcGrid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDAXIS] = (d) => {
  return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
  return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGROUP] = (d) => {
  return IfcGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHALFSPACESOLID] = (d) => {
  return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGER] = (d) => {
  return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
  return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIER] = (d) => {
  return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
  return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
  return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIMAGETEXTURE] = (d) => {
  return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
  return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
  return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
  return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
  return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
  return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
  return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTOR] = (d) => {
  return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
  return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
  return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINVENTORY] = (d) => {
  return IfcInventory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
  return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
  return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOX] = (d) => {
  return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
  return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
  return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCE] = (d) => {
  return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
  return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAGTIME] = (d) => {
  return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMP] = (d) => {
  return IfcLamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMPTYPE] = (d) => {
  return IfcLampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
  return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
  return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
  return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
  return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
  return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
  return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCE] = (d) => {
  return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
  return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
  return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
  return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
  return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
  return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINE] = (d) => {
  return IfcLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINESEGMENT2D] = (d) => {
  return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
  return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
  return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
  return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOOP] = (d) => {
  return IfcLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
  return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPCONVERSION] = (d) => {
  return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPPEDITEM] = (d) => {
  return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIAL] = (d) => {
  return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
  return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
  return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
  return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
  return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
  return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYER] = (d) => {
  return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
  return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
  return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
  return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLIST] = (d) => {
  return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILE] = (d) => {
  return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
  return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
  return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
  return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
  return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
  return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
  return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
  return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
  return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
  return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
  return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICE] = (d) => {
  return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
  return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBER] = (d) => {
  return IfcMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
  return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERTYPE] = (d) => {
  return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMETRIC] = (d) => {
  return IfcMetric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
  return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMONETARYUNIT] = (d) => {
  return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTION] = (d) => {
  return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
  return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCNAMEDUNIT] = (d) => {
  return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECT] = (d) => {
  return IfcObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
  return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
  return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTIVE] = (d) => {
  return IfcObjective.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOCCUPANT] = (d) => {
  return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE] = (d) => {
  return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
  return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
  return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
  return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENSHELL] = (d) => {
  return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGELEMENT] = (d) => {
  return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
  return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATION] = (d) => {
  return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
  return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
  return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTEDEDGE] = (d) => {
  return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
  return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLET] = (d) => {
  return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLETTYPE] = (d) => {
  return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOWNERHISTORY] = (d) => {
  return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
  return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPATH] = (d) => {
  return IfcPath.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPCURVE] = (d) => {
  return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
  return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
  return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMIT] = (d) => {
  return IfcPermit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSON] = (d) => {
  return IfcPerson.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
  return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
  return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
  return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
  return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILE] = (d) => {
  return IfcPile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILETYPE] = (d) => {
  return IfcPileType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTING] = (d) => {
  return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
  return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENT] = (d) => {
  return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
  return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIXELTEXTURE] = (d) => {
  return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLACEMENT] = (d) => {
  return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANARBOX] = (d) => {
  return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANAREXTENT] = (d) => {
  return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANE] = (d) => {
  return IfcPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATE] = (d) => {
  return IfcPlate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
  return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATETYPE] = (d) => {
  return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINT] = (d) => {
  return IfcPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONCURVE] = (d) => {
  return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONSURFACE] = (d) => {
  return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLOOP] = (d) => {
  return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
  return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
  return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLINE] = (d) => {
  return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPORT] = (d) => {
  return IfcPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
  return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSTALADDRESS] = (d) => {
  return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
  return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
  return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
  return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
  return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
  return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
  return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
  return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
  return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
  return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
  return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
  return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURE] = (d) => {
  return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURETYPE] = (d) => {
  return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCESS] = (d) => {
  return IfcProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCT] = (d) => {
  return IfcProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
  return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
  return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEDEF] = (d) => {
  return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
  return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECT] = (d) => {
  return IfcProject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
  return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTORDER] = (d) => {
  return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTEDCRS] = (d) => {
  return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
  return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTY] = (d) => {
  return IfcProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
  return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
  return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
  return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
  return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
  return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
  return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
  return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
  return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSET] = (d) => {
  return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
  return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
  return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
  return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
  return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
  return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
  return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
  return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
  return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
  return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
  return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROXY] = (d) => {
  return IfcProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMP] = (d) => {
  return IfcPump.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMPTYPE] = (d) => {
  return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYAREA] = (d) => {
  return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
  return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
  return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYSET] = (d) => {
  return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYTIME] = (d) => {
  return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
  return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
  return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILING] = (d) => {
  return IfcRailing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILINGTYPE] = (d) => {
  return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMP] = (d) => {
  return IfcRamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHT] = (d) => {
  return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
  return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPTYPE] = (d) => {
  return IfcRampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
  return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
  return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
  return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
  return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
  return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENCE] = (d) => {
  return IfcReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENT] = (d) => {
  return IfcReferent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
  return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
  return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
  return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBAR] = (d) => {
  return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
  return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
  return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
  return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESH] = (d) => {
  return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
  return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELAGGREGATES] = (d) => {
  return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNS] = (d) => {
  return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
  return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
  return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
  return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
  return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
  return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
  return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
  return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATES] = (d) => {
  return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
  return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
  return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
  return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
  return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
  return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
  return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTS] = (d) => {
  return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
  return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
  return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
  return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
  return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
  return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
  return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
  return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
  return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
  return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
  return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECLARES] = (d) => {
  return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECOMPOSES] = (d) => {
  return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINES] = (d) => {
  return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
  return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
  return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
  return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
  return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
  return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
  return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
  return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELNESTS] = (d) => {
  return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPOSITIONS] = (d) => {
  return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
  return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSEQUENCE] = (d) => {
  return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
  return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
  return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
  return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
  return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
  return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELATIONSHIP] = (d) => {
  return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
  return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATION] = (d) => {
  return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
  return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
  return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
  return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCE] = (d) => {
  return IfcResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
  return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
  return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
  return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCETIME] = (d) => {
  return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
  return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
  return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
  return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
  return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOF] = (d) => {
  return IfcRoof.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOFTYPE] = (d) => {
  return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOT] = (d) => {
  return IfcRoot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
  return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIUNIT] = (d) => {
  return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
  return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
  return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
  return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSEAMCURVE] = (d) => {
  return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
  return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
  return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
  return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
  return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
  return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSOR] = (d) => {
  return IfcSensor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSORTYPE] = (d) => {
  return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICE] = (d) => {
  return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
  return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEASPECT] = (d) => {
  return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEMODEL] = (d) => {
  return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
  return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
  return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
  return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
  return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSITE] = (d) => {
  return IfcSite.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLAB] = (d) => {
  return IfcSlab.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
  return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
  return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABTYPE] = (d) => {
  return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
  return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICE] = (d) => {
  return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
  return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLIDMODEL] = (d) => {
  return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACE] = (d) => {
  return IfcSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATER] = (d) => {
  return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
  return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACETYPE] = (d) => {
  return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENT] = (d) => {
  return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
  return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
  return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONE] = (d) => {
  return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
  return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERE] = (d) => {
  return IfcSphere.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
  return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINAL] = (d) => {
  return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
  return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIR] = (d) => {
  return IfcStair.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
  return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
  return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRTYPE] = (d) => {
  return IfcStairType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
  return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
  return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
  return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
  return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
  return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
  return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
  return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
  return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
  return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
  return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
  return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
  return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
  return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
  return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
  return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
  return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
  return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
  return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
  return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
  return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
  return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
  return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
  return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
  return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
  return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
  return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
  return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
  return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
  return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
  return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
  return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
  return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
  return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
  return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
  return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
  return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
  return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEMODEL] = (d) => {
  return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDITEM] = (d) => {
  return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
  return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
  return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
  return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBEDGE] = (d) => {
  return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACE] = (d) => {
  return IfcSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVE] = (d) => {
  return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
  return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEFEATURE] = (d) => {
  return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
  return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
  return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
  return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLE] = (d) => {
  return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
  return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
  return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
  return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
  return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
  return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACETEXTURE] = (d) => {
  return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
  return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
  return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
  return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTSURFACE] = (d) => {
  return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
  return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
  return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEM] = (d) => {
  return IfcSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
  return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
  return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
  return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLE] = (d) => {
  return IfcTable.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLECOLUMN] = (d) => {
  return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLEROW] = (d) => {
  return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANK] = (d) => {
  return IfcTank.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANKTYPE] = (d) => {
  return IfcTankType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASK] = (d) => {
  return IfcTask.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIME] = (d) => {
  return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
  return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTYPE] = (d) => {
  return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTELECOMADDRESS] = (d) => {
  return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDON] = (d) => {
  return IfcTendon.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHOR] = (d) => {
  return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
  return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUIT] = (d) => {
  return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
  return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONTYPE] = (d) => {
  return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
  return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
  return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERAL] = (d) => {
  return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
  return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLE] = (d) => {
  return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
  return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
  return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
  return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
  return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
  return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREMAP] = (d) => {
  return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
  return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
  return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMEPERIOD] = (d) => {
  return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIES] = (d) => {
  return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
  return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
  return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
  return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
  return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMER] = (d) => {
  return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
  return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
  return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
  return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
  return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
  return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
  return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
  return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
  return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLE] = (d) => {
  return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
  return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEOBJECT] = (d) => {
  return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPROCESS] = (d) => {
  return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPRODUCT] = (d) => {
  return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPERESOURCE] = (d) => {
  return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
  return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
  return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
  return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
  return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
  return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
  return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVE] = (d) => {
  return IfcValve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVETYPE] = (d) => {
  return IfcValveType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVECTOR] = (d) => {
  return IfcVector.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEX] = (d) => {
  return IfcVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXLOOP] = (d) => {
  return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXPOINT] = (d) => {
  return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
  return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
  return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
  return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
  return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
  return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
  return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
  return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALL] = (d) => {
  return IfcWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
  return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
  return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLTYPE] = (d) => {
  return IfcWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINAL] = (d) => {
  return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
  return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOW] = (d) => {
  return IfcWindow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
  return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
  return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
  return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTYLE] = (d) => {
  return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWTYPE] = (d) => {
  return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCALENDAR] = (d) => {
  return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCONTROL] = (d) => {
  return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKPLAN] = (d) => {
  return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKSCHEDULE] = (d) => {
  return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKTIME] = (d) => {
  return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
  return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZONE] = (d) => {
  return IfcZone.FromTape(d.ID, d.type, d.arguments);
};
var IfcActionRequestTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcActionRequestTypeEnum.EMAIL = "EMAIL";
IfcActionRequestTypeEnum.FAX = "FAX";
IfcActionRequestTypeEnum.PHONE = "PHONE";
IfcActionRequestTypeEnum.POST = "POST";
IfcActionRequestTypeEnum.VERBAL = "VERBAL";
IfcActionRequestTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionRequestTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionSourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcActionSourceTypeEnum.DEAD_LOAD_G = "DEAD_LOAD_G";
IfcActionSourceTypeEnum.COMPLETION_G1 = "COMPLETION_G1";
IfcActionSourceTypeEnum.LIVE_LOAD_Q = "LIVE_LOAD_Q";
IfcActionSourceTypeEnum.SNOW_S = "SNOW_S";
IfcActionSourceTypeEnum.WIND_W = "WIND_W";
IfcActionSourceTypeEnum.PRESTRESSING_P = "PRESTRESSING_P";
IfcActionSourceTypeEnum.SETTLEMENT_U = "SETTLEMENT_U";
IfcActionSourceTypeEnum.TEMPERATURE_T = "TEMPERATURE_T";
IfcActionSourceTypeEnum.EARTHQUAKE_E = "EARTHQUAKE_E";
IfcActionSourceTypeEnum.FIRE = "FIRE";
IfcActionSourceTypeEnum.IMPULSE = "IMPULSE";
IfcActionSourceTypeEnum.IMPACT = "IMPACT";
IfcActionSourceTypeEnum.TRANSPORT = "TRANSPORT";
IfcActionSourceTypeEnum.ERECTION = "ERECTION";
IfcActionSourceTypeEnum.PROPPING = "PROPPING";
IfcActionSourceTypeEnum.SYSTEM_IMPERFECTION = "SYSTEM_IMPERFECTION";
IfcActionSourceTypeEnum.SHRINKAGE = "SHRINKAGE";
IfcActionSourceTypeEnum.CREEP = "CREEP";
IfcActionSourceTypeEnum.LACK_OF_FIT = "LACK_OF_FIT";
IfcActionSourceTypeEnum.BUOYANCY = "BUOYANCY";
IfcActionSourceTypeEnum.ICE = "ICE";
IfcActionSourceTypeEnum.CURRENT = "CURRENT";
IfcActionSourceTypeEnum.WAVE = "WAVE";
IfcActionSourceTypeEnum.RAIN = "RAIN";
IfcActionSourceTypeEnum.BRAKES = "BRAKES";
IfcActionSourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionSourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcActionTypeEnum.PERMANENT_G = "PERMANENT_G";
IfcActionTypeEnum.VARIABLE_Q = "VARIABLE_Q";
IfcActionTypeEnum.EXTRAORDINARY_A = "EXTRAORDINARY_A";
IfcActionTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActuatorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcActuatorTypeEnum.ELECTRICACTUATOR = "ELECTRICACTUATOR";
IfcActuatorTypeEnum.HANDOPERATEDACTUATOR = "HANDOPERATEDACTUATOR";
IfcActuatorTypeEnum.HYDRAULICACTUATOR = "HYDRAULICACTUATOR";
IfcActuatorTypeEnum.PNEUMATICACTUATOR = "PNEUMATICACTUATOR";
IfcActuatorTypeEnum.THERMOSTATICACTUATOR = "THERMOSTATICACTUATOR";
IfcActuatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcActuatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAddressTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAddressTypeEnum.OFFICE = "OFFICE";
IfcAddressTypeEnum.SITE = "SITE";
IfcAddressTypeEnum.HOME = "HOME";
IfcAddressTypeEnum.DISTRIBUTIONPOINT = "DISTRIBUTIONPOINT";
IfcAddressTypeEnum.USERDEFINED = "USERDEFINED";
var IfcAirTerminalBoxTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAirTerminalBoxTypeEnum.CONSTANTFLOW = "CONSTANTFLOW";
IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREDEPENDANT = "VARIABLEFLOWPRESSUREDEPENDANT";
IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREINDEPENDANT = "VARIABLEFLOWPRESSUREINDEPENDANT";
IfcAirTerminalBoxTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirTerminalBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAirTerminalTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAirTerminalTypeEnum.DIFFUSER = "DIFFUSER";
IfcAirTerminalTypeEnum.GRILLE = "GRILLE";
IfcAirTerminalTypeEnum.LOUVRE = "LOUVRE";
IfcAirTerminalTypeEnum.REGISTER = "REGISTER";
IfcAirTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAirToAirHeatRecoveryTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECOUNTERFLOWEXCHANGER = "FIXEDPLATECOUNTERFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECROSSFLOWEXCHANGER = "FIXEDPLATECROSSFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATEPARALLELFLOWEXCHANGER = "FIXEDPLATEPARALLELFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.ROTARYWHEEL = "ROTARYWHEEL";
IfcAirToAirHeatRecoveryTypeEnum.RUNAROUNDCOILLOOP = "RUNAROUNDCOILLOOP";
IfcAirToAirHeatRecoveryTypeEnum.HEATPIPE = "HEATPIPE";
IfcAirToAirHeatRecoveryTypeEnum.TWINTOWERENTHALPYRECOVERYLOOPS = "TWINTOWERENTHALPYRECOVERYLOOPS";
IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONSEALEDTUBEHEATEXCHANGERS = "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS";
IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONCOILTYPEHEATEXCHANGERS = "THERMOSIPHONCOILTYPEHEATEXCHANGERS";
IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirToAirHeatRecoveryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAlarmTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAlarmTypeEnum.BELL = "BELL";
IfcAlarmTypeEnum.BREAKGLASSBUTTON = "BREAKGLASSBUTTON";
IfcAlarmTypeEnum.LIGHT = "LIGHT";
IfcAlarmTypeEnum.MANUALPULLBOX = "MANUALPULLBOX";
IfcAlarmTypeEnum.SIREN = "SIREN";
IfcAlarmTypeEnum.WHISTLE = "WHISTLE";
IfcAlarmTypeEnum.USERDEFINED = "USERDEFINED";
IfcAlarmTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAlignmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAlignmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcAlignmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAnalysisModelTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAnalysisModelTypeEnum.IN_PLANE_LOADING_2D = "IN_PLANE_LOADING_2D";
IfcAnalysisModelTypeEnum.OUT_PLANE_LOADING_2D = "OUT_PLANE_LOADING_2D";
IfcAnalysisModelTypeEnum.LOADING_3D = "LOADING_3D";
IfcAnalysisModelTypeEnum.USERDEFINED = "USERDEFINED";
IfcAnalysisModelTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAnalysisTheoryTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAnalysisTheoryTypeEnum.FIRST_ORDER_THEORY = "FIRST_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.SECOND_ORDER_THEORY = "SECOND_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.THIRD_ORDER_THEORY = "THIRD_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.FULL_NONLINEAR_THEORY = "FULL_NONLINEAR_THEORY";
IfcAnalysisTheoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcAnalysisTheoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcArithmeticOperatorEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcArithmeticOperatorEnum.ADD = "ADD";
IfcArithmeticOperatorEnum.DIVIDE = "DIVIDE";
IfcArithmeticOperatorEnum.MULTIPLY = "MULTIPLY";
IfcArithmeticOperatorEnum.SUBTRACT = "SUBTRACT";
var IfcAssemblyPlaceEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAssemblyPlaceEnum.SITE = "SITE";
IfcAssemblyPlaceEnum.FACTORY = "FACTORY";
IfcAssemblyPlaceEnum.NOTDEFINED = "NOTDEFINED";
var IfcAudioVisualApplianceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcAudioVisualApplianceTypeEnum.AMPLIFIER = "AMPLIFIER";
IfcAudioVisualApplianceTypeEnum.CAMERA = "CAMERA";
IfcAudioVisualApplianceTypeEnum.DISPLAY = "DISPLAY";
IfcAudioVisualApplianceTypeEnum.MICROPHONE = "MICROPHONE";
IfcAudioVisualApplianceTypeEnum.PLAYER = "PLAYER";
IfcAudioVisualApplianceTypeEnum.PROJECTOR = "PROJECTOR";
IfcAudioVisualApplianceTypeEnum.RECEIVER = "RECEIVER";
IfcAudioVisualApplianceTypeEnum.SPEAKER = "SPEAKER";
IfcAudioVisualApplianceTypeEnum.SWITCHER = "SWITCHER";
IfcAudioVisualApplianceTypeEnum.TELEPHONE = "TELEPHONE";
IfcAudioVisualApplianceTypeEnum.TUNER = "TUNER";
IfcAudioVisualApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcAudioVisualApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBSplineCurveForm = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBSplineCurveForm.POLYLINE_FORM = "POLYLINE_FORM";
IfcBSplineCurveForm.CIRCULAR_ARC = "CIRCULAR_ARC";
IfcBSplineCurveForm.ELLIPTIC_ARC = "ELLIPTIC_ARC";
IfcBSplineCurveForm.PARABOLIC_ARC = "PARABOLIC_ARC";
IfcBSplineCurveForm.HYPERBOLIC_ARC = "HYPERBOLIC_ARC";
IfcBSplineCurveForm.UNSPECIFIED = "UNSPECIFIED";
var IfcBSplineSurfaceForm = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBSplineSurfaceForm.PLANE_SURF = "PLANE_SURF";
IfcBSplineSurfaceForm.CYLINDRICAL_SURF = "CYLINDRICAL_SURF";
IfcBSplineSurfaceForm.CONICAL_SURF = "CONICAL_SURF";
IfcBSplineSurfaceForm.SPHERICAL_SURF = "SPHERICAL_SURF";
IfcBSplineSurfaceForm.TOROIDAL_SURF = "TOROIDAL_SURF";
IfcBSplineSurfaceForm.SURF_OF_REVOLUTION = "SURF_OF_REVOLUTION";
IfcBSplineSurfaceForm.RULED_SURF = "RULED_SURF";
IfcBSplineSurfaceForm.GENERALISED_CONE = "GENERALISED_CONE";
IfcBSplineSurfaceForm.QUADRIC_SURF = "QUADRIC_SURF";
IfcBSplineSurfaceForm.SURF_OF_LINEAR_EXTRUSION = "SURF_OF_LINEAR_EXTRUSION";
IfcBSplineSurfaceForm.UNSPECIFIED = "UNSPECIFIED";
var IfcBeamTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBeamTypeEnum.BEAM = "BEAM";
IfcBeamTypeEnum.JOIST = "JOIST";
IfcBeamTypeEnum.HOLLOWCORE = "HOLLOWCORE";
IfcBeamTypeEnum.LINTEL = "LINTEL";
IfcBeamTypeEnum.SPANDREL = "SPANDREL";
IfcBeamTypeEnum.T_BEAM = "T_BEAM";
IfcBeamTypeEnum.GIRDER_SEGMENT = "GIRDER_SEGMENT";
IfcBeamTypeEnum.DIAPHRAGM = "DIAPHRAGM";
IfcBeamTypeEnum.PIERCAP = "PIERCAP";
IfcBeamTypeEnum.HATSTONE = "HATSTONE";
IfcBeamTypeEnum.CORNICE = "CORNICE";
IfcBeamTypeEnum.EDGEBEAM = "EDGEBEAM";
IfcBeamTypeEnum.USERDEFINED = "USERDEFINED";
IfcBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBearingTypeDisplacementEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBearingTypeDisplacementEnum.FIXED_MOVEMENT = "FIXED_MOVEMENT";
IfcBearingTypeDisplacementEnum.GUIDED_LONGITUDINAL = "GUIDED_LONGITUDINAL";
IfcBearingTypeDisplacementEnum.GUIDED_TRANSVERSAL = "GUIDED_TRANSVERSAL";
IfcBearingTypeDisplacementEnum.FREE_MOVEMENT = "FREE_MOVEMENT";
IfcBearingTypeDisplacementEnum.NOTDEFINED = "NOTDEFINED";
var IfcBearingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBearingTypeEnum.CYLINDRICAL = "CYLINDRICAL";
IfcBearingTypeEnum.SPHERICAL = "SPHERICAL";
IfcBearingTypeEnum.ELASTOMERIC = "ELASTOMERIC";
IfcBearingTypeEnum.POT = "POT";
IfcBearingTypeEnum.GUIDE = "GUIDE";
IfcBearingTypeEnum.ROCKER = "ROCKER";
IfcBearingTypeEnum.ROLLER = "ROLLER";
IfcBearingTypeEnum.DISK = "DISK";
IfcBearingTypeEnum.USERDEFINED = "USERDEFINED";
IfcBearingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBenchmarkEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBenchmarkEnum.GREATERTHAN = "GREATERTHAN";
IfcBenchmarkEnum.GREATERTHANOREQUALTO = "GREATERTHANOREQUALTO";
IfcBenchmarkEnum.LESSTHAN = "LESSTHAN";
IfcBenchmarkEnum.LESSTHANOREQUALTO = "LESSTHANOREQUALTO";
IfcBenchmarkEnum.EQUALTO = "EQUALTO";
IfcBenchmarkEnum.NOTEQUALTO = "NOTEQUALTO";
IfcBenchmarkEnum.INCLUDES = "INCLUDES";
IfcBenchmarkEnum.NOTINCLUDES = "NOTINCLUDES";
IfcBenchmarkEnum.INCLUDEDIN = "INCLUDEDIN";
IfcBenchmarkEnum.NOTINCLUDEDIN = "NOTINCLUDEDIN";
var IfcBoilerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBoilerTypeEnum.WATER = "WATER";
IfcBoilerTypeEnum.STEAM = "STEAM";
IfcBoilerTypeEnum.USERDEFINED = "USERDEFINED";
IfcBoilerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBooleanOperator = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBooleanOperator.UNION = "UNION";
IfcBooleanOperator.INTERSECTION = "INTERSECTION";
IfcBooleanOperator.DIFFERENCE = "DIFFERENCE";
var IfcBridgePartTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBridgePartTypeEnum.ABUTMENT = "ABUTMENT";
IfcBridgePartTypeEnum.DECK = "DECK";
IfcBridgePartTypeEnum.DECK_SEGMENT = "DECK_SEGMENT";
IfcBridgePartTypeEnum.FOUNDATION = "FOUNDATION";
IfcBridgePartTypeEnum.PIER = "PIER";
IfcBridgePartTypeEnum.PIER_SEGMENT = "PIER_SEGMENT";
IfcBridgePartTypeEnum.PYLON = "PYLON";
IfcBridgePartTypeEnum.SUBSTRUCTURE = "SUBSTRUCTURE";
IfcBridgePartTypeEnum.SUPERSTRUCTURE = "SUPERSTRUCTURE";
IfcBridgePartTypeEnum.SURFACESTRUCTURE = "SURFACESTRUCTURE";
IfcBridgePartTypeEnum.USERDEFINED = "USERDEFINED";
IfcBridgePartTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBridgeTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBridgeTypeEnum.ARCHED = "ARCHED";
IfcBridgeTypeEnum.CABLE_STAYED = "CABLE_STAYED";
IfcBridgeTypeEnum.CANTILEVER = "CANTILEVER";
IfcBridgeTypeEnum.CULVERT = "CULVERT";
IfcBridgeTypeEnum.FRAMEWORK = "FRAMEWORK";
IfcBridgeTypeEnum.GIRDER = "GIRDER";
IfcBridgeTypeEnum.SUSPENSION = "SUSPENSION";
IfcBridgeTypeEnum.TRUSS = "TRUSS";
IfcBridgeTypeEnum.USERDEFINED = "USERDEFINED";
IfcBridgeTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingElementPartTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBuildingElementPartTypeEnum.INSULATION = "INSULATION";
IfcBuildingElementPartTypeEnum.PRECASTPANEL = "PRECASTPANEL";
IfcBuildingElementPartTypeEnum.APRON = "APRON";
IfcBuildingElementPartTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingElementPartTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingElementProxyTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBuildingElementProxyTypeEnum.COMPLEX = "COMPLEX";
IfcBuildingElementProxyTypeEnum.ELEMENT = "ELEMENT";
IfcBuildingElementProxyTypeEnum.PARTIAL = "PARTIAL";
IfcBuildingElementProxyTypeEnum.PROVISIONFORVOID = "PROVISIONFORVOID";
IfcBuildingElementProxyTypeEnum.PROVISIONFORSPACE = "PROVISIONFORSPACE";
IfcBuildingElementProxyTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingElementProxyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingSystemTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBuildingSystemTypeEnum.FENESTRATION = "FENESTRATION";
IfcBuildingSystemTypeEnum.FOUNDATION = "FOUNDATION";
IfcBuildingSystemTypeEnum.LOADBEARING = "LOADBEARING";
IfcBuildingSystemTypeEnum.OUTERSHELL = "OUTERSHELL";
IfcBuildingSystemTypeEnum.SHADING = "SHADING";
IfcBuildingSystemTypeEnum.TRANSPORT = "TRANSPORT";
IfcBuildingSystemTypeEnum.REINFORCING = "REINFORCING";
IfcBuildingSystemTypeEnum.PRESTRESSING = "PRESTRESSING";
IfcBuildingSystemTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingSystemTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBurnerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcBurnerTypeEnum.USERDEFINED = "USERDEFINED";
IfcBurnerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableCarrierFittingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCableCarrierFittingTypeEnum.BEND = "BEND";
IfcCableCarrierFittingTypeEnum.CROSS = "CROSS";
IfcCableCarrierFittingTypeEnum.REDUCER = "REDUCER";
IfcCableCarrierFittingTypeEnum.TEE = "TEE";
IfcCableCarrierFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableCarrierFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableCarrierSegmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCableCarrierSegmentTypeEnum.CABLELADDERSEGMENT = "CABLELADDERSEGMENT";
IfcCableCarrierSegmentTypeEnum.CABLETRAYSEGMENT = "CABLETRAYSEGMENT";
IfcCableCarrierSegmentTypeEnum.CABLETRUNKINGSEGMENT = "CABLETRUNKINGSEGMENT";
IfcCableCarrierSegmentTypeEnum.CONDUITSEGMENT = "CONDUITSEGMENT";
IfcCableCarrierSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableCarrierSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableFittingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCableFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcCableFittingTypeEnum.ENTRY = "ENTRY";
IfcCableFittingTypeEnum.EXIT = "EXIT";
IfcCableFittingTypeEnum.JUNCTION = "JUNCTION";
IfcCableFittingTypeEnum.TRANSITION = "TRANSITION";
IfcCableFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableSegmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCableSegmentTypeEnum.BUSBARSEGMENT = "BUSBARSEGMENT";
IfcCableSegmentTypeEnum.CABLESEGMENT = "CABLESEGMENT";
IfcCableSegmentTypeEnum.CONDUCTORSEGMENT = "CONDUCTORSEGMENT";
IfcCableSegmentTypeEnum.CORESEGMENT = "CORESEGMENT";
IfcCableSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCaissonFoundationTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCaissonFoundationTypeEnum.WELL = "WELL";
IfcCaissonFoundationTypeEnum.CAISSON = "CAISSON";
IfcCaissonFoundationTypeEnum.USERDEFINED = "USERDEFINED";
IfcCaissonFoundationTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcChangeActionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcChangeActionEnum.NOCHANGE = "NOCHANGE";
IfcChangeActionEnum.MODIFIED = "MODIFIED";
IfcChangeActionEnum.ADDED = "ADDED";
IfcChangeActionEnum.DELETED = "DELETED";
IfcChangeActionEnum.NOTDEFINED = "NOTDEFINED";
var IfcChillerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcChillerTypeEnum.AIRCOOLED = "AIRCOOLED";
IfcChillerTypeEnum.WATERCOOLED = "WATERCOOLED";
IfcChillerTypeEnum.HEATRECOVERY = "HEATRECOVERY";
IfcChillerTypeEnum.USERDEFINED = "USERDEFINED";
IfcChillerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcChimneyTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcChimneyTypeEnum.USERDEFINED = "USERDEFINED";
IfcChimneyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoilTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCoilTypeEnum.DXCOOLINGCOIL = "DXCOOLINGCOIL";
IfcCoilTypeEnum.ELECTRICHEATINGCOIL = "ELECTRICHEATINGCOIL";
IfcCoilTypeEnum.GASHEATINGCOIL = "GASHEATINGCOIL";
IfcCoilTypeEnum.HYDRONICCOIL = "HYDRONICCOIL";
IfcCoilTypeEnum.STEAMHEATINGCOIL = "STEAMHEATINGCOIL";
IfcCoilTypeEnum.WATERCOOLINGCOIL = "WATERCOOLINGCOIL";
IfcCoilTypeEnum.WATERHEATINGCOIL = "WATERHEATINGCOIL";
IfcCoilTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoilTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcColumnTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcColumnTypeEnum.COLUMN = "COLUMN";
IfcColumnTypeEnum.PILASTER = "PILASTER";
IfcColumnTypeEnum.PIERSTEM = "PIERSTEM";
IfcColumnTypeEnum.PIERSTEM_SEGMENT = "PIERSTEM_SEGMENT";
IfcColumnTypeEnum.STANDCOLUMN = "STANDCOLUMN";
IfcColumnTypeEnum.USERDEFINED = "USERDEFINED";
IfcColumnTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCommunicationsApplianceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCommunicationsApplianceTypeEnum.ANTENNA = "ANTENNA";
IfcCommunicationsApplianceTypeEnum.COMPUTER = "COMPUTER";
IfcCommunicationsApplianceTypeEnum.FAX = "FAX";
IfcCommunicationsApplianceTypeEnum.GATEWAY = "GATEWAY";
IfcCommunicationsApplianceTypeEnum.MODEM = "MODEM";
IfcCommunicationsApplianceTypeEnum.NETWORKAPPLIANCE = "NETWORKAPPLIANCE";
IfcCommunicationsApplianceTypeEnum.NETWORKBRIDGE = "NETWORKBRIDGE";
IfcCommunicationsApplianceTypeEnum.NETWORKHUB = "NETWORKHUB";
IfcCommunicationsApplianceTypeEnum.PRINTER = "PRINTER";
IfcCommunicationsApplianceTypeEnum.REPEATER = "REPEATER";
IfcCommunicationsApplianceTypeEnum.ROUTER = "ROUTER";
IfcCommunicationsApplianceTypeEnum.SCANNER = "SCANNER";
IfcCommunicationsApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcCommunicationsApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcComplexPropertyTemplateTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcComplexPropertyTemplateTypeEnum.P_COMPLEX = "P_COMPLEX";
IfcComplexPropertyTemplateTypeEnum.Q_COMPLEX = "Q_COMPLEX";
var IfcCompressorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCompressorTypeEnum.DYNAMIC = "DYNAMIC";
IfcCompressorTypeEnum.RECIPROCATING = "RECIPROCATING";
IfcCompressorTypeEnum.ROTARY = "ROTARY";
IfcCompressorTypeEnum.SCROLL = "SCROLL";
IfcCompressorTypeEnum.TROCHOIDAL = "TROCHOIDAL";
IfcCompressorTypeEnum.SINGLESTAGE = "SINGLESTAGE";
IfcCompressorTypeEnum.BOOSTER = "BOOSTER";
IfcCompressorTypeEnum.OPENTYPE = "OPENTYPE";
IfcCompressorTypeEnum.HERMETIC = "HERMETIC";
IfcCompressorTypeEnum.SEMIHERMETIC = "SEMIHERMETIC";
IfcCompressorTypeEnum.WELDEDSHELLHERMETIC = "WELDEDSHELLHERMETIC";
IfcCompressorTypeEnum.ROLLINGPISTON = "ROLLINGPISTON";
IfcCompressorTypeEnum.ROTARYVANE = "ROTARYVANE";
IfcCompressorTypeEnum.SINGLESCREW = "SINGLESCREW";
IfcCompressorTypeEnum.TWINSCREW = "TWINSCREW";
IfcCompressorTypeEnum.USERDEFINED = "USERDEFINED";
IfcCompressorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCondenserTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCondenserTypeEnum.AIRCOOLED = "AIRCOOLED";
IfcCondenserTypeEnum.EVAPORATIVECOOLED = "EVAPORATIVECOOLED";
IfcCondenserTypeEnum.WATERCOOLED = "WATERCOOLED";
IfcCondenserTypeEnum.WATERCOOLEDBRAZEDPLATE = "WATERCOOLEDBRAZEDPLATE";
IfcCondenserTypeEnum.WATERCOOLEDSHELLCOIL = "WATERCOOLEDSHELLCOIL";
IfcCondenserTypeEnum.WATERCOOLEDSHELLTUBE = "WATERCOOLEDSHELLTUBE";
IfcCondenserTypeEnum.WATERCOOLEDTUBEINTUBE = "WATERCOOLEDTUBEINTUBE";
IfcCondenserTypeEnum.USERDEFINED = "USERDEFINED";
IfcCondenserTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConnectionTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcConnectionTypeEnum.ATPATH = "ATPATH";
IfcConnectionTypeEnum.ATSTART = "ATSTART";
IfcConnectionTypeEnum.ATEND = "ATEND";
IfcConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstraintEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcConstraintEnum.HARD = "HARD";
IfcConstraintEnum.SOFT = "SOFT";
IfcConstraintEnum.ADVISORY = "ADVISORY";
IfcConstraintEnum.USERDEFINED = "USERDEFINED";
IfcConstraintEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstructionEquipmentResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcConstructionEquipmentResourceTypeEnum.DEMOLISHING = "DEMOLISHING";
IfcConstructionEquipmentResourceTypeEnum.EARTHMOVING = "EARTHMOVING";
IfcConstructionEquipmentResourceTypeEnum.ERECTING = "ERECTING";
IfcConstructionEquipmentResourceTypeEnum.HEATING = "HEATING";
IfcConstructionEquipmentResourceTypeEnum.LIGHTING = "LIGHTING";
IfcConstructionEquipmentResourceTypeEnum.PAVING = "PAVING";
IfcConstructionEquipmentResourceTypeEnum.PUMPING = "PUMPING";
IfcConstructionEquipmentResourceTypeEnum.TRANSPORTING = "TRANSPORTING";
IfcConstructionEquipmentResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcConstructionEquipmentResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstructionMaterialResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcConstructionMaterialResourceTypeEnum.AGGREGATES = "AGGREGATES";
IfcConstructionMaterialResourceTypeEnum.CONCRETE = "CONCRETE";
IfcConstructionMaterialResourceTypeEnum.DRYWALL = "DRYWALL";
IfcConstructionMaterialResourceTypeEnum.FUEL = "FUEL";
IfcConstructionMaterialResourceTypeEnum.GYPSUM = "GYPSUM";
IfcConstructionMaterialResourceTypeEnum.MASONRY = "MASONRY";
IfcConstructionMaterialResourceTypeEnum.METAL = "METAL";
IfcConstructionMaterialResourceTypeEnum.PLASTIC = "PLASTIC";
IfcConstructionMaterialResourceTypeEnum.WOOD = "WOOD";
IfcConstructionMaterialResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
IfcConstructionMaterialResourceTypeEnum.USERDEFINED = "USERDEFINED";
var IfcConstructionProductResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcConstructionProductResourceTypeEnum.ASSEMBLY = "ASSEMBLY";
IfcConstructionProductResourceTypeEnum.FORMWORK = "FORMWORK";
IfcConstructionProductResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcConstructionProductResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcControllerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcControllerTypeEnum.FLOATING = "FLOATING";
IfcControllerTypeEnum.PROGRAMMABLE = "PROGRAMMABLE";
IfcControllerTypeEnum.PROPORTIONAL = "PROPORTIONAL";
IfcControllerTypeEnum.MULTIPOSITION = "MULTIPOSITION";
IfcControllerTypeEnum.TWOPOSITION = "TWOPOSITION";
IfcControllerTypeEnum.USERDEFINED = "USERDEFINED";
IfcControllerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCooledBeamTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCooledBeamTypeEnum.ACTIVE = "ACTIVE";
IfcCooledBeamTypeEnum.PASSIVE = "PASSIVE";
IfcCooledBeamTypeEnum.USERDEFINED = "USERDEFINED";
IfcCooledBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoolingTowerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCoolingTowerTypeEnum.NATURALDRAFT = "NATURALDRAFT";
IfcCoolingTowerTypeEnum.MECHANICALINDUCEDDRAFT = "MECHANICALINDUCEDDRAFT";
IfcCoolingTowerTypeEnum.MECHANICALFORCEDDRAFT = "MECHANICALFORCEDDRAFT";
IfcCoolingTowerTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoolingTowerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCostItemTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCostItemTypeEnum.USERDEFINED = "USERDEFINED";
IfcCostItemTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCostScheduleTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCostScheduleTypeEnum.BUDGET = "BUDGET";
IfcCostScheduleTypeEnum.COSTPLAN = "COSTPLAN";
IfcCostScheduleTypeEnum.ESTIMATE = "ESTIMATE";
IfcCostScheduleTypeEnum.TENDER = "TENDER";
IfcCostScheduleTypeEnum.PRICEDBILLOFQUANTITIES = "PRICEDBILLOFQUANTITIES";
IfcCostScheduleTypeEnum.UNPRICEDBILLOFQUANTITIES = "UNPRICEDBILLOFQUANTITIES";
IfcCostScheduleTypeEnum.SCHEDULEOFRATES = "SCHEDULEOFRATES";
IfcCostScheduleTypeEnum.USERDEFINED = "USERDEFINED";
IfcCostScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoveringTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCoveringTypeEnum.CEILING = "CEILING";
IfcCoveringTypeEnum.FLOORING = "FLOORING";
IfcCoveringTypeEnum.CLADDING = "CLADDING";
IfcCoveringTypeEnum.ROOFING = "ROOFING";
IfcCoveringTypeEnum.MOLDING = "MOLDING";
IfcCoveringTypeEnum.SKIRTINGBOARD = "SKIRTINGBOARD";
IfcCoveringTypeEnum.INSULATION = "INSULATION";
IfcCoveringTypeEnum.MEMBRANE = "MEMBRANE";
IfcCoveringTypeEnum.SLEEVING = "SLEEVING";
IfcCoveringTypeEnum.WRAPPING = "WRAPPING";
IfcCoveringTypeEnum.COPING = "COPING";
IfcCoveringTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoveringTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCrewResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCrewResourceTypeEnum.OFFICE = "OFFICE";
IfcCrewResourceTypeEnum.SITE = "SITE";
IfcCrewResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcCrewResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCurtainWallTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCurtainWallTypeEnum.USERDEFINED = "USERDEFINED";
IfcCurtainWallTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCurveInterpolationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcCurveInterpolationEnum.LINEAR = "LINEAR";
IfcCurveInterpolationEnum.LOG_LINEAR = "LOG_LINEAR";
IfcCurveInterpolationEnum.LOG_LOG = "LOG_LOG";
IfcCurveInterpolationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDamperTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDamperTypeEnum.BACKDRAFTDAMPER = "BACKDRAFTDAMPER";
IfcDamperTypeEnum.BALANCINGDAMPER = "BALANCINGDAMPER";
IfcDamperTypeEnum.BLASTDAMPER = "BLASTDAMPER";
IfcDamperTypeEnum.CONTROLDAMPER = "CONTROLDAMPER";
IfcDamperTypeEnum.FIREDAMPER = "FIREDAMPER";
IfcDamperTypeEnum.FIRESMOKEDAMPER = "FIRESMOKEDAMPER";
IfcDamperTypeEnum.FUMEHOODEXHAUST = "FUMEHOODEXHAUST";
IfcDamperTypeEnum.GRAVITYDAMPER = "GRAVITYDAMPER";
IfcDamperTypeEnum.GRAVITYRELIEFDAMPER = "GRAVITYRELIEFDAMPER";
IfcDamperTypeEnum.RELIEFDAMPER = "RELIEFDAMPER";
IfcDamperTypeEnum.SMOKEDAMPER = "SMOKEDAMPER";
IfcDamperTypeEnum.USERDEFINED = "USERDEFINED";
IfcDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDataOriginEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDataOriginEnum.MEASURED = "MEASURED";
IfcDataOriginEnum.PREDICTED = "PREDICTED";
IfcDataOriginEnum.SIMULATED = "SIMULATED";
IfcDataOriginEnum.USERDEFINED = "USERDEFINED";
IfcDataOriginEnum.NOTDEFINED = "NOTDEFINED";
var IfcDerivedUnitEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDerivedUnitEnum.ANGULARVELOCITYUNIT = "ANGULARVELOCITYUNIT";
IfcDerivedUnitEnum.AREADENSITYUNIT = "AREADENSITYUNIT";
IfcDerivedUnitEnum.COMPOUNDPLANEANGLEUNIT = "COMPOUNDPLANEANGLEUNIT";
IfcDerivedUnitEnum.DYNAMICVISCOSITYUNIT = "DYNAMICVISCOSITYUNIT";
IfcDerivedUnitEnum.HEATFLUXDENSITYUNIT = "HEATFLUXDENSITYUNIT";
IfcDerivedUnitEnum.INTEGERCOUNTRATEUNIT = "INTEGERCOUNTRATEUNIT";
IfcDerivedUnitEnum.ISOTHERMALMOISTURECAPACITYUNIT = "ISOTHERMALMOISTURECAPACITYUNIT";
IfcDerivedUnitEnum.KINEMATICVISCOSITYUNIT = "KINEMATICVISCOSITYUNIT";
IfcDerivedUnitEnum.LINEARVELOCITYUNIT = "LINEARVELOCITYUNIT";
IfcDerivedUnitEnum.MASSDENSITYUNIT = "MASSDENSITYUNIT";
IfcDerivedUnitEnum.MASSFLOWRATEUNIT = "MASSFLOWRATEUNIT";
IfcDerivedUnitEnum.MOISTUREDIFFUSIVITYUNIT = "MOISTUREDIFFUSIVITYUNIT";
IfcDerivedUnitEnum.MOLECULARWEIGHTUNIT = "MOLECULARWEIGHTUNIT";
IfcDerivedUnitEnum.SPECIFICHEATCAPACITYUNIT = "SPECIFICHEATCAPACITYUNIT";
IfcDerivedUnitEnum.THERMALADMITTANCEUNIT = "THERMALADMITTANCEUNIT";
IfcDerivedUnitEnum.THERMALCONDUCTANCEUNIT = "THERMALCONDUCTANCEUNIT";
IfcDerivedUnitEnum.THERMALRESISTANCEUNIT = "THERMALRESISTANCEUNIT";
IfcDerivedUnitEnum.THERMALTRANSMITTANCEUNIT = "THERMALTRANSMITTANCEUNIT";
IfcDerivedUnitEnum.VAPORPERMEABILITYUNIT = "VAPORPERMEABILITYUNIT";
IfcDerivedUnitEnum.VOLUMETRICFLOWRATEUNIT = "VOLUMETRICFLOWRATEUNIT";
IfcDerivedUnitEnum.ROTATIONALFREQUENCYUNIT = "ROTATIONALFREQUENCYUNIT";
IfcDerivedUnitEnum.TORQUEUNIT = "TORQUEUNIT";
IfcDerivedUnitEnum.MOMENTOFINERTIAUNIT = "MOMENTOFINERTIAUNIT";
IfcDerivedUnitEnum.LINEARMOMENTUNIT = "LINEARMOMENTUNIT";
IfcDerivedUnitEnum.LINEARFORCEUNIT = "LINEARFORCEUNIT";
IfcDerivedUnitEnum.PLANARFORCEUNIT = "PLANARFORCEUNIT";
IfcDerivedUnitEnum.MODULUSOFELASTICITYUNIT = "MODULUSOFELASTICITYUNIT";
IfcDerivedUnitEnum.SHEARMODULUSUNIT = "SHEARMODULUSUNIT";
IfcDerivedUnitEnum.LINEARSTIFFNESSUNIT = "LINEARSTIFFNESSUNIT";
IfcDerivedUnitEnum.ROTATIONALSTIFFNESSUNIT = "ROTATIONALSTIFFNESSUNIT";
IfcDerivedUnitEnum.MODULUSOFSUBGRADEREACTIONUNIT = "MODULUSOFSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.ACCELERATIONUNIT = "ACCELERATIONUNIT";
IfcDerivedUnitEnum.CURVATUREUNIT = "CURVATUREUNIT";
IfcDerivedUnitEnum.HEATINGVALUEUNIT = "HEATINGVALUEUNIT";
IfcDerivedUnitEnum.IONCONCENTRATIONUNIT = "IONCONCENTRATIONUNIT";
IfcDerivedUnitEnum.LUMINOUSINTENSITYDISTRIBUTIONUNIT = "LUMINOUSINTENSITYDISTRIBUTIONUNIT";
IfcDerivedUnitEnum.MASSPERLENGTHUNIT = "MASSPERLENGTHUNIT";
IfcDerivedUnitEnum.MODULUSOFLINEARSUBGRADEREACTIONUNIT = "MODULUSOFLINEARSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.MODULUSOFROTATIONALSUBGRADEREACTIONUNIT = "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.PHUNIT = "PHUNIT";
IfcDerivedUnitEnum.ROTATIONALMASSUNIT = "ROTATIONALMASSUNIT";
IfcDerivedUnitEnum.SECTIONAREAINTEGRALUNIT = "SECTIONAREAINTEGRALUNIT";
IfcDerivedUnitEnum.SECTIONMODULUSUNIT = "SECTIONMODULUSUNIT";
IfcDerivedUnitEnum.SOUNDPOWERLEVELUNIT = "SOUNDPOWERLEVELUNIT";
IfcDerivedUnitEnum.SOUNDPOWERUNIT = "SOUNDPOWERUNIT";
IfcDerivedUnitEnum.SOUNDPRESSURELEVELUNIT = "SOUNDPRESSURELEVELUNIT";
IfcDerivedUnitEnum.SOUNDPRESSUREUNIT = "SOUNDPRESSUREUNIT";
IfcDerivedUnitEnum.TEMPERATUREGRADIENTUNIT = "TEMPERATUREGRADIENTUNIT";
IfcDerivedUnitEnum.TEMPERATURERATEOFCHANGEUNIT = "TEMPERATURERATEOFCHANGEUNIT";
IfcDerivedUnitEnum.THERMALEXPANSIONCOEFFICIENTUNIT = "THERMALEXPANSIONCOEFFICIENTUNIT";
IfcDerivedUnitEnum.WARPINGCONSTANTUNIT = "WARPINGCONSTANTUNIT";
IfcDerivedUnitEnum.WARPINGMOMENTUNIT = "WARPINGMOMENTUNIT";
IfcDerivedUnitEnum.USERDEFINED = "USERDEFINED";
var IfcDirectionSenseEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDirectionSenseEnum.POSITIVE = "POSITIVE";
IfcDirectionSenseEnum.NEGATIVE = "NEGATIVE";
var IfcDiscreteAccessoryTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDiscreteAccessoryTypeEnum.ANCHORPLATE = "ANCHORPLATE";
IfcDiscreteAccessoryTypeEnum.BRACKET = "BRACKET";
IfcDiscreteAccessoryTypeEnum.SHOE = "SHOE";
IfcDiscreteAccessoryTypeEnum.EXPANSION_JOINT_DEVICE = "EXPANSION_JOINT_DEVICE";
IfcDiscreteAccessoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcDiscreteAccessoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionChamberElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDistributionChamberElementTypeEnum.FORMEDDUCT = "FORMEDDUCT";
IfcDistributionChamberElementTypeEnum.INSPECTIONCHAMBER = "INSPECTIONCHAMBER";
IfcDistributionChamberElementTypeEnum.INSPECTIONPIT = "INSPECTIONPIT";
IfcDistributionChamberElementTypeEnum.MANHOLE = "MANHOLE";
IfcDistributionChamberElementTypeEnum.METERCHAMBER = "METERCHAMBER";
IfcDistributionChamberElementTypeEnum.SUMP = "SUMP";
IfcDistributionChamberElementTypeEnum.TRENCH = "TRENCH";
IfcDistributionChamberElementTypeEnum.VALVECHAMBER = "VALVECHAMBER";
IfcDistributionChamberElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcDistributionChamberElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionPortTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDistributionPortTypeEnum.CABLE = "CABLE";
IfcDistributionPortTypeEnum.CABLECARRIER = "CABLECARRIER";
IfcDistributionPortTypeEnum.DUCT = "DUCT";
IfcDistributionPortTypeEnum.PIPE = "PIPE";
IfcDistributionPortTypeEnum.USERDEFINED = "USERDEFINED";
IfcDistributionPortTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionSystemEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDistributionSystemEnum.AIRCONDITIONING = "AIRCONDITIONING";
IfcDistributionSystemEnum.AUDIOVISUAL = "AUDIOVISUAL";
IfcDistributionSystemEnum.CHEMICAL = "CHEMICAL";
IfcDistributionSystemEnum.CHILLEDWATER = "CHILLEDWATER";
IfcDistributionSystemEnum.COMMUNICATION = "COMMUNICATION";
IfcDistributionSystemEnum.COMPRESSEDAIR = "COMPRESSEDAIR";
IfcDistributionSystemEnum.CONDENSERWATER = "CONDENSERWATER";
IfcDistributionSystemEnum.CONTROL = "CONTROL";
IfcDistributionSystemEnum.CONVEYING = "CONVEYING";
IfcDistributionSystemEnum.DATA = "DATA";
IfcDistributionSystemEnum.DISPOSAL = "DISPOSAL";
IfcDistributionSystemEnum.DOMESTICCOLDWATER = "DOMESTICCOLDWATER";
IfcDistributionSystemEnum.DOMESTICHOTWATER = "DOMESTICHOTWATER";
IfcDistributionSystemEnum.DRAINAGE = "DRAINAGE";
IfcDistributionSystemEnum.EARTHING = "EARTHING";
IfcDistributionSystemEnum.ELECTRICAL = "ELECTRICAL";
IfcDistributionSystemEnum.ELECTROACOUSTIC = "ELECTROACOUSTIC";
IfcDistributionSystemEnum.EXHAUST = "EXHAUST";
IfcDistributionSystemEnum.FIREPROTECTION = "FIREPROTECTION";
IfcDistributionSystemEnum.FUEL = "FUEL";
IfcDistributionSystemEnum.GAS = "GAS";
IfcDistributionSystemEnum.HAZARDOUS = "HAZARDOUS";
IfcDistributionSystemEnum.HEATING = "HEATING";
IfcDistributionSystemEnum.LIGHTING = "LIGHTING";
IfcDistributionSystemEnum.LIGHTNINGPROTECTION = "LIGHTNINGPROTECTION";
IfcDistributionSystemEnum.MUNICIPALSOLIDWASTE = "MUNICIPALSOLIDWASTE";
IfcDistributionSystemEnum.OIL = "OIL";
IfcDistributionSystemEnum.OPERATIONAL = "OPERATIONAL";
IfcDistributionSystemEnum.POWERGENERATION = "POWERGENERATION";
IfcDistributionSystemEnum.RAINWATER = "RAINWATER";
IfcDistributionSystemEnum.REFRIGERATION = "REFRIGERATION";
IfcDistributionSystemEnum.SECURITY = "SECURITY";
IfcDistributionSystemEnum.SEWAGE = "SEWAGE";
IfcDistributionSystemEnum.SIGNAL = "SIGNAL";
IfcDistributionSystemEnum.STORMWATER = "STORMWATER";
IfcDistributionSystemEnum.TELEPHONE = "TELEPHONE";
IfcDistributionSystemEnum.TV = "TV";
IfcDistributionSystemEnum.VACUUM = "VACUUM";
IfcDistributionSystemEnum.VENT = "VENT";
IfcDistributionSystemEnum.VENTILATION = "VENTILATION";
IfcDistributionSystemEnum.WASTEWATER = "WASTEWATER";
IfcDistributionSystemEnum.WATERSUPPLY = "WATERSUPPLY";
IfcDistributionSystemEnum.USERDEFINED = "USERDEFINED";
IfcDistributionSystemEnum.NOTDEFINED = "NOTDEFINED";
var IfcDocumentConfidentialityEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDocumentConfidentialityEnum.PUBLIC = "PUBLIC";
IfcDocumentConfidentialityEnum.RESTRICTED = "RESTRICTED";
IfcDocumentConfidentialityEnum.CONFIDENTIAL = "CONFIDENTIAL";
IfcDocumentConfidentialityEnum.PERSONAL = "PERSONAL";
IfcDocumentConfidentialityEnum.USERDEFINED = "USERDEFINED";
IfcDocumentConfidentialityEnum.NOTDEFINED = "NOTDEFINED";
var IfcDocumentStatusEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDocumentStatusEnum.DRAFT = "DRAFT";
IfcDocumentStatusEnum.FINALDRAFT = "FINALDRAFT";
IfcDocumentStatusEnum.FINAL = "FINAL";
IfcDocumentStatusEnum.REVISION = "REVISION";
IfcDocumentStatusEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorPanelOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorPanelOperationEnum.SWINGING = "SWINGING";
IfcDoorPanelOperationEnum.DOUBLE_ACTING = "DOUBLE_ACTING";
IfcDoorPanelOperationEnum.SLIDING = "SLIDING";
IfcDoorPanelOperationEnum.FOLDING = "FOLDING";
IfcDoorPanelOperationEnum.REVOLVING = "REVOLVING";
IfcDoorPanelOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorPanelOperationEnum.FIXEDPANEL = "FIXEDPANEL";
IfcDoorPanelOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorPanelPositionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorPanelPositionEnum.LEFT = "LEFT";
IfcDoorPanelPositionEnum.MIDDLE = "MIDDLE";
IfcDoorPanelPositionEnum.RIGHT = "RIGHT";
IfcDoorPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorStyleConstructionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
IfcDoorStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
IfcDoorStyleConstructionEnum.STEEL = "STEEL";
IfcDoorStyleConstructionEnum.WOOD = "WOOD";
IfcDoorStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
IfcDoorStyleConstructionEnum.ALUMINIUM_PLASTIC = "ALUMINIUM_PLASTIC";
IfcDoorStyleConstructionEnum.PLASTIC = "PLASTIC";
IfcDoorStyleConstructionEnum.USERDEFINED = "USERDEFINED";
IfcDoorStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorStyleOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorStyleOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
IfcDoorStyleOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
IfcDoorStyleOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
IfcDoorStyleOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
IfcDoorStyleOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
IfcDoorStyleOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
IfcDoorStyleOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
IfcDoorStyleOperationEnum.REVOLVING = "REVOLVING";
IfcDoorStyleOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorStyleOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorTypeEnum.DOOR = "DOOR";
IfcDoorTypeEnum.GATE = "GATE";
IfcDoorTypeEnum.TRAPDOOR = "TRAPDOOR";
IfcDoorTypeEnum.USERDEFINED = "USERDEFINED";
IfcDoorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorTypeOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDoorTypeOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
IfcDoorTypeOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
IfcDoorTypeOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
IfcDoorTypeOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
IfcDoorTypeOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
IfcDoorTypeOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
IfcDoorTypeOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
IfcDoorTypeOperationEnum.REVOLVING = "REVOLVING";
IfcDoorTypeOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorTypeOperationEnum.SWING_FIXED_LEFT = "SWING_FIXED_LEFT";
IfcDoorTypeOperationEnum.SWING_FIXED_RIGHT = "SWING_FIXED_RIGHT";
IfcDoorTypeOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorTypeOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctFittingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDuctFittingTypeEnum.BEND = "BEND";
IfcDuctFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcDuctFittingTypeEnum.ENTRY = "ENTRY";
IfcDuctFittingTypeEnum.EXIT = "EXIT";
IfcDuctFittingTypeEnum.JUNCTION = "JUNCTION";
IfcDuctFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
IfcDuctFittingTypeEnum.TRANSITION = "TRANSITION";
IfcDuctFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctSegmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDuctSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
IfcDuctSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
IfcDuctSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctSilencerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcDuctSilencerTypeEnum.FLATOVAL = "FLATOVAL";
IfcDuctSilencerTypeEnum.RECTANGULAR = "RECTANGULAR";
IfcDuctSilencerTypeEnum.ROUND = "ROUND";
IfcDuctSilencerTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctSilencerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricApplianceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricApplianceTypeEnum.DISHWASHER = "DISHWASHER";
IfcElectricApplianceTypeEnum.ELECTRICCOOKER = "ELECTRICCOOKER";
IfcElectricApplianceTypeEnum.FREESTANDINGELECTRICHEATER = "FREESTANDINGELECTRICHEATER";
IfcElectricApplianceTypeEnum.FREESTANDINGFAN = "FREESTANDINGFAN";
IfcElectricApplianceTypeEnum.FREESTANDINGWATERHEATER = "FREESTANDINGWATERHEATER";
IfcElectricApplianceTypeEnum.FREESTANDINGWATERCOOLER = "FREESTANDINGWATERCOOLER";
IfcElectricApplianceTypeEnum.FREEZER = "FREEZER";
IfcElectricApplianceTypeEnum.FRIDGE_FREEZER = "FRIDGE_FREEZER";
IfcElectricApplianceTypeEnum.HANDDRYER = "HANDDRYER";
IfcElectricApplianceTypeEnum.KITCHENMACHINE = "KITCHENMACHINE";
IfcElectricApplianceTypeEnum.MICROWAVE = "MICROWAVE";
IfcElectricApplianceTypeEnum.PHOTOCOPIER = "PHOTOCOPIER";
IfcElectricApplianceTypeEnum.REFRIGERATOR = "REFRIGERATOR";
IfcElectricApplianceTypeEnum.TUMBLEDRYER = "TUMBLEDRYER";
IfcElectricApplianceTypeEnum.VENDINGMACHINE = "VENDINGMACHINE";
IfcElectricApplianceTypeEnum.WASHINGMACHINE = "WASHINGMACHINE";
IfcElectricApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricDistributionBoardTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricDistributionBoardTypeEnum.CONSUMERUNIT = "CONSUMERUNIT";
IfcElectricDistributionBoardTypeEnum.DISTRIBUTIONBOARD = "DISTRIBUTIONBOARD";
IfcElectricDistributionBoardTypeEnum.MOTORCONTROLCENTRE = "MOTORCONTROLCENTRE";
IfcElectricDistributionBoardTypeEnum.SWITCHBOARD = "SWITCHBOARD";
IfcElectricDistributionBoardTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricDistributionBoardTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricFlowStorageDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricFlowStorageDeviceTypeEnum.BATTERY = "BATTERY";
IfcElectricFlowStorageDeviceTypeEnum.CAPACITORBANK = "CAPACITORBANK";
IfcElectricFlowStorageDeviceTypeEnum.HARMONICFILTER = "HARMONICFILTER";
IfcElectricFlowStorageDeviceTypeEnum.INDUCTORBANK = "INDUCTORBANK";
IfcElectricFlowStorageDeviceTypeEnum.UPS = "UPS";
IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricFlowStorageDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricGeneratorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricGeneratorTypeEnum.CHP = "CHP";
IfcElectricGeneratorTypeEnum.ENGINEGENERATOR = "ENGINEGENERATOR";
IfcElectricGeneratorTypeEnum.STANDALONE = "STANDALONE";
IfcElectricGeneratorTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricGeneratorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricMotorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricMotorTypeEnum.DC = "DC";
IfcElectricMotorTypeEnum.INDUCTION = "INDUCTION";
IfcElectricMotorTypeEnum.POLYPHASE = "POLYPHASE";
IfcElectricMotorTypeEnum.RELUCTANCESYNCHRONOUS = "RELUCTANCESYNCHRONOUS";
IfcElectricMotorTypeEnum.SYNCHRONOUS = "SYNCHRONOUS";
IfcElectricMotorTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricMotorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricTimeControlTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElectricTimeControlTypeEnum.TIMECLOCK = "TIMECLOCK";
IfcElectricTimeControlTypeEnum.TIMEDELAY = "TIMEDELAY";
IfcElectricTimeControlTypeEnum.RELAY = "RELAY";
IfcElectricTimeControlTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricTimeControlTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElementAssemblyTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElementAssemblyTypeEnum.ACCESSORY_ASSEMBLY = "ACCESSORY_ASSEMBLY";
IfcElementAssemblyTypeEnum.ARCH = "ARCH";
IfcElementAssemblyTypeEnum.BEAM_GRID = "BEAM_GRID";
IfcElementAssemblyTypeEnum.BRACED_FRAME = "BRACED_FRAME";
IfcElementAssemblyTypeEnum.GIRDER = "GIRDER";
IfcElementAssemblyTypeEnum.REINFORCEMENT_UNIT = "REINFORCEMENT_UNIT";
IfcElementAssemblyTypeEnum.RIGID_FRAME = "RIGID_FRAME";
IfcElementAssemblyTypeEnum.SLAB_FIELD = "SLAB_FIELD";
IfcElementAssemblyTypeEnum.TRUSS = "TRUSS";
IfcElementAssemblyTypeEnum.ABUTMENT = "ABUTMENT";
IfcElementAssemblyTypeEnum.PIER = "PIER";
IfcElementAssemblyTypeEnum.PYLON = "PYLON";
IfcElementAssemblyTypeEnum.CROSS_BRACING = "CROSS_BRACING";
IfcElementAssemblyTypeEnum.DECK = "DECK";
IfcElementAssemblyTypeEnum.USERDEFINED = "USERDEFINED";
IfcElementAssemblyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElementCompositionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcElementCompositionEnum.COMPLEX = "COMPLEX";
IfcElementCompositionEnum.ELEMENT = "ELEMENT";
IfcElementCompositionEnum.PARTIAL = "PARTIAL";
var IfcEngineTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcEngineTypeEnum.EXTERNALCOMBUSTION = "EXTERNALCOMBUSTION";
IfcEngineTypeEnum.INTERNALCOMBUSTION = "INTERNALCOMBUSTION";
IfcEngineTypeEnum.USERDEFINED = "USERDEFINED";
IfcEngineTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEvaporativeCoolerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER = "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER = "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER = "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER = "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEAIRWASHER = "DIRECTEVAPORATIVEAIRWASHER";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEPACKAGEAIRCOOLER = "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEWETCOIL = "INDIRECTEVAPORATIVEWETCOIL";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER = "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER";
IfcEvaporativeCoolerTypeEnum.INDIRECTDIRECTCOMBINATION = "INDIRECTDIRECTCOMBINATION";
IfcEvaporativeCoolerTypeEnum.USERDEFINED = "USERDEFINED";
IfcEvaporativeCoolerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEvaporatorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcEvaporatorTypeEnum.DIRECTEXPANSION = "DIRECTEXPANSION";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONSHELLANDTUBE = "DIRECTEXPANSIONSHELLANDTUBE";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONTUBEINTUBE = "DIRECTEXPANSIONTUBEINTUBE";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONBRAZEDPLATE = "DIRECTEXPANSIONBRAZEDPLATE";
IfcEvaporatorTypeEnum.FLOODEDSHELLANDTUBE = "FLOODEDSHELLANDTUBE";
IfcEvaporatorTypeEnum.SHELLANDCOIL = "SHELLANDCOIL";
IfcEvaporatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcEvaporatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEventTriggerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcEventTriggerTypeEnum.EVENTRULE = "EVENTRULE";
IfcEventTriggerTypeEnum.EVENTMESSAGE = "EVENTMESSAGE";
IfcEventTriggerTypeEnum.EVENTTIME = "EVENTTIME";
IfcEventTriggerTypeEnum.EVENTCOMPLEX = "EVENTCOMPLEX";
IfcEventTriggerTypeEnum.USERDEFINED = "USERDEFINED";
IfcEventTriggerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEventTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcEventTypeEnum.STARTEVENT = "STARTEVENT";
IfcEventTypeEnum.ENDEVENT = "ENDEVENT";
IfcEventTypeEnum.INTERMEDIATEEVENT = "INTERMEDIATEEVENT";
IfcEventTypeEnum.USERDEFINED = "USERDEFINED";
IfcEventTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcExternalSpatialElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcExternalSpatialElementTypeEnum.EXTERNAL = "EXTERNAL";
IfcExternalSpatialElementTypeEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
IfcExternalSpatialElementTypeEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
IfcExternalSpatialElementTypeEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
IfcExternalSpatialElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcExternalSpatialElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFanTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFanTypeEnum.CENTRIFUGALFORWARDCURVED = "CENTRIFUGALFORWARDCURVED";
IfcFanTypeEnum.CENTRIFUGALRADIAL = "CENTRIFUGALRADIAL";
IfcFanTypeEnum.CENTRIFUGALBACKWARDINCLINEDCURVED = "CENTRIFUGALBACKWARDINCLINEDCURVED";
IfcFanTypeEnum.CENTRIFUGALAIRFOIL = "CENTRIFUGALAIRFOIL";
IfcFanTypeEnum.TUBEAXIAL = "TUBEAXIAL";
IfcFanTypeEnum.VANEAXIAL = "VANEAXIAL";
IfcFanTypeEnum.PROPELLORAXIAL = "PROPELLORAXIAL";
IfcFanTypeEnum.USERDEFINED = "USERDEFINED";
IfcFanTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFastenerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFastenerTypeEnum.GLUE = "GLUE";
IfcFastenerTypeEnum.MORTAR = "MORTAR";
IfcFastenerTypeEnum.WELD = "WELD";
IfcFastenerTypeEnum.USERDEFINED = "USERDEFINED";
IfcFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFilterTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFilterTypeEnum.AIRPARTICLEFILTER = "AIRPARTICLEFILTER";
IfcFilterTypeEnum.COMPRESSEDAIRFILTER = "COMPRESSEDAIRFILTER";
IfcFilterTypeEnum.ODORFILTER = "ODORFILTER";
IfcFilterTypeEnum.OILFILTER = "OILFILTER";
IfcFilterTypeEnum.STRAINER = "STRAINER";
IfcFilterTypeEnum.WATERFILTER = "WATERFILTER";
IfcFilterTypeEnum.USERDEFINED = "USERDEFINED";
IfcFilterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFireSuppressionTerminalTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFireSuppressionTerminalTypeEnum.BREECHINGINLET = "BREECHINGINLET";
IfcFireSuppressionTerminalTypeEnum.FIREHYDRANT = "FIREHYDRANT";
IfcFireSuppressionTerminalTypeEnum.HOSEREEL = "HOSEREEL";
IfcFireSuppressionTerminalTypeEnum.SPRINKLER = "SPRINKLER";
IfcFireSuppressionTerminalTypeEnum.SPRINKLERDEFLECTOR = "SPRINKLERDEFLECTOR";
IfcFireSuppressionTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcFireSuppressionTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowDirectionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFlowDirectionEnum.SOURCE = "SOURCE";
IfcFlowDirectionEnum.SINK = "SINK";
IfcFlowDirectionEnum.SOURCEANDSINK = "SOURCEANDSINK";
IfcFlowDirectionEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowInstrumentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFlowInstrumentTypeEnum.PRESSUREGAUGE = "PRESSUREGAUGE";
IfcFlowInstrumentTypeEnum.THERMOMETER = "THERMOMETER";
IfcFlowInstrumentTypeEnum.AMMETER = "AMMETER";
IfcFlowInstrumentTypeEnum.FREQUENCYMETER = "FREQUENCYMETER";
IfcFlowInstrumentTypeEnum.POWERFACTORMETER = "POWERFACTORMETER";
IfcFlowInstrumentTypeEnum.PHASEANGLEMETER = "PHASEANGLEMETER";
IfcFlowInstrumentTypeEnum.VOLTMETER_PEAK = "VOLTMETER_PEAK";
IfcFlowInstrumentTypeEnum.VOLTMETER_RMS = "VOLTMETER_RMS";
IfcFlowInstrumentTypeEnum.USERDEFINED = "USERDEFINED";
IfcFlowInstrumentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowMeterTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFlowMeterTypeEnum.ENERGYMETER = "ENERGYMETER";
IfcFlowMeterTypeEnum.GASMETER = "GASMETER";
IfcFlowMeterTypeEnum.OILMETER = "OILMETER";
IfcFlowMeterTypeEnum.WATERMETER = "WATERMETER";
IfcFlowMeterTypeEnum.USERDEFINED = "USERDEFINED";
IfcFlowMeterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFootingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFootingTypeEnum.CAISSON_FOUNDATION = "CAISSON_FOUNDATION";
IfcFootingTypeEnum.FOOTING_BEAM = "FOOTING_BEAM";
IfcFootingTypeEnum.PAD_FOOTING = "PAD_FOOTING";
IfcFootingTypeEnum.PILE_CAP = "PILE_CAP";
IfcFootingTypeEnum.STRIP_FOOTING = "STRIP_FOOTING";
IfcFootingTypeEnum.USERDEFINED = "USERDEFINED";
IfcFootingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFurnitureTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcFurnitureTypeEnum.CHAIR = "CHAIR";
IfcFurnitureTypeEnum.TABLE = "TABLE";
IfcFurnitureTypeEnum.DESK = "DESK";
IfcFurnitureTypeEnum.BED = "BED";
IfcFurnitureTypeEnum.FILECABINET = "FILECABINET";
IfcFurnitureTypeEnum.SHELF = "SHELF";
IfcFurnitureTypeEnum.SOFA = "SOFA";
IfcFurnitureTypeEnum.USERDEFINED = "USERDEFINED";
IfcFurnitureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcGeographicElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcGeographicElementTypeEnum.TERRAIN = "TERRAIN";
IfcGeographicElementTypeEnum.SOIL_BORING_POINT = "SOIL_BORING_POINT";
IfcGeographicElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcGeographicElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcGeometricProjectionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcGeometricProjectionEnum.GRAPH_VIEW = "GRAPH_VIEW";
IfcGeometricProjectionEnum.SKETCH_VIEW = "SKETCH_VIEW";
IfcGeometricProjectionEnum.MODEL_VIEW = "MODEL_VIEW";
IfcGeometricProjectionEnum.PLAN_VIEW = "PLAN_VIEW";
IfcGeometricProjectionEnum.REFLECTED_PLAN_VIEW = "REFLECTED_PLAN_VIEW";
IfcGeometricProjectionEnum.SECTION_VIEW = "SECTION_VIEW";
IfcGeometricProjectionEnum.ELEVATION_VIEW = "ELEVATION_VIEW";
IfcGeometricProjectionEnum.USERDEFINED = "USERDEFINED";
IfcGeometricProjectionEnum.NOTDEFINED = "NOTDEFINED";
var IfcGlobalOrLocalEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcGlobalOrLocalEnum.GLOBAL_COORDS = "GLOBAL_COORDS";
IfcGlobalOrLocalEnum.LOCAL_COORDS = "LOCAL_COORDS";
var IfcGridTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcGridTypeEnum.RECTANGULAR = "RECTANGULAR";
IfcGridTypeEnum.RADIAL = "RADIAL";
IfcGridTypeEnum.TRIANGULAR = "TRIANGULAR";
IfcGridTypeEnum.IRREGULAR = "IRREGULAR";
IfcGridTypeEnum.USERDEFINED = "USERDEFINED";
IfcGridTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcHeatExchangerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcHeatExchangerTypeEnum.PLATE = "PLATE";
IfcHeatExchangerTypeEnum.SHELLANDTUBE = "SHELLANDTUBE";
IfcHeatExchangerTypeEnum.USERDEFINED = "USERDEFINED";
IfcHeatExchangerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcHumidifierTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcHumidifierTypeEnum.STEAMINJECTION = "STEAMINJECTION";
IfcHumidifierTypeEnum.ADIABATICAIRWASHER = "ADIABATICAIRWASHER";
IfcHumidifierTypeEnum.ADIABATICPAN = "ADIABATICPAN";
IfcHumidifierTypeEnum.ADIABATICWETTEDELEMENT = "ADIABATICWETTEDELEMENT";
IfcHumidifierTypeEnum.ADIABATICATOMIZING = "ADIABATICATOMIZING";
IfcHumidifierTypeEnum.ADIABATICULTRASONIC = "ADIABATICULTRASONIC";
IfcHumidifierTypeEnum.ADIABATICRIGIDMEDIA = "ADIABATICRIGIDMEDIA";
IfcHumidifierTypeEnum.ADIABATICCOMPRESSEDAIRNOZZLE = "ADIABATICCOMPRESSEDAIRNOZZLE";
IfcHumidifierTypeEnum.ASSISTEDELECTRIC = "ASSISTEDELECTRIC";
IfcHumidifierTypeEnum.ASSISTEDNATURALGAS = "ASSISTEDNATURALGAS";
IfcHumidifierTypeEnum.ASSISTEDPROPANE = "ASSISTEDPROPANE";
IfcHumidifierTypeEnum.ASSISTEDBUTANE = "ASSISTEDBUTANE";
IfcHumidifierTypeEnum.ASSISTEDSTEAM = "ASSISTEDSTEAM";
IfcHumidifierTypeEnum.USERDEFINED = "USERDEFINED";
IfcHumidifierTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcInterceptorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcInterceptorTypeEnum.CYCLONIC = "CYCLONIC";
IfcInterceptorTypeEnum.GREASE = "GREASE";
IfcInterceptorTypeEnum.OIL = "OIL";
IfcInterceptorTypeEnum.PETROL = "PETROL";
IfcInterceptorTypeEnum.USERDEFINED = "USERDEFINED";
IfcInterceptorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcInternalOrExternalEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcInternalOrExternalEnum.INTERNAL = "INTERNAL";
IfcInternalOrExternalEnum.EXTERNAL = "EXTERNAL";
IfcInternalOrExternalEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
IfcInternalOrExternalEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
IfcInternalOrExternalEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
IfcInternalOrExternalEnum.NOTDEFINED = "NOTDEFINED";
var IfcInventoryTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcInventoryTypeEnum.ASSETINVENTORY = "ASSETINVENTORY";
IfcInventoryTypeEnum.SPACEINVENTORY = "SPACEINVENTORY";
IfcInventoryTypeEnum.FURNITUREINVENTORY = "FURNITUREINVENTORY";
IfcInventoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcInventoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcJunctionBoxTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcJunctionBoxTypeEnum.DATA = "DATA";
IfcJunctionBoxTypeEnum.POWER = "POWER";
IfcJunctionBoxTypeEnum.USERDEFINED = "USERDEFINED";
IfcJunctionBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcKnotType = class {
  constructor(v) {
    this.value = v;
  }
};
IfcKnotType.UNIFORM_KNOTS = "UNIFORM_KNOTS";
IfcKnotType.QUASI_UNIFORM_KNOTS = "QUASI_UNIFORM_KNOTS";
IfcKnotType.PIECEWISE_BEZIER_KNOTS = "PIECEWISE_BEZIER_KNOTS";
IfcKnotType.UNSPECIFIED = "UNSPECIFIED";
var IfcLaborResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLaborResourceTypeEnum.ADMINISTRATION = "ADMINISTRATION";
IfcLaborResourceTypeEnum.CARPENTRY = "CARPENTRY";
IfcLaborResourceTypeEnum.CLEANING = "CLEANING";
IfcLaborResourceTypeEnum.CONCRETE = "CONCRETE";
IfcLaborResourceTypeEnum.DRYWALL = "DRYWALL";
IfcLaborResourceTypeEnum.ELECTRIC = "ELECTRIC";
IfcLaborResourceTypeEnum.FINISHING = "FINISHING";
IfcLaborResourceTypeEnum.FLOORING = "FLOORING";
IfcLaborResourceTypeEnum.GENERAL = "GENERAL";
IfcLaborResourceTypeEnum.HVAC = "HVAC";
IfcLaborResourceTypeEnum.LANDSCAPING = "LANDSCAPING";
IfcLaborResourceTypeEnum.MASONRY = "MASONRY";
IfcLaborResourceTypeEnum.PAINTING = "PAINTING";
IfcLaborResourceTypeEnum.PAVING = "PAVING";
IfcLaborResourceTypeEnum.PLUMBING = "PLUMBING";
IfcLaborResourceTypeEnum.ROOFING = "ROOFING";
IfcLaborResourceTypeEnum.SITEGRADING = "SITEGRADING";
IfcLaborResourceTypeEnum.STEELWORK = "STEELWORK";
IfcLaborResourceTypeEnum.SURVEYING = "SURVEYING";
IfcLaborResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcLaborResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLampTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLampTypeEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
IfcLampTypeEnum.FLUORESCENT = "FLUORESCENT";
IfcLampTypeEnum.HALOGEN = "HALOGEN";
IfcLampTypeEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
IfcLampTypeEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
IfcLampTypeEnum.LED = "LED";
IfcLampTypeEnum.METALHALIDE = "METALHALIDE";
IfcLampTypeEnum.OLED = "OLED";
IfcLampTypeEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
IfcLampTypeEnum.USERDEFINED = "USERDEFINED";
IfcLampTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLayerSetDirectionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLayerSetDirectionEnum.AXIS1 = "AXIS1";
IfcLayerSetDirectionEnum.AXIS2 = "AXIS2";
IfcLayerSetDirectionEnum.AXIS3 = "AXIS3";
var IfcLightDistributionCurveEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLightDistributionCurveEnum.TYPE_A = "TYPE_A";
IfcLightDistributionCurveEnum.TYPE_B = "TYPE_B";
IfcLightDistributionCurveEnum.TYPE_C = "TYPE_C";
IfcLightDistributionCurveEnum.NOTDEFINED = "NOTDEFINED";
var IfcLightEmissionSourceEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLightEmissionSourceEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
IfcLightEmissionSourceEnum.FLUORESCENT = "FLUORESCENT";
IfcLightEmissionSourceEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
IfcLightEmissionSourceEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
IfcLightEmissionSourceEnum.LIGHTEMITTINGDIODE = "LIGHTEMITTINGDIODE";
IfcLightEmissionSourceEnum.LOWPRESSURESODIUM = "LOWPRESSURESODIUM";
IfcLightEmissionSourceEnum.LOWVOLTAGEHALOGEN = "LOWVOLTAGEHALOGEN";
IfcLightEmissionSourceEnum.MAINVOLTAGEHALOGEN = "MAINVOLTAGEHALOGEN";
IfcLightEmissionSourceEnum.METALHALIDE = "METALHALIDE";
IfcLightEmissionSourceEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
IfcLightEmissionSourceEnum.NOTDEFINED = "NOTDEFINED";
var IfcLightFixtureTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLightFixtureTypeEnum.POINTSOURCE = "POINTSOURCE";
IfcLightFixtureTypeEnum.DIRECTIONSOURCE = "DIRECTIONSOURCE";
IfcLightFixtureTypeEnum.SECURITYLIGHTING = "SECURITYLIGHTING";
IfcLightFixtureTypeEnum.USERDEFINED = "USERDEFINED";
IfcLightFixtureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLoadGroupTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLoadGroupTypeEnum.LOAD_GROUP = "LOAD_GROUP";
IfcLoadGroupTypeEnum.LOAD_CASE = "LOAD_CASE";
IfcLoadGroupTypeEnum.LOAD_COMBINATION = "LOAD_COMBINATION";
IfcLoadGroupTypeEnum.USERDEFINED = "USERDEFINED";
IfcLoadGroupTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLogicalOperatorEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcLogicalOperatorEnum.LOGICALAND = "LOGICALAND";
IfcLogicalOperatorEnum.LOGICALOR = "LOGICALOR";
IfcLogicalOperatorEnum.LOGICALXOR = "LOGICALXOR";
IfcLogicalOperatorEnum.LOGICALNOTAND = "LOGICALNOTAND";
IfcLogicalOperatorEnum.LOGICALNOTOR = "LOGICALNOTOR";
var IfcMechanicalFastenerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcMechanicalFastenerTypeEnum.ANCHORBOLT = "ANCHORBOLT";
IfcMechanicalFastenerTypeEnum.BOLT = "BOLT";
IfcMechanicalFastenerTypeEnum.DOWEL = "DOWEL";
IfcMechanicalFastenerTypeEnum.NAIL = "NAIL";
IfcMechanicalFastenerTypeEnum.NAILPLATE = "NAILPLATE";
IfcMechanicalFastenerTypeEnum.RIVET = "RIVET";
IfcMechanicalFastenerTypeEnum.SCREW = "SCREW";
IfcMechanicalFastenerTypeEnum.SHEARCONNECTOR = "SHEARCONNECTOR";
IfcMechanicalFastenerTypeEnum.STAPLE = "STAPLE";
IfcMechanicalFastenerTypeEnum.STUDSHEARCONNECTOR = "STUDSHEARCONNECTOR";
IfcMechanicalFastenerTypeEnum.COUPLER = "COUPLER";
IfcMechanicalFastenerTypeEnum.USERDEFINED = "USERDEFINED";
IfcMechanicalFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMedicalDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcMedicalDeviceTypeEnum.AIRSTATION = "AIRSTATION";
IfcMedicalDeviceTypeEnum.FEEDAIRUNIT = "FEEDAIRUNIT";
IfcMedicalDeviceTypeEnum.OXYGENGENERATOR = "OXYGENGENERATOR";
IfcMedicalDeviceTypeEnum.OXYGENPLANT = "OXYGENPLANT";
IfcMedicalDeviceTypeEnum.VACUUMSTATION = "VACUUMSTATION";
IfcMedicalDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcMedicalDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMemberTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcMemberTypeEnum.BRACE = "BRACE";
IfcMemberTypeEnum.CHORD = "CHORD";
IfcMemberTypeEnum.COLLAR = "COLLAR";
IfcMemberTypeEnum.MEMBER = "MEMBER";
IfcMemberTypeEnum.MULLION = "MULLION";
IfcMemberTypeEnum.PLATE = "PLATE";
IfcMemberTypeEnum.POST = "POST";
IfcMemberTypeEnum.PURLIN = "PURLIN";
IfcMemberTypeEnum.RAFTER = "RAFTER";
IfcMemberTypeEnum.STRINGER = "STRINGER";
IfcMemberTypeEnum.STRUT = "STRUT";
IfcMemberTypeEnum.STUD = "STUD";
IfcMemberTypeEnum.STIFFENING_RIB = "STIFFENING_RIB";
IfcMemberTypeEnum.ARCH_SEGMENT = "ARCH_SEGMENT";
IfcMemberTypeEnum.SUSPENSION_CABLE = "SUSPENSION_CABLE";
IfcMemberTypeEnum.SUSPENDER = "SUSPENDER";
IfcMemberTypeEnum.STAY_CABLE = "STAY_CABLE";
IfcMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMotorConnectionTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcMotorConnectionTypeEnum.BELTDRIVE = "BELTDRIVE";
IfcMotorConnectionTypeEnum.COUPLING = "COUPLING";
IfcMotorConnectionTypeEnum.DIRECTDRIVE = "DIRECTDRIVE";
IfcMotorConnectionTypeEnum.USERDEFINED = "USERDEFINED";
IfcMotorConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcNullStyle = class {
  constructor(v) {
    this.value = v;
  }
};
IfcNullStyle.NULL = "NULL";
var IfcObjectTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcObjectTypeEnum.PRODUCT = "PRODUCT";
IfcObjectTypeEnum.PROCESS = "PROCESS";
IfcObjectTypeEnum.CONTROL = "CONTROL";
IfcObjectTypeEnum.RESOURCE = "RESOURCE";
IfcObjectTypeEnum.ACTOR = "ACTOR";
IfcObjectTypeEnum.GROUP = "GROUP";
IfcObjectTypeEnum.PROJECT = "PROJECT";
IfcObjectTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcObjectiveEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcObjectiveEnum.CODECOMPLIANCE = "CODECOMPLIANCE";
IfcObjectiveEnum.CODEWAIVER = "CODEWAIVER";
IfcObjectiveEnum.DESIGNINTENT = "DESIGNINTENT";
IfcObjectiveEnum.EXTERNAL = "EXTERNAL";
IfcObjectiveEnum.HEALTHANDSAFETY = "HEALTHANDSAFETY";
IfcObjectiveEnum.MERGECONFLICT = "MERGECONFLICT";
IfcObjectiveEnum.MODELVIEW = "MODELVIEW";
IfcObjectiveEnum.PARAMETER = "PARAMETER";
IfcObjectiveEnum.REQUIREMENT = "REQUIREMENT";
IfcObjectiveEnum.SPECIFICATION = "SPECIFICATION";
IfcObjectiveEnum.TRIGGERCONDITION = "TRIGGERCONDITION";
IfcObjectiveEnum.USERDEFINED = "USERDEFINED";
IfcObjectiveEnum.NOTDEFINED = "NOTDEFINED";
var IfcOccupantTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcOccupantTypeEnum.ASSIGNEE = "ASSIGNEE";
IfcOccupantTypeEnum.ASSIGNOR = "ASSIGNOR";
IfcOccupantTypeEnum.LESSEE = "LESSEE";
IfcOccupantTypeEnum.LESSOR = "LESSOR";
IfcOccupantTypeEnum.LETTINGAGENT = "LETTINGAGENT";
IfcOccupantTypeEnum.OWNER = "OWNER";
IfcOccupantTypeEnum.TENANT = "TENANT";
IfcOccupantTypeEnum.USERDEFINED = "USERDEFINED";
IfcOccupantTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcOpeningElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcOpeningElementTypeEnum.OPENING = "OPENING";
IfcOpeningElementTypeEnum.RECESS = "RECESS";
IfcOpeningElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcOpeningElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcOutletTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcOutletTypeEnum.AUDIOVISUALOUTLET = "AUDIOVISUALOUTLET";
IfcOutletTypeEnum.COMMUNICATIONSOUTLET = "COMMUNICATIONSOUTLET";
IfcOutletTypeEnum.POWEROUTLET = "POWEROUTLET";
IfcOutletTypeEnum.DATAOUTLET = "DATAOUTLET";
IfcOutletTypeEnum.TELEPHONEOUTLET = "TELEPHONEOUTLET";
IfcOutletTypeEnum.USERDEFINED = "USERDEFINED";
IfcOutletTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPerformanceHistoryTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPerformanceHistoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcPerformanceHistoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPermeableCoveringOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPermeableCoveringOperationEnum.GRILL = "GRILL";
IfcPermeableCoveringOperationEnum.LOUVER = "LOUVER";
IfcPermeableCoveringOperationEnum.SCREEN = "SCREEN";
IfcPermeableCoveringOperationEnum.USERDEFINED = "USERDEFINED";
IfcPermeableCoveringOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcPermitTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPermitTypeEnum.ACCESS = "ACCESS";
IfcPermitTypeEnum.BUILDING = "BUILDING";
IfcPermitTypeEnum.WORK = "WORK";
IfcPermitTypeEnum.USERDEFINED = "USERDEFINED";
IfcPermitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPhysicalOrVirtualEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPhysicalOrVirtualEnum.PHYSICAL = "PHYSICAL";
IfcPhysicalOrVirtualEnum.VIRTUAL = "VIRTUAL";
IfcPhysicalOrVirtualEnum.NOTDEFINED = "NOTDEFINED";
var IfcPileConstructionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPileConstructionEnum.CAST_IN_PLACE = "CAST_IN_PLACE";
IfcPileConstructionEnum.COMPOSITE = "COMPOSITE";
IfcPileConstructionEnum.PRECAST_CONCRETE = "PRECAST_CONCRETE";
IfcPileConstructionEnum.PREFAB_STEEL = "PREFAB_STEEL";
IfcPileConstructionEnum.USERDEFINED = "USERDEFINED";
IfcPileConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcPileTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPileTypeEnum.BORED = "BORED";
IfcPileTypeEnum.DRIVEN = "DRIVEN";
IfcPileTypeEnum.JETGROUTING = "JETGROUTING";
IfcPileTypeEnum.COHESION = "COHESION";
IfcPileTypeEnum.FRICTION = "FRICTION";
IfcPileTypeEnum.SUPPORT = "SUPPORT";
IfcPileTypeEnum.USERDEFINED = "USERDEFINED";
IfcPileTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPipeFittingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPipeFittingTypeEnum.BEND = "BEND";
IfcPipeFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcPipeFittingTypeEnum.ENTRY = "ENTRY";
IfcPipeFittingTypeEnum.EXIT = "EXIT";
IfcPipeFittingTypeEnum.JUNCTION = "JUNCTION";
IfcPipeFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
IfcPipeFittingTypeEnum.TRANSITION = "TRANSITION";
IfcPipeFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcPipeFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPipeSegmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPipeSegmentTypeEnum.CULVERT = "CULVERT";
IfcPipeSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
IfcPipeSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
IfcPipeSegmentTypeEnum.GUTTER = "GUTTER";
IfcPipeSegmentTypeEnum.SPOOL = "SPOOL";
IfcPipeSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcPipeSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPlateTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPlateTypeEnum.CURTAIN_PANEL = "CURTAIN_PANEL";
IfcPlateTypeEnum.SHEET = "SHEET";
IfcPlateTypeEnum.FLANGE_PLATE = "FLANGE_PLATE";
IfcPlateTypeEnum.WEB_PLATE = "WEB_PLATE";
IfcPlateTypeEnum.STIFFENER_PLATE = "STIFFENER_PLATE";
IfcPlateTypeEnum.GUSSET_PLATE = "GUSSET_PLATE";
IfcPlateTypeEnum.COVER_PLATE = "COVER_PLATE";
IfcPlateTypeEnum.SPLICE_PLATE = "SPLICE_PLATE";
IfcPlateTypeEnum.BASE_PLATE = "BASE_PLATE";
IfcPlateTypeEnum.USERDEFINED = "USERDEFINED";
IfcPlateTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPreferredSurfaceCurveRepresentation = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPreferredSurfaceCurveRepresentation.CURVE3D = "CURVE3D";
IfcPreferredSurfaceCurveRepresentation.PCURVE_S1 = "PCURVE_S1";
IfcPreferredSurfaceCurveRepresentation.PCURVE_S2 = "PCURVE_S2";
var IfcProcedureTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProcedureTypeEnum.ADVICE_CAUTION = "ADVICE_CAUTION";
IfcProcedureTypeEnum.ADVICE_NOTE = "ADVICE_NOTE";
IfcProcedureTypeEnum.ADVICE_WARNING = "ADVICE_WARNING";
IfcProcedureTypeEnum.CALIBRATION = "CALIBRATION";
IfcProcedureTypeEnum.DIAGNOSTIC = "DIAGNOSTIC";
IfcProcedureTypeEnum.SHUTDOWN = "SHUTDOWN";
IfcProcedureTypeEnum.STARTUP = "STARTUP";
IfcProcedureTypeEnum.USERDEFINED = "USERDEFINED";
IfcProcedureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProfileTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProfileTypeEnum.CURVE = "CURVE";
IfcProfileTypeEnum.AREA = "AREA";
var IfcProjectOrderTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProjectOrderTypeEnum.CHANGEORDER = "CHANGEORDER";
IfcProjectOrderTypeEnum.MAINTENANCEWORKORDER = "MAINTENANCEWORKORDER";
IfcProjectOrderTypeEnum.MOVEORDER = "MOVEORDER";
IfcProjectOrderTypeEnum.PURCHASEORDER = "PURCHASEORDER";
IfcProjectOrderTypeEnum.WORKORDER = "WORKORDER";
IfcProjectOrderTypeEnum.USERDEFINED = "USERDEFINED";
IfcProjectOrderTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProjectedOrTrueLengthEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProjectedOrTrueLengthEnum.PROJECTED_LENGTH = "PROJECTED_LENGTH";
IfcProjectedOrTrueLengthEnum.TRUE_LENGTH = "TRUE_LENGTH";
var IfcProjectionElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProjectionElementTypeEnum.BLISTER = "BLISTER";
IfcProjectionElementTypeEnum.DEVIATOR = "DEVIATOR";
IfcProjectionElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcProjectionElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPropertySetTemplateTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENONLY = "PSET_TYPEDRIVENONLY";
IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENOVERRIDE = "PSET_TYPEDRIVENOVERRIDE";
IfcPropertySetTemplateTypeEnum.PSET_OCCURRENCEDRIVEN = "PSET_OCCURRENCEDRIVEN";
IfcPropertySetTemplateTypeEnum.PSET_PERFORMANCEDRIVEN = "PSET_PERFORMANCEDRIVEN";
IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENONLY = "QTO_TYPEDRIVENONLY";
IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENOVERRIDE = "QTO_TYPEDRIVENOVERRIDE";
IfcPropertySetTemplateTypeEnum.QTO_OCCURRENCEDRIVEN = "QTO_OCCURRENCEDRIVEN";
IfcPropertySetTemplateTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProtectiveDeviceTrippingUnitTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTRONIC = "ELECTRONIC";
IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTROMAGNETIC = "ELECTROMAGNETIC";
IfcProtectiveDeviceTrippingUnitTypeEnum.RESIDUALCURRENT = "RESIDUALCURRENT";
IfcProtectiveDeviceTrippingUnitTypeEnum.THERMAL = "THERMAL";
IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED = "USERDEFINED";
IfcProtectiveDeviceTrippingUnitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProtectiveDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcProtectiveDeviceTypeEnum.CIRCUITBREAKER = "CIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.EARTHLEAKAGECIRCUITBREAKER = "EARTHLEAKAGECIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.EARTHINGSWITCH = "EARTHINGSWITCH";
IfcProtectiveDeviceTypeEnum.FUSEDISCONNECTOR = "FUSEDISCONNECTOR";
IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTCIRCUITBREAKER = "RESIDUALCURRENTCIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTSWITCH = "RESIDUALCURRENTSWITCH";
IfcProtectiveDeviceTypeEnum.VARISTOR = "VARISTOR";
IfcProtectiveDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcProtectiveDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPumpTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcPumpTypeEnum.CIRCULATOR = "CIRCULATOR";
IfcPumpTypeEnum.ENDSUCTION = "ENDSUCTION";
IfcPumpTypeEnum.SPLITCASE = "SPLITCASE";
IfcPumpTypeEnum.SUBMERSIBLEPUMP = "SUBMERSIBLEPUMP";
IfcPumpTypeEnum.SUMPPUMP = "SUMPPUMP";
IfcPumpTypeEnum.VERTICALINLINE = "VERTICALINLINE";
IfcPumpTypeEnum.VERTICALTURBINE = "VERTICALTURBINE";
IfcPumpTypeEnum.USERDEFINED = "USERDEFINED";
IfcPumpTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRailingTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRailingTypeEnum.HANDRAIL = "HANDRAIL";
IfcRailingTypeEnum.GUARDRAIL = "GUARDRAIL";
IfcRailingTypeEnum.BALUSTRADE = "BALUSTRADE";
IfcRailingTypeEnum.USERDEFINED = "USERDEFINED";
IfcRailingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRampFlightTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRampFlightTypeEnum.STRAIGHT = "STRAIGHT";
IfcRampFlightTypeEnum.SPIRAL = "SPIRAL";
IfcRampFlightTypeEnum.USERDEFINED = "USERDEFINED";
IfcRampFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRampTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRampTypeEnum.STRAIGHT_RUN_RAMP = "STRAIGHT_RUN_RAMP";
IfcRampTypeEnum.TWO_STRAIGHT_RUN_RAMP = "TWO_STRAIGHT_RUN_RAMP";
IfcRampTypeEnum.QUARTER_TURN_RAMP = "QUARTER_TURN_RAMP";
IfcRampTypeEnum.TWO_QUARTER_TURN_RAMP = "TWO_QUARTER_TURN_RAMP";
IfcRampTypeEnum.HALF_TURN_RAMP = "HALF_TURN_RAMP";
IfcRampTypeEnum.SPIRAL_RAMP = "SPIRAL_RAMP";
IfcRampTypeEnum.USERDEFINED = "USERDEFINED";
IfcRampTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRecurrenceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRecurrenceTypeEnum.DAILY = "DAILY";
IfcRecurrenceTypeEnum.WEEKLY = "WEEKLY";
IfcRecurrenceTypeEnum.MONTHLY_BY_DAY_OF_MONTH = "MONTHLY_BY_DAY_OF_MONTH";
IfcRecurrenceTypeEnum.MONTHLY_BY_POSITION = "MONTHLY_BY_POSITION";
IfcRecurrenceTypeEnum.BY_DAY_COUNT = "BY_DAY_COUNT";
IfcRecurrenceTypeEnum.BY_WEEKDAY_COUNT = "BY_WEEKDAY_COUNT";
IfcRecurrenceTypeEnum.YEARLY_BY_DAY_OF_MONTH = "YEARLY_BY_DAY_OF_MONTH";
IfcRecurrenceTypeEnum.YEARLY_BY_POSITION = "YEARLY_BY_POSITION";
var IfcReferentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReferentTypeEnum.KILOPOINT = "KILOPOINT";
IfcReferentTypeEnum.MILEPOINT = "MILEPOINT";
IfcReferentTypeEnum.STATION = "STATION";
IfcReferentTypeEnum.USERDEFINED = "USERDEFINED";
IfcReferentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcReflectanceMethodEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReflectanceMethodEnum.BLINN = "BLINN";
IfcReflectanceMethodEnum.FLAT = "FLAT";
IfcReflectanceMethodEnum.GLASS = "GLASS";
IfcReflectanceMethodEnum.MATT = "MATT";
IfcReflectanceMethodEnum.METAL = "METAL";
IfcReflectanceMethodEnum.MIRROR = "MIRROR";
IfcReflectanceMethodEnum.PHONG = "PHONG";
IfcReflectanceMethodEnum.PLASTIC = "PLASTIC";
IfcReflectanceMethodEnum.STRAUSS = "STRAUSS";
IfcReflectanceMethodEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingBarRoleEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReinforcingBarRoleEnum.MAIN = "MAIN";
IfcReinforcingBarRoleEnum.SHEAR = "SHEAR";
IfcReinforcingBarRoleEnum.LIGATURE = "LIGATURE";
IfcReinforcingBarRoleEnum.STUD = "STUD";
IfcReinforcingBarRoleEnum.PUNCHING = "PUNCHING";
IfcReinforcingBarRoleEnum.EDGE = "EDGE";
IfcReinforcingBarRoleEnum.RING = "RING";
IfcReinforcingBarRoleEnum.ANCHORING = "ANCHORING";
IfcReinforcingBarRoleEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingBarRoleEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingBarSurfaceEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReinforcingBarSurfaceEnum.PLAIN = "PLAIN";
IfcReinforcingBarSurfaceEnum.TEXTURED = "TEXTURED";
var IfcReinforcingBarTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReinforcingBarTypeEnum.ANCHORING = "ANCHORING";
IfcReinforcingBarTypeEnum.EDGE = "EDGE";
IfcReinforcingBarTypeEnum.LIGATURE = "LIGATURE";
IfcReinforcingBarTypeEnum.MAIN = "MAIN";
IfcReinforcingBarTypeEnum.PUNCHING = "PUNCHING";
IfcReinforcingBarTypeEnum.RING = "RING";
IfcReinforcingBarTypeEnum.SHEAR = "SHEAR";
IfcReinforcingBarTypeEnum.STUD = "STUD";
IfcReinforcingBarTypeEnum.SPACEBAR = "SPACEBAR";
IfcReinforcingBarTypeEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingBarTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingMeshTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcReinforcingMeshTypeEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingMeshTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRoleEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRoleEnum.SUPPLIER = "SUPPLIER";
IfcRoleEnum.MANUFACTURER = "MANUFACTURER";
IfcRoleEnum.CONTRACTOR = "CONTRACTOR";
IfcRoleEnum.SUBCONTRACTOR = "SUBCONTRACTOR";
IfcRoleEnum.ARCHITECT = "ARCHITECT";
IfcRoleEnum.STRUCTURALENGINEER = "STRUCTURALENGINEER";
IfcRoleEnum.COSTENGINEER = "COSTENGINEER";
IfcRoleEnum.CLIENT = "CLIENT";
IfcRoleEnum.BUILDINGOWNER = "BUILDINGOWNER";
IfcRoleEnum.BUILDINGOPERATOR = "BUILDINGOPERATOR";
IfcRoleEnum.MECHANICALENGINEER = "MECHANICALENGINEER";
IfcRoleEnum.ELECTRICALENGINEER = "ELECTRICALENGINEER";
IfcRoleEnum.PROJECTMANAGER = "PROJECTMANAGER";
IfcRoleEnum.FACILITIESMANAGER = "FACILITIESMANAGER";
IfcRoleEnum.CIVILENGINEER = "CIVILENGINEER";
IfcRoleEnum.COMMISSIONINGENGINEER = "COMMISSIONINGENGINEER";
IfcRoleEnum.ENGINEER = "ENGINEER";
IfcRoleEnum.OWNER = "OWNER";
IfcRoleEnum.CONSULTANT = "CONSULTANT";
IfcRoleEnum.CONSTRUCTIONMANAGER = "CONSTRUCTIONMANAGER";
IfcRoleEnum.FIELDCONSTRUCTIONMANAGER = "FIELDCONSTRUCTIONMANAGER";
IfcRoleEnum.RESELLER = "RESELLER";
IfcRoleEnum.USERDEFINED = "USERDEFINED";
var IfcRoofTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcRoofTypeEnum.FLAT_ROOF = "FLAT_ROOF";
IfcRoofTypeEnum.SHED_ROOF = "SHED_ROOF";
IfcRoofTypeEnum.GABLE_ROOF = "GABLE_ROOF";
IfcRoofTypeEnum.HIP_ROOF = "HIP_ROOF";
IfcRoofTypeEnum.HIPPED_GABLE_ROOF = "HIPPED_GABLE_ROOF";
IfcRoofTypeEnum.GAMBREL_ROOF = "GAMBREL_ROOF";
IfcRoofTypeEnum.MANSARD_ROOF = "MANSARD_ROOF";
IfcRoofTypeEnum.BARREL_ROOF = "BARREL_ROOF";
IfcRoofTypeEnum.RAINBOW_ROOF = "RAINBOW_ROOF";
IfcRoofTypeEnum.BUTTERFLY_ROOF = "BUTTERFLY_ROOF";
IfcRoofTypeEnum.PAVILION_ROOF = "PAVILION_ROOF";
IfcRoofTypeEnum.DOME_ROOF = "DOME_ROOF";
IfcRoofTypeEnum.FREEFORM = "FREEFORM";
IfcRoofTypeEnum.USERDEFINED = "USERDEFINED";
IfcRoofTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSIPrefix = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSIPrefix.EXA = "EXA";
IfcSIPrefix.PETA = "PETA";
IfcSIPrefix.TERA = "TERA";
IfcSIPrefix.GIGA = "GIGA";
IfcSIPrefix.MEGA = "MEGA";
IfcSIPrefix.KILO = "KILO";
IfcSIPrefix.HECTO = "HECTO";
IfcSIPrefix.DECA = "DECA";
IfcSIPrefix.DECI = "DECI";
IfcSIPrefix.CENTI = "CENTI";
IfcSIPrefix.MILLI = "MILLI";
IfcSIPrefix.MICRO = "MICRO";
IfcSIPrefix.NANO = "NANO";
IfcSIPrefix.PICO = "PICO";
IfcSIPrefix.FEMTO = "FEMTO";
IfcSIPrefix.ATTO = "ATTO";
var IfcSIUnitName = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSIUnitName.AMPERE = "AMPERE";
IfcSIUnitName.BECQUEREL = "BECQUEREL";
IfcSIUnitName.CANDELA = "CANDELA";
IfcSIUnitName.COULOMB = "COULOMB";
IfcSIUnitName.CUBIC_METRE = "CUBIC_METRE";
IfcSIUnitName.DEGREE_CELSIUS = "DEGREE_CELSIUS";
IfcSIUnitName.FARAD = "FARAD";
IfcSIUnitName.GRAM = "GRAM";
IfcSIUnitName.GRAY = "GRAY";
IfcSIUnitName.HENRY = "HENRY";
IfcSIUnitName.HERTZ = "HERTZ";
IfcSIUnitName.JOULE = "JOULE";
IfcSIUnitName.KELVIN = "KELVIN";
IfcSIUnitName.LUMEN = "LUMEN";
IfcSIUnitName.LUX = "LUX";
IfcSIUnitName.METRE = "METRE";
IfcSIUnitName.MOLE = "MOLE";
IfcSIUnitName.NEWTON = "NEWTON";
IfcSIUnitName.OHM = "OHM";
IfcSIUnitName.PASCAL = "PASCAL";
IfcSIUnitName.RADIAN = "RADIAN";
IfcSIUnitName.SECOND = "SECOND";
IfcSIUnitName.SIEMENS = "SIEMENS";
IfcSIUnitName.SIEVERT = "SIEVERT";
IfcSIUnitName.SQUARE_METRE = "SQUARE_METRE";
IfcSIUnitName.STERADIAN = "STERADIAN";
IfcSIUnitName.TESLA = "TESLA";
IfcSIUnitName.VOLT = "VOLT";
IfcSIUnitName.WATT = "WATT";
IfcSIUnitName.WEBER = "WEBER";
var IfcSanitaryTerminalTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSanitaryTerminalTypeEnum.BATH = "BATH";
IfcSanitaryTerminalTypeEnum.BIDET = "BIDET";
IfcSanitaryTerminalTypeEnum.CISTERN = "CISTERN";
IfcSanitaryTerminalTypeEnum.SHOWER = "SHOWER";
IfcSanitaryTerminalTypeEnum.SINK = "SINK";
IfcSanitaryTerminalTypeEnum.SANITARYFOUNTAIN = "SANITARYFOUNTAIN";
IfcSanitaryTerminalTypeEnum.TOILETPAN = "TOILETPAN";
IfcSanitaryTerminalTypeEnum.URINAL = "URINAL";
IfcSanitaryTerminalTypeEnum.WASHHANDBASIN = "WASHHANDBASIN";
IfcSanitaryTerminalTypeEnum.WCSEAT = "WCSEAT";
IfcSanitaryTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcSanitaryTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSectionTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSectionTypeEnum.UNIFORM = "UNIFORM";
IfcSectionTypeEnum.TAPERED = "TAPERED";
var IfcSensorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSensorTypeEnum.COSENSOR = "COSENSOR";
IfcSensorTypeEnum.CO2SENSOR = "CO2SENSOR";
IfcSensorTypeEnum.CONDUCTANCESENSOR = "CONDUCTANCESENSOR";
IfcSensorTypeEnum.CONTACTSENSOR = "CONTACTSENSOR";
IfcSensorTypeEnum.FIRESENSOR = "FIRESENSOR";
IfcSensorTypeEnum.FLOWSENSOR = "FLOWSENSOR";
IfcSensorTypeEnum.FROSTSENSOR = "FROSTSENSOR";
IfcSensorTypeEnum.GASSENSOR = "GASSENSOR";
IfcSensorTypeEnum.HEATSENSOR = "HEATSENSOR";
IfcSensorTypeEnum.HUMIDITYSENSOR = "HUMIDITYSENSOR";
IfcSensorTypeEnum.IDENTIFIERSENSOR = "IDENTIFIERSENSOR";
IfcSensorTypeEnum.IONCONCENTRATIONSENSOR = "IONCONCENTRATIONSENSOR";
IfcSensorTypeEnum.LEVELSENSOR = "LEVELSENSOR";
IfcSensorTypeEnum.LIGHTSENSOR = "LIGHTSENSOR";
IfcSensorTypeEnum.MOISTURESENSOR = "MOISTURESENSOR";
IfcSensorTypeEnum.MOVEMENTSENSOR = "MOVEMENTSENSOR";
IfcSensorTypeEnum.PHSENSOR = "PHSENSOR";
IfcSensorTypeEnum.PRESSURESENSOR = "PRESSURESENSOR";
IfcSensorTypeEnum.RADIATIONSENSOR = "RADIATIONSENSOR";
IfcSensorTypeEnum.RADIOACTIVITYSENSOR = "RADIOACTIVITYSENSOR";
IfcSensorTypeEnum.SMOKESENSOR = "SMOKESENSOR";
IfcSensorTypeEnum.SOUNDSENSOR = "SOUNDSENSOR";
IfcSensorTypeEnum.TEMPERATURESENSOR = "TEMPERATURESENSOR";
IfcSensorTypeEnum.WINDSENSOR = "WINDSENSOR";
IfcSensorTypeEnum.USERDEFINED = "USERDEFINED";
IfcSensorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSequenceEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSequenceEnum.START_START = "START_START";
IfcSequenceEnum.START_FINISH = "START_FINISH";
IfcSequenceEnum.FINISH_START = "FINISH_START";
IfcSequenceEnum.FINISH_FINISH = "FINISH_FINISH";
IfcSequenceEnum.USERDEFINED = "USERDEFINED";
IfcSequenceEnum.NOTDEFINED = "NOTDEFINED";
var IfcShadingDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcShadingDeviceTypeEnum.JALOUSIE = "JALOUSIE";
IfcShadingDeviceTypeEnum.SHUTTER = "SHUTTER";
IfcShadingDeviceTypeEnum.AWNING = "AWNING";
IfcShadingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcShadingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSimplePropertyTemplateTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSimplePropertyTemplateTypeEnum.P_SINGLEVALUE = "P_SINGLEVALUE";
IfcSimplePropertyTemplateTypeEnum.P_ENUMERATEDVALUE = "P_ENUMERATEDVALUE";
IfcSimplePropertyTemplateTypeEnum.P_BOUNDEDVALUE = "P_BOUNDEDVALUE";
IfcSimplePropertyTemplateTypeEnum.P_LISTVALUE = "P_LISTVALUE";
IfcSimplePropertyTemplateTypeEnum.P_TABLEVALUE = "P_TABLEVALUE";
IfcSimplePropertyTemplateTypeEnum.P_REFERENCEVALUE = "P_REFERENCEVALUE";
IfcSimplePropertyTemplateTypeEnum.Q_LENGTH = "Q_LENGTH";
IfcSimplePropertyTemplateTypeEnum.Q_AREA = "Q_AREA";
IfcSimplePropertyTemplateTypeEnum.Q_VOLUME = "Q_VOLUME";
IfcSimplePropertyTemplateTypeEnum.Q_COUNT = "Q_COUNT";
IfcSimplePropertyTemplateTypeEnum.Q_WEIGHT = "Q_WEIGHT";
IfcSimplePropertyTemplateTypeEnum.Q_TIME = "Q_TIME";
var IfcSlabTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSlabTypeEnum.FLOOR = "FLOOR";
IfcSlabTypeEnum.ROOF = "ROOF";
IfcSlabTypeEnum.LANDING = "LANDING";
IfcSlabTypeEnum.BASESLAB = "BASESLAB";
IfcSlabTypeEnum.APPROACH_SLAB = "APPROACH_SLAB";
IfcSlabTypeEnum.PAVING = "PAVING";
IfcSlabTypeEnum.WEARING = "WEARING";
IfcSlabTypeEnum.SIDEWALK = "SIDEWALK";
IfcSlabTypeEnum.USERDEFINED = "USERDEFINED";
IfcSlabTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSolarDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSolarDeviceTypeEnum.SOLARCOLLECTOR = "SOLARCOLLECTOR";
IfcSolarDeviceTypeEnum.SOLARPANEL = "SOLARPANEL";
IfcSolarDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSolarDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpaceHeaterTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSpaceHeaterTypeEnum.CONVECTOR = "CONVECTOR";
IfcSpaceHeaterTypeEnum.RADIATOR = "RADIATOR";
IfcSpaceHeaterTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpaceHeaterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpaceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSpaceTypeEnum.SPACE = "SPACE";
IfcSpaceTypeEnum.PARKING = "PARKING";
IfcSpaceTypeEnum.GFA = "GFA";
IfcSpaceTypeEnum.INTERNAL = "INTERNAL";
IfcSpaceTypeEnum.EXTERNAL = "EXTERNAL";
IfcSpaceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpaceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpatialZoneTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSpatialZoneTypeEnum.CONSTRUCTION = "CONSTRUCTION";
IfcSpatialZoneTypeEnum.FIRESAFETY = "FIRESAFETY";
IfcSpatialZoneTypeEnum.LIGHTING = "LIGHTING";
IfcSpatialZoneTypeEnum.OCCUPANCY = "OCCUPANCY";
IfcSpatialZoneTypeEnum.SECURITY = "SECURITY";
IfcSpatialZoneTypeEnum.THERMAL = "THERMAL";
IfcSpatialZoneTypeEnum.TRANSPORT = "TRANSPORT";
IfcSpatialZoneTypeEnum.VENTILATION = "VENTILATION";
IfcSpatialZoneTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpatialZoneTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStackTerminalTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStackTerminalTypeEnum.BIRDCAGE = "BIRDCAGE";
IfcStackTerminalTypeEnum.COWL = "COWL";
IfcStackTerminalTypeEnum.RAINWATERHOPPER = "RAINWATERHOPPER";
IfcStackTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcStackTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStairFlightTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStairFlightTypeEnum.STRAIGHT = "STRAIGHT";
IfcStairFlightTypeEnum.WINDER = "WINDER";
IfcStairFlightTypeEnum.SPIRAL = "SPIRAL";
IfcStairFlightTypeEnum.CURVED = "CURVED";
IfcStairFlightTypeEnum.FREEFORM = "FREEFORM";
IfcStairFlightTypeEnum.USERDEFINED = "USERDEFINED";
IfcStairFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStairTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStairTypeEnum.STRAIGHT_RUN_STAIR = "STRAIGHT_RUN_STAIR";
IfcStairTypeEnum.TWO_STRAIGHT_RUN_STAIR = "TWO_STRAIGHT_RUN_STAIR";
IfcStairTypeEnum.QUARTER_WINDING_STAIR = "QUARTER_WINDING_STAIR";
IfcStairTypeEnum.QUARTER_TURN_STAIR = "QUARTER_TURN_STAIR";
IfcStairTypeEnum.HALF_WINDING_STAIR = "HALF_WINDING_STAIR";
IfcStairTypeEnum.HALF_TURN_STAIR = "HALF_TURN_STAIR";
IfcStairTypeEnum.TWO_QUARTER_WINDING_STAIR = "TWO_QUARTER_WINDING_STAIR";
IfcStairTypeEnum.TWO_QUARTER_TURN_STAIR = "TWO_QUARTER_TURN_STAIR";
IfcStairTypeEnum.THREE_QUARTER_WINDING_STAIR = "THREE_QUARTER_WINDING_STAIR";
IfcStairTypeEnum.THREE_QUARTER_TURN_STAIR = "THREE_QUARTER_TURN_STAIR";
IfcStairTypeEnum.SPIRAL_STAIR = "SPIRAL_STAIR";
IfcStairTypeEnum.DOUBLE_RETURN_STAIR = "DOUBLE_RETURN_STAIR";
IfcStairTypeEnum.CURVED_RUN_STAIR = "CURVED_RUN_STAIR";
IfcStairTypeEnum.TWO_CURVED_RUN_STAIR = "TWO_CURVED_RUN_STAIR";
IfcStairTypeEnum.USERDEFINED = "USERDEFINED";
IfcStairTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStateEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStateEnum.READWRITE = "READWRITE";
IfcStateEnum.READONLY = "READONLY";
IfcStateEnum.LOCKED = "LOCKED";
IfcStateEnum.READWRITELOCKED = "READWRITELOCKED";
IfcStateEnum.READONLYLOCKED = "READONLYLOCKED";
var IfcStructuralCurveActivityTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStructuralCurveActivityTypeEnum.CONST = "CONST";
IfcStructuralCurveActivityTypeEnum.LINEAR = "LINEAR";
IfcStructuralCurveActivityTypeEnum.POLYGONAL = "POLYGONAL";
IfcStructuralCurveActivityTypeEnum.EQUIDISTANT = "EQUIDISTANT";
IfcStructuralCurveActivityTypeEnum.SINUS = "SINUS";
IfcStructuralCurveActivityTypeEnum.PARABOLA = "PARABOLA";
IfcStructuralCurveActivityTypeEnum.DISCRETE = "DISCRETE";
IfcStructuralCurveActivityTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralCurveActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralCurveMemberTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStructuralCurveMemberTypeEnum.RIGID_JOINED_MEMBER = "RIGID_JOINED_MEMBER";
IfcStructuralCurveMemberTypeEnum.PIN_JOINED_MEMBER = "PIN_JOINED_MEMBER";
IfcStructuralCurveMemberTypeEnum.CABLE = "CABLE";
IfcStructuralCurveMemberTypeEnum.TENSION_MEMBER = "TENSION_MEMBER";
IfcStructuralCurveMemberTypeEnum.COMPRESSION_MEMBER = "COMPRESSION_MEMBER";
IfcStructuralCurveMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralCurveMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralSurfaceActivityTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStructuralSurfaceActivityTypeEnum.CONST = "CONST";
IfcStructuralSurfaceActivityTypeEnum.BILINEAR = "BILINEAR";
IfcStructuralSurfaceActivityTypeEnum.DISCRETE = "DISCRETE";
IfcStructuralSurfaceActivityTypeEnum.ISOCONTOUR = "ISOCONTOUR";
IfcStructuralSurfaceActivityTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralSurfaceActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralSurfaceMemberTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcStructuralSurfaceMemberTypeEnum.BENDING_ELEMENT = "BENDING_ELEMENT";
IfcStructuralSurfaceMemberTypeEnum.MEMBRANE_ELEMENT = "MEMBRANE_ELEMENT";
IfcStructuralSurfaceMemberTypeEnum.SHELL = "SHELL";
IfcStructuralSurfaceMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralSurfaceMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSubContractResourceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSubContractResourceTypeEnum.PURCHASE = "PURCHASE";
IfcSubContractResourceTypeEnum.WORK = "WORK";
IfcSubContractResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSubContractResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSurfaceFeatureTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSurfaceFeatureTypeEnum.MARK = "MARK";
IfcSurfaceFeatureTypeEnum.TAG = "TAG";
IfcSurfaceFeatureTypeEnum.TREATMENT = "TREATMENT";
IfcSurfaceFeatureTypeEnum.DEFECT = "DEFECT";
IfcSurfaceFeatureTypeEnum.USERDEFINED = "USERDEFINED";
IfcSurfaceFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSurfaceSide = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSurfaceSide.POSITIVE = "POSITIVE";
IfcSurfaceSide.NEGATIVE = "NEGATIVE";
IfcSurfaceSide.BOTH = "BOTH";
var IfcSwitchingDeviceTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSwitchingDeviceTypeEnum.CONTACTOR = "CONTACTOR";
IfcSwitchingDeviceTypeEnum.DIMMERSWITCH = "DIMMERSWITCH";
IfcSwitchingDeviceTypeEnum.EMERGENCYSTOP = "EMERGENCYSTOP";
IfcSwitchingDeviceTypeEnum.KEYPAD = "KEYPAD";
IfcSwitchingDeviceTypeEnum.MOMENTARYSWITCH = "MOMENTARYSWITCH";
IfcSwitchingDeviceTypeEnum.SELECTORSWITCH = "SELECTORSWITCH";
IfcSwitchingDeviceTypeEnum.STARTER = "STARTER";
IfcSwitchingDeviceTypeEnum.SWITCHDISCONNECTOR = "SWITCHDISCONNECTOR";
IfcSwitchingDeviceTypeEnum.TOGGLESWITCH = "TOGGLESWITCH";
IfcSwitchingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSwitchingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSystemFurnitureElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcSystemFurnitureElementTypeEnum.PANEL = "PANEL";
IfcSystemFurnitureElementTypeEnum.WORKSURFACE = "WORKSURFACE";
IfcSystemFurnitureElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcSystemFurnitureElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTankTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTankTypeEnum.BASIN = "BASIN";
IfcTankTypeEnum.BREAKPRESSURE = "BREAKPRESSURE";
IfcTankTypeEnum.EXPANSION = "EXPANSION";
IfcTankTypeEnum.FEEDANDEXPANSION = "FEEDANDEXPANSION";
IfcTankTypeEnum.PRESSUREVESSEL = "PRESSUREVESSEL";
IfcTankTypeEnum.STORAGE = "STORAGE";
IfcTankTypeEnum.VESSEL = "VESSEL";
IfcTankTypeEnum.USERDEFINED = "USERDEFINED";
IfcTankTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTaskDurationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTaskDurationEnum.ELAPSEDTIME = "ELAPSEDTIME";
IfcTaskDurationEnum.WORKTIME = "WORKTIME";
IfcTaskDurationEnum.NOTDEFINED = "NOTDEFINED";
var IfcTaskTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTaskTypeEnum.ATTENDANCE = "ATTENDANCE";
IfcTaskTypeEnum.CONSTRUCTION = "CONSTRUCTION";
IfcTaskTypeEnum.DEMOLITION = "DEMOLITION";
IfcTaskTypeEnum.DISMANTLE = "DISMANTLE";
IfcTaskTypeEnum.DISPOSAL = "DISPOSAL";
IfcTaskTypeEnum.INSTALLATION = "INSTALLATION";
IfcTaskTypeEnum.LOGISTIC = "LOGISTIC";
IfcTaskTypeEnum.MAINTENANCE = "MAINTENANCE";
IfcTaskTypeEnum.MOVE = "MOVE";
IfcTaskTypeEnum.OPERATION = "OPERATION";
IfcTaskTypeEnum.REMOVAL = "REMOVAL";
IfcTaskTypeEnum.RENOVATION = "RENOVATION";
IfcTaskTypeEnum.USERDEFINED = "USERDEFINED";
IfcTaskTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonAnchorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTendonAnchorTypeEnum.COUPLER = "COUPLER";
IfcTendonAnchorTypeEnum.FIXED_END = "FIXED_END";
IfcTendonAnchorTypeEnum.TENSIONING_END = "TENSIONING_END";
IfcTendonAnchorTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonAnchorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonConduitTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTendonConduitTypeEnum.DUCT = "DUCT";
IfcTendonConduitTypeEnum.COUPLER = "COUPLER";
IfcTendonConduitTypeEnum.GROUTING_DUCT = "GROUTING_DUCT";
IfcTendonConduitTypeEnum.TRUMPET = "TRUMPET";
IfcTendonConduitTypeEnum.DIABOLO = "DIABOLO";
IfcTendonConduitTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonConduitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTendonTypeEnum.BAR = "BAR";
IfcTendonTypeEnum.COATED = "COATED";
IfcTendonTypeEnum.STRAND = "STRAND";
IfcTendonTypeEnum.WIRE = "WIRE";
IfcTendonTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTextPath = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTextPath.LEFT = "LEFT";
IfcTextPath.RIGHT = "RIGHT";
IfcTextPath.UP = "UP";
IfcTextPath.DOWN = "DOWN";
var IfcTimeSeriesDataTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTimeSeriesDataTypeEnum.CONTINUOUS = "CONTINUOUS";
IfcTimeSeriesDataTypeEnum.DISCRETE = "DISCRETE";
IfcTimeSeriesDataTypeEnum.DISCRETEBINARY = "DISCRETEBINARY";
IfcTimeSeriesDataTypeEnum.PIECEWISEBINARY = "PIECEWISEBINARY";
IfcTimeSeriesDataTypeEnum.PIECEWISECONSTANT = "PIECEWISECONSTANT";
IfcTimeSeriesDataTypeEnum.PIECEWISECONTINUOUS = "PIECEWISECONTINUOUS";
IfcTimeSeriesDataTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTransformerTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTransformerTypeEnum.CURRENT = "CURRENT";
IfcTransformerTypeEnum.FREQUENCY = "FREQUENCY";
IfcTransformerTypeEnum.INVERTER = "INVERTER";
IfcTransformerTypeEnum.RECTIFIER = "RECTIFIER";
IfcTransformerTypeEnum.VOLTAGE = "VOLTAGE";
IfcTransformerTypeEnum.USERDEFINED = "USERDEFINED";
IfcTransformerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTransitionCode = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTransitionCode.DISCONTINUOUS = "DISCONTINUOUS";
IfcTransitionCode.CONTINUOUS = "CONTINUOUS";
IfcTransitionCode.CONTSAMEGRADIENT = "CONTSAMEGRADIENT";
IfcTransitionCode.CONTSAMEGRADIENTSAMECURVATURE = "CONTSAMEGRADIENTSAMECURVATURE";
var IfcTransitionCurveType = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTransitionCurveType.BIQUADRATICPARABOLA = "BIQUADRATICPARABOLA";
IfcTransitionCurveType.BLOSSCURVE = "BLOSSCURVE";
IfcTransitionCurveType.CLOTHOIDCURVE = "CLOTHOIDCURVE";
IfcTransitionCurveType.COSINECURVE = "COSINECURVE";
IfcTransitionCurveType.CUBICPARABOLA = "CUBICPARABOLA";
IfcTransitionCurveType.SINECURVE = "SINECURVE";
var IfcTransportElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTransportElementTypeEnum.ELEVATOR = "ELEVATOR";
IfcTransportElementTypeEnum.ESCALATOR = "ESCALATOR";
IfcTransportElementTypeEnum.MOVINGWALKWAY = "MOVINGWALKWAY";
IfcTransportElementTypeEnum.CRANEWAY = "CRANEWAY";
IfcTransportElementTypeEnum.LIFTINGGEAR = "LIFTINGGEAR";
IfcTransportElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcTransportElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTrimmingPreference = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTrimmingPreference.CARTESIAN = "CARTESIAN";
IfcTrimmingPreference.PARAMETER = "PARAMETER";
IfcTrimmingPreference.UNSPECIFIED = "UNSPECIFIED";
var IfcTubeBundleTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcTubeBundleTypeEnum.FINNED = "FINNED";
IfcTubeBundleTypeEnum.USERDEFINED = "USERDEFINED";
IfcTubeBundleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcUnitEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcUnitEnum.ABSORBEDDOSEUNIT = "ABSORBEDDOSEUNIT";
IfcUnitEnum.AMOUNTOFSUBSTANCEUNIT = "AMOUNTOFSUBSTANCEUNIT";
IfcUnitEnum.AREAUNIT = "AREAUNIT";
IfcUnitEnum.DOSEEQUIVALENTUNIT = "DOSEEQUIVALENTUNIT";
IfcUnitEnum.ELECTRICCAPACITANCEUNIT = "ELECTRICCAPACITANCEUNIT";
IfcUnitEnum.ELECTRICCHARGEUNIT = "ELECTRICCHARGEUNIT";
IfcUnitEnum.ELECTRICCONDUCTANCEUNIT = "ELECTRICCONDUCTANCEUNIT";
IfcUnitEnum.ELECTRICCURRENTUNIT = "ELECTRICCURRENTUNIT";
IfcUnitEnum.ELECTRICRESISTANCEUNIT = "ELECTRICRESISTANCEUNIT";
IfcUnitEnum.ELECTRICVOLTAGEUNIT = "ELECTRICVOLTAGEUNIT";
IfcUnitEnum.ENERGYUNIT = "ENERGYUNIT";
IfcUnitEnum.FORCEUNIT = "FORCEUNIT";
IfcUnitEnum.FREQUENCYUNIT = "FREQUENCYUNIT";
IfcUnitEnum.ILLUMINANCEUNIT = "ILLUMINANCEUNIT";
IfcUnitEnum.INDUCTANCEUNIT = "INDUCTANCEUNIT";
IfcUnitEnum.LENGTHUNIT = "LENGTHUNIT";
IfcUnitEnum.LUMINOUSFLUXUNIT = "LUMINOUSFLUXUNIT";
IfcUnitEnum.LUMINOUSINTENSITYUNIT = "LUMINOUSINTENSITYUNIT";
IfcUnitEnum.MAGNETICFLUXDENSITYUNIT = "MAGNETICFLUXDENSITYUNIT";
IfcUnitEnum.MAGNETICFLUXUNIT = "MAGNETICFLUXUNIT";
IfcUnitEnum.MASSUNIT = "MASSUNIT";
IfcUnitEnum.PLANEANGLEUNIT = "PLANEANGLEUNIT";
IfcUnitEnum.POWERUNIT = "POWERUNIT";
IfcUnitEnum.PRESSUREUNIT = "PRESSUREUNIT";
IfcUnitEnum.RADIOACTIVITYUNIT = "RADIOACTIVITYUNIT";
IfcUnitEnum.SOLIDANGLEUNIT = "SOLIDANGLEUNIT";
IfcUnitEnum.THERMODYNAMICTEMPERATUREUNIT = "THERMODYNAMICTEMPERATUREUNIT";
IfcUnitEnum.TIMEUNIT = "TIMEUNIT";
IfcUnitEnum.VOLUMEUNIT = "VOLUMEUNIT";
IfcUnitEnum.USERDEFINED = "USERDEFINED";
var IfcUnitaryControlElementTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcUnitaryControlElementTypeEnum.ALARMPANEL = "ALARMPANEL";
IfcUnitaryControlElementTypeEnum.CONTROLPANEL = "CONTROLPANEL";
IfcUnitaryControlElementTypeEnum.GASDETECTIONPANEL = "GASDETECTIONPANEL";
IfcUnitaryControlElementTypeEnum.INDICATORPANEL = "INDICATORPANEL";
IfcUnitaryControlElementTypeEnum.MIMICPANEL = "MIMICPANEL";
IfcUnitaryControlElementTypeEnum.HUMIDISTAT = "HUMIDISTAT";
IfcUnitaryControlElementTypeEnum.THERMOSTAT = "THERMOSTAT";
IfcUnitaryControlElementTypeEnum.WEATHERSTATION = "WEATHERSTATION";
IfcUnitaryControlElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcUnitaryControlElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcUnitaryEquipmentTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcUnitaryEquipmentTypeEnum.AIRHANDLER = "AIRHANDLER";
IfcUnitaryEquipmentTypeEnum.AIRCONDITIONINGUNIT = "AIRCONDITIONINGUNIT";
IfcUnitaryEquipmentTypeEnum.DEHUMIDIFIER = "DEHUMIDIFIER";
IfcUnitaryEquipmentTypeEnum.SPLITSYSTEM = "SPLITSYSTEM";
IfcUnitaryEquipmentTypeEnum.ROOFTOPUNIT = "ROOFTOPUNIT";
IfcUnitaryEquipmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcUnitaryEquipmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcValveTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcValveTypeEnum.AIRRELEASE = "AIRRELEASE";
IfcValveTypeEnum.ANTIVACUUM = "ANTIVACUUM";
IfcValveTypeEnum.CHANGEOVER = "CHANGEOVER";
IfcValveTypeEnum.CHECK = "CHECK";
IfcValveTypeEnum.COMMISSIONING = "COMMISSIONING";
IfcValveTypeEnum.DIVERTING = "DIVERTING";
IfcValveTypeEnum.DRAWOFFCOCK = "DRAWOFFCOCK";
IfcValveTypeEnum.DOUBLECHECK = "DOUBLECHECK";
IfcValveTypeEnum.DOUBLEREGULATING = "DOUBLEREGULATING";
IfcValveTypeEnum.FAUCET = "FAUCET";
IfcValveTypeEnum.FLUSHING = "FLUSHING";
IfcValveTypeEnum.GASCOCK = "GASCOCK";
IfcValveTypeEnum.GASTAP = "GASTAP";
IfcValveTypeEnum.ISOLATING = "ISOLATING";
IfcValveTypeEnum.MIXING = "MIXING";
IfcValveTypeEnum.PRESSUREREDUCING = "PRESSUREREDUCING";
IfcValveTypeEnum.PRESSURERELIEF = "PRESSURERELIEF";
IfcValveTypeEnum.REGULATING = "REGULATING";
IfcValveTypeEnum.SAFETYCUTOFF = "SAFETYCUTOFF";
IfcValveTypeEnum.STEAMTRAP = "STEAMTRAP";
IfcValveTypeEnum.STOPCOCK = "STOPCOCK";
IfcValveTypeEnum.USERDEFINED = "USERDEFINED";
IfcValveTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVibrationDamperTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcVibrationDamperTypeEnum.BENDING_YIELD = "BENDING_YIELD";
IfcVibrationDamperTypeEnum.SHEAR_YIELD = "SHEAR_YIELD";
IfcVibrationDamperTypeEnum.AXIAL_YIELD = "AXIAL_YIELD";
IfcVibrationDamperTypeEnum.FRICTION = "FRICTION";
IfcVibrationDamperTypeEnum.VISCOUS = "VISCOUS";
IfcVibrationDamperTypeEnum.RUBBER = "RUBBER";
IfcVibrationDamperTypeEnum.USERDEFINED = "USERDEFINED";
IfcVibrationDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVibrationIsolatorTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcVibrationIsolatorTypeEnum.COMPRESSION = "COMPRESSION";
IfcVibrationIsolatorTypeEnum.SPRING = "SPRING";
IfcVibrationIsolatorTypeEnum.BASE = "BASE";
IfcVibrationIsolatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcVibrationIsolatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVoidingFeatureTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcVoidingFeatureTypeEnum.CUTOUT = "CUTOUT";
IfcVoidingFeatureTypeEnum.NOTCH = "NOTCH";
IfcVoidingFeatureTypeEnum.HOLE = "HOLE";
IfcVoidingFeatureTypeEnum.MITER = "MITER";
IfcVoidingFeatureTypeEnum.CHAMFER = "CHAMFER";
IfcVoidingFeatureTypeEnum.EDGE = "EDGE";
IfcVoidingFeatureTypeEnum.USERDEFINED = "USERDEFINED";
IfcVoidingFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWallTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWallTypeEnum.MOVABLE = "MOVABLE";
IfcWallTypeEnum.PARAPET = "PARAPET";
IfcWallTypeEnum.PARTITIONING = "PARTITIONING";
IfcWallTypeEnum.PLUMBINGWALL = "PLUMBINGWALL";
IfcWallTypeEnum.SHEAR = "SHEAR";
IfcWallTypeEnum.SOLIDWALL = "SOLIDWALL";
IfcWallTypeEnum.STANDARD = "STANDARD";
IfcWallTypeEnum.POLYGONAL = "POLYGONAL";
IfcWallTypeEnum.ELEMENTEDWALL = "ELEMENTEDWALL";
IfcWallTypeEnum.RETAININGWALL = "RETAININGWALL";
IfcWallTypeEnum.USERDEFINED = "USERDEFINED";
IfcWallTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWasteTerminalTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWasteTerminalTypeEnum.FLOORTRAP = "FLOORTRAP";
IfcWasteTerminalTypeEnum.FLOORWASTE = "FLOORWASTE";
IfcWasteTerminalTypeEnum.GULLYSUMP = "GULLYSUMP";
IfcWasteTerminalTypeEnum.GULLYTRAP = "GULLYTRAP";
IfcWasteTerminalTypeEnum.ROOFDRAIN = "ROOFDRAIN";
IfcWasteTerminalTypeEnum.WASTEDISPOSALUNIT = "WASTEDISPOSALUNIT";
IfcWasteTerminalTypeEnum.WASTETRAP = "WASTETRAP";
IfcWasteTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcWasteTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowPanelOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowPanelOperationEnum.SIDEHUNGRIGHTHAND = "SIDEHUNGRIGHTHAND";
IfcWindowPanelOperationEnum.SIDEHUNGLEFTHAND = "SIDEHUNGLEFTHAND";
IfcWindowPanelOperationEnum.TILTANDTURNRIGHTHAND = "TILTANDTURNRIGHTHAND";
IfcWindowPanelOperationEnum.TILTANDTURNLEFTHAND = "TILTANDTURNLEFTHAND";
IfcWindowPanelOperationEnum.TOPHUNG = "TOPHUNG";
IfcWindowPanelOperationEnum.BOTTOMHUNG = "BOTTOMHUNG";
IfcWindowPanelOperationEnum.PIVOTHORIZONTAL = "PIVOTHORIZONTAL";
IfcWindowPanelOperationEnum.PIVOTVERTICAL = "PIVOTVERTICAL";
IfcWindowPanelOperationEnum.SLIDINGHORIZONTAL = "SLIDINGHORIZONTAL";
IfcWindowPanelOperationEnum.SLIDINGVERTICAL = "SLIDINGVERTICAL";
IfcWindowPanelOperationEnum.REMOVABLECASEMENT = "REMOVABLECASEMENT";
IfcWindowPanelOperationEnum.FIXEDCASEMENT = "FIXEDCASEMENT";
IfcWindowPanelOperationEnum.OTHEROPERATION = "OTHEROPERATION";
IfcWindowPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowPanelPositionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowPanelPositionEnum.LEFT = "LEFT";
IfcWindowPanelPositionEnum.MIDDLE = "MIDDLE";
IfcWindowPanelPositionEnum.RIGHT = "RIGHT";
IfcWindowPanelPositionEnum.BOTTOM = "BOTTOM";
IfcWindowPanelPositionEnum.TOP = "TOP";
IfcWindowPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowStyleConstructionEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
IfcWindowStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
IfcWindowStyleConstructionEnum.STEEL = "STEEL";
IfcWindowStyleConstructionEnum.WOOD = "WOOD";
IfcWindowStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
IfcWindowStyleConstructionEnum.PLASTIC = "PLASTIC";
IfcWindowStyleConstructionEnum.OTHER_CONSTRUCTION = "OTHER_CONSTRUCTION";
IfcWindowStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowStyleOperationEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowStyleOperationEnum.SINGLE_PANEL = "SINGLE_PANEL";
IfcWindowStyleOperationEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
IfcWindowStyleOperationEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
IfcWindowStyleOperationEnum.USERDEFINED = "USERDEFINED";
IfcWindowStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowTypeEnum.WINDOW = "WINDOW";
IfcWindowTypeEnum.SKYLIGHT = "SKYLIGHT";
IfcWindowTypeEnum.LIGHTDOME = "LIGHTDOME";
IfcWindowTypeEnum.USERDEFINED = "USERDEFINED";
IfcWindowTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowTypePartitioningEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWindowTypePartitioningEnum.SINGLE_PANEL = "SINGLE_PANEL";
IfcWindowTypePartitioningEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
IfcWindowTypePartitioningEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
IfcWindowTypePartitioningEnum.USERDEFINED = "USERDEFINED";
IfcWindowTypePartitioningEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkCalendarTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWorkCalendarTypeEnum.FIRSTSHIFT = "FIRSTSHIFT";
IfcWorkCalendarTypeEnum.SECONDSHIFT = "SECONDSHIFT";
IfcWorkCalendarTypeEnum.THIRDSHIFT = "THIRDSHIFT";
IfcWorkCalendarTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkCalendarTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkPlanTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWorkPlanTypeEnum.ACTUAL = "ACTUAL";
IfcWorkPlanTypeEnum.BASELINE = "BASELINE";
IfcWorkPlanTypeEnum.PLANNED = "PLANNED";
IfcWorkPlanTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkPlanTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkScheduleTypeEnum = class {
  constructor(v) {
    this.value = v;
  }
};
IfcWorkScheduleTypeEnum.ACTUAL = "ACTUAL";
IfcWorkScheduleTypeEnum.BASELINE = "BASELINE";
IfcWorkScheduleTypeEnum.PLANNED = "PLANNED";
IfcWorkScheduleTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionRequest = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
};
var IfcActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheActor);
    ;
    return args;
  }
};
var IfcActorRole = class {
  constructor(expressID, type, Role, UserDefinedRole, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Role = Role;
    this.UserDefinedRole = UserDefinedRole;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Role = tape[ptr++];
    let UserDefinedRole = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Role);
    ;
    args.push(this.UserDefinedRole);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcActuator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcActuatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    return args;
  }
};
var IfcAdvancedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcAdvancedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
};
var IfcAdvancedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    args.push(this.Voids);
    ;
    return args;
  }
};
var IfcAdvancedFace = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    args.push(this.FaceSurface);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
};
var IfcAirTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAirTerminalBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAirTerminalBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAirTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAirToAirHeatRecovery = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAirToAirHeatRecoveryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAlarm = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAlarmType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAlignment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Axis);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAlignment2DHorizontal = class {
  constructor(expressID, type, StartDistAlong, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.StartDistAlong = StartDistAlong;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartDistAlong = tape[ptr++];
    let Segments = tape[ptr++];
    return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.StartDistAlong);
    ;
    args.push(this.Segments);
    ;
    return args;
  }
};
var IfcAlignment2DHorizontalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.CurveGeometry = CurveGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let CurveGeometry = tape[ptr++];
    return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.CurveGeometry);
    ;
    return args;
  }
};
var IfcAlignment2DSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    return args;
  }
};
var IfcAlignment2DVerSegCircularArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.Radius = Radius;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let Radius = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    args.push(this.Radius);
    ;
    args.push(this.IsConvex);
    ;
    return args;
  }
};
var IfcAlignment2DVerSegLine = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    return args;
  }
};
var IfcAlignment2DVerSegParabolicArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.ParabolaConstant = ParabolaConstant;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let ParabolaConstant = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    args.push(this.ParabolaConstant);
    ;
    args.push(this.IsConvex);
    ;
    return args;
  }
};
var IfcAlignment2DVertical = class {
  constructor(expressID, type, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    return new IfcAlignment2DVertical(expressID, type, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    return args;
  }
};
var IfcAlignment2DVerticalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    return args;
  }
};
var IfcAlignmentCurve = class {
  constructor(expressID, type, Horizontal, Vertical, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.Horizontal = Horizontal;
    this.Vertical = Vertical;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Horizontal = tape[ptr++];
    let Vertical = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.Horizontal);
    ;
    args.push(this.Vertical);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcAnnotation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcAnnotationFillArea = class {
  constructor(expressID, type, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.OuterBoundary);
    ;
    args.push(this.InnerBoundaries);
    ;
    return args;
  }
};
var IfcApplication = class {
  constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
    this.expressID = expressID;
    this.type = type;
    this.ApplicationDeveloper = ApplicationDeveloper;
    this.Version = Version;
    this.ApplicationFullName = ApplicationFullName;
    this.ApplicationIdentifier = ApplicationIdentifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ApplicationDeveloper = tape[ptr++];
    let Version = tape[ptr++];
    let ApplicationFullName = tape[ptr++];
    let ApplicationIdentifier = tape[ptr++];
    return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
  }
  ToTape() {
    let args = [];
    args.push(this.ApplicationDeveloper);
    ;
    args.push(this.Version);
    ;
    args.push(this.ApplicationFullName);
    ;
    args.push(this.ApplicationIdentifier);
    ;
    return args;
  }
};
var IfcAppliedValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AppliedValue);
    ;
    args.push(this.UnitBasis);
    ;
    args.push(this.ApplicableDate);
    ;
    args.push(this.FixedUntilDate);
    ;
    args.push(this.Category);
    ;
    args.push(this.Condition);
    ;
    args.push(this.ArithmeticOperator);
    ;
    args.push(this.Components);
    ;
    return args;
  }
};
var IfcApproval = class {
  constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.TimeOfApproval = TimeOfApproval;
    this.Status = Status;
    this.Level = Level;
    this.Qualifier = Qualifier;
    this.RequestingApproval = RequestingApproval;
    this.GivingApproval = GivingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TimeOfApproval = tape[ptr++];
    let Status = tape[ptr++];
    let Level = tape[ptr++];
    let Qualifier = tape[ptr++];
    let RequestingApproval = tape[ptr++];
    let GivingApproval = tape[ptr++];
    return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TimeOfApproval);
    ;
    args.push(this.Status);
    ;
    args.push(this.Level);
    ;
    args.push(this.Qualifier);
    ;
    args.push(this.RequestingApproval);
    ;
    args.push(this.GivingApproval);
    ;
    return args;
  }
};
var IfcApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingApproval = RelatingApproval;
    this.RelatedApprovals = RelatedApprovals;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    let RelatedApprovals = tape[ptr++];
    return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingApproval);
    ;
    args.push(this.RelatedApprovals);
    ;
    return args;
  }
};
var IfcArbitraryClosedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.OuterCurve);
    ;
    return args;
  }
};
var IfcArbitraryOpenProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve2) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve2 = tape[ptr++];
    return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve2);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Curve);
    ;
    return args;
  }
};
var IfcArbitraryProfileDefWithVoids = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
    this.InnerCurves = InnerCurves;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    let InnerCurves = tape[ptr++];
    return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.OuterCurve);
    ;
    args.push(this.InnerCurves);
    ;
    return args;
  }
};
var IfcAsset = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.OriginalValue = OriginalValue;
    this.CurrentValue = CurrentValue;
    this.TotalReplacementCost = TotalReplacementCost;
    this.Owner = Owner;
    this.User = User;
    this.ResponsiblePerson = ResponsiblePerson;
    this.IncorporationDate = IncorporationDate;
    this.DepreciatedValue = DepreciatedValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let OriginalValue = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let TotalReplacementCost = tape[ptr++];
    let Owner = tape[ptr++];
    let User = tape[ptr++];
    let ResponsiblePerson = tape[ptr++];
    let IncorporationDate = tape[ptr++];
    let DepreciatedValue = tape[ptr++];
    return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.OriginalValue);
    ;
    args.push(this.CurrentValue);
    ;
    args.push(this.TotalReplacementCost);
    ;
    args.push(this.Owner);
    ;
    args.push(this.User);
    ;
    args.push(this.ResponsiblePerson);
    ;
    args.push(this.IncorporationDate);
    ;
    args.push(this.DepreciatedValue);
    ;
    return args;
  }
};
var IfcAsymmetricIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomFlangeWidth = BottomFlangeWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.BottomFlangeThickness = BottomFlangeThickness;
    this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
    this.TopFlangeWidth = TopFlangeWidth;
    this.TopFlangeThickness = TopFlangeThickness;
    this.TopFlangeFilletRadius = TopFlangeFilletRadius;
    this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
    this.BottomFlangeSlope = BottomFlangeSlope;
    this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
    this.TopFlangeSlope = TopFlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomFlangeWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let BottomFlangeThickness = tape[ptr++];
    let BottomFlangeFilletRadius = tape[ptr++];
    let TopFlangeWidth = tape[ptr++];
    let TopFlangeThickness = tape[ptr++];
    let TopFlangeFilletRadius = tape[ptr++];
    let BottomFlangeEdgeRadius = tape[ptr++];
    let BottomFlangeSlope = tape[ptr++];
    let TopFlangeEdgeRadius = tape[ptr++];
    let TopFlangeSlope = tape[ptr++];
    return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.BottomFlangeWidth);
    ;
    args.push(this.OverallDepth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.BottomFlangeThickness);
    ;
    args.push(this.BottomFlangeFilletRadius);
    ;
    args.push(this.TopFlangeWidth);
    ;
    args.push(this.TopFlangeThickness);
    ;
    args.push(this.TopFlangeFilletRadius);
    ;
    args.push(this.BottomFlangeEdgeRadius);
    ;
    args.push(this.BottomFlangeSlope);
    ;
    args.push(this.TopFlangeEdgeRadius);
    ;
    args.push(this.TopFlangeSlope);
    ;
    return args;
  }
};
var IfcAudioVisualAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAudioVisualApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcAxis1Placement = class {
  constructor(expressID, type, Location, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcAxis1Placement(expressID, type, Location, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
};
var IfcAxis2Placement2D = class {
  constructor(expressID, type, Location, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
};
var IfcAxis2Placement3D = class {
  constructor(expressID, type, Location, Axis, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Axis);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
};
var IfcBSplineCurve = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.KnotMultiplicities);
    ;
    args.push(this.Knots);
    ;
    args.push(this.KnotSpec);
    ;
    return args;
  }
};
var IfcBSplineSurface = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.UMultiplicities);
    ;
    args.push(this.VMultiplicities);
    ;
    args.push(this.UKnots);
    ;
    args.push(this.VKnots);
    ;
    args.push(this.KnotSpec);
    ;
    return args;
  }
};
var IfcBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBeamStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBearing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBearingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBlobTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.RasterFormat = RasterFormat;
    this.RasterCode = RasterCode;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let RasterFormat = tape[ptr++];
    let RasterCode = tape[ptr++];
    return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.RasterFormat);
    ;
    args.push(this.RasterCode);
    ;
    return args;
  }
};
var IfcBlock = class {
  constructor(expressID, type, Position, XLength, YLength, ZLength) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.ZLength = ZLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let ZLength = tape[ptr++];
    return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.XLength);
    ;
    args.push(this.YLength);
    ;
    args.push(this.ZLength);
    ;
    return args;
  }
};
var IfcBoiler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBoilerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBooleanClippingResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    ;
    args.push(this.FirstOperand);
    ;
    args.push(this.SecondOperand);
    ;
    return args;
  }
};
var IfcBooleanResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    ;
    args.push(this.FirstOperand);
    ;
    args.push(this.SecondOperand);
    ;
    return args;
  }
};
var IfcBoundaryCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcBoundaryCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcBoundaryEdgeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
    this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
    this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
    this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
    this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
    this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByLengthX = tape[ptr++];
    let TranslationalStiffnessByLengthY = tape[ptr++];
    let TranslationalStiffnessByLengthZ = tape[ptr++];
    let RotationalStiffnessByLengthX = tape[ptr++];
    let RotationalStiffnessByLengthY = tape[ptr++];
    let RotationalStiffnessByLengthZ = tape[ptr++];
    return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessByLengthX);
    ;
    args.push(this.TranslationalStiffnessByLengthY);
    ;
    args.push(this.TranslationalStiffnessByLengthZ);
    ;
    args.push(this.RotationalStiffnessByLengthX);
    ;
    args.push(this.RotationalStiffnessByLengthY);
    ;
    args.push(this.RotationalStiffnessByLengthZ);
    ;
    return args;
  }
};
var IfcBoundaryFaceCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
    this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
    this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByAreaX = tape[ptr++];
    let TranslationalStiffnessByAreaY = tape[ptr++];
    let TranslationalStiffnessByAreaZ = tape[ptr++];
    return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessByAreaX);
    ;
    args.push(this.TranslationalStiffnessByAreaY);
    ;
    args.push(this.TranslationalStiffnessByAreaZ);
    ;
    return args;
  }
};
var IfcBoundaryNodeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessX);
    ;
    args.push(this.TranslationalStiffnessY);
    ;
    args.push(this.TranslationalStiffnessZ);
    ;
    args.push(this.RotationalStiffnessX);
    ;
    args.push(this.RotationalStiffnessY);
    ;
    args.push(this.RotationalStiffnessZ);
    ;
    return args;
  }
};
var IfcBoundaryNodeConditionWarping = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
    this.WarpingStiffness = WarpingStiffness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    let WarpingStiffness = tape[ptr++];
    return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessX);
    ;
    args.push(this.TranslationalStiffnessY);
    ;
    args.push(this.TranslationalStiffnessZ);
    ;
    args.push(this.RotationalStiffnessX);
    ;
    args.push(this.RotationalStiffnessY);
    ;
    args.push(this.RotationalStiffnessZ);
    ;
    args.push(this.WarpingStiffness);
    ;
    return args;
  }
};
var IfcBoundedCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcBoundedCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundedSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcBoundedSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundingBox = class {
  constructor(expressID, type, Corner, XDim, YDim, ZDim) {
    this.expressID = expressID;
    this.type = type;
    this.Corner = Corner;
    this.XDim = XDim;
    this.YDim = YDim;
    this.ZDim = ZDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Corner = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let ZDim = tape[ptr++];
    return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
  }
  ToTape() {
    let args = [];
    args.push(this.Corner);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.ZDim);
    ;
    return args;
  }
};
var IfcBoxedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Enclosure = Enclosure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Enclosure = tape[ptr++];
    return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    args.push(this.Enclosure);
    ;
    return args;
  }
};
var IfcBridge = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBridgePart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBuilding = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.ElevationOfRefHeight = ElevationOfRefHeight;
    this.ElevationOfTerrain = ElevationOfTerrain;
    this.BuildingAddress = BuildingAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let ElevationOfRefHeight = tape[ptr++];
    let ElevationOfTerrain = tape[ptr++];
    let BuildingAddress = tape[ptr++];
    return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.ElevationOfRefHeight);
    ;
    args.push(this.ElevationOfTerrain);
    ;
    args.push(this.BuildingAddress);
    ;
    return args;
  }
};
var IfcBuildingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcBuildingElementPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBuildingElementPartType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBuildingElementProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBuildingElementProxyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBuildingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcBuildingStorey = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.Elevation = Elevation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let Elevation = tape[ptr++];
    return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.Elevation);
    ;
    return args;
  }
};
var IfcBuildingSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};
var IfcBurner = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcBurnerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.WallThickness = WallThickness;
    this.Girth = Girth;
    this.InternalFilletRadius = InternalFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let WallThickness = tape[ptr++];
    let Girth = tape[ptr++];
    let InternalFilletRadius = tape[ptr++];
    return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.Width);
    ;
    args.push(this.WallThickness);
    ;
    args.push(this.Girth);
    ;
    args.push(this.InternalFilletRadius);
    ;
    return args;
  }
};
var IfcCableCarrierFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableCarrierFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableCarrierSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableCarrierSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCableSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCaissonFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCaissonFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCartesianPoint = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcCartesianPoint(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
};
var IfcCartesianPointList = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcCartesianPointList(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCartesianPointList2D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    ;
    args.push(this.TagList);
    ;
    return args;
  }
};
var IfcCartesianPointList3D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    ;
    args.push(this.TagList);
    ;
    return args;
  }
};
var IfcCartesianTransformationOperator = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
};
var IfcCartesianTransformationOperator2D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
};
var IfcCartesianTransformationOperator2DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Scale2 = Scale2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Scale2 = tape[ptr++];
    return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Scale2);
    ;
    return args;
  }
};
var IfcCartesianTransformationOperator3D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Axis3);
    ;
    return args;
  }
};
var IfcCartesianTransformationOperator3DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
    this.Scale2 = Scale2;
    this.Scale3 = Scale3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    let Scale2 = tape[ptr++];
    let Scale3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Axis3);
    ;
    args.push(this.Scale2);
    ;
    args.push(this.Scale3);
    ;
    return args;
  }
};
var IfcCenterLineProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve2, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve2;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve2 = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve2, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Curve);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
};
var IfcChiller = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcChillerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcChimney = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcChimneyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCircle = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircle(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcCircleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
    this.WallThickness = WallThickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let WallThickness = tape[ptr++];
    return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.WallThickness);
    ;
    return args;
  }
};
var IfcCircleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcCircularArcSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.Radius = Radius;
    this.IsCCW = IsCCW;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let Radius = tape[ptr++];
    let IsCCW = tape[ptr++];
    return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    args.push(this.Radius);
    ;
    args.push(this.IsCCW);
    ;
    return args;
  }
};
var IfcCivilElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcCivilElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcClassification = class {
  constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
    this.expressID = expressID;
    this.type = type;
    this.Source = Source;
    this.Edition = Edition;
    this.EditionDate = EditionDate;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.ReferenceTokens = ReferenceTokens;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Source = tape[ptr++];
    let Edition = tape[ptr++];
    let EditionDate = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let ReferenceTokens = tape[ptr++];
    return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
  }
  ToTape() {
    let args = [];
    args.push(this.Source);
    ;
    args.push(this.Edition);
    ;
    args.push(this.EditionDate);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Location);
    ;
    args.push(this.ReferenceTokens);
    ;
    return args;
  }
};
var IfcClassificationReference = class {
  constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.ReferencedSource = ReferencedSource;
    this.Description = Description;
    this.Sort = Sort;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let ReferencedSource = tape[ptr++];
    let Description = tape[ptr++];
    let Sort = tape[ptr++];
    return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.ReferencedSource);
    ;
    args.push(this.Description);
    ;
    args.push(this.Sort);
    ;
    return args;
  }
};
var IfcClosedShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcClosedShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
};
var IfcCoil = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCoilType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcColourRgb = class {
  constructor(expressID, type, Name, Red, Green, Blue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Red = Red;
    this.Green = Green;
    this.Blue = Blue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Red = tape[ptr++];
    let Green = tape[ptr++];
    let Blue = tape[ptr++];
    return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Red);
    ;
    args.push(this.Green);
    ;
    args.push(this.Blue);
    ;
    return args;
  }
};
var IfcColourRgbList = class {
  constructor(expressID, type, ColourList) {
    this.expressID = expressID;
    this.type = type;
    this.ColourList = ColourList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ColourList = tape[ptr++];
    return new IfcColourRgbList(expressID, type, ColourList);
  }
  ToTape() {
    let args = [];
    args.push(this.ColourList);
    ;
    return args;
  }
};
var IfcColourSpecification = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcColourSpecification(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcColumn = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcColumnStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcColumnType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCommunicationsAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCommunicationsApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcComplexProperty = class {
  constructor(expressID, type, Name, Description, UsageName, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.HasProperties);
    ;
    return args;
  }
};
var IfcComplexPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.TemplateType = TemplateType;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let TemplateType = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.HasPropertyTemplates);
    ;
    return args;
  }
};
var IfcCompositeCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcCompositeCurveOnSurface = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    ;
    args.push(this.SameSense);
    ;
    args.push(this.ParentCurve);
    ;
    return args;
  }
};
var IfcCompositeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Profiles = Profiles;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Profiles = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Profiles);
    ;
    args.push(this.Label);
    ;
    return args;
  }
};
var IfcCompressor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCompressorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCondenser = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCondenserType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConic = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcConic(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcConnectedFaceSet = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcConnectedFaceSet(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
};
var IfcConnectionCurveGeometry = class {
  constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.CurveOnRelatingElement = CurveOnRelatingElement;
    this.CurveOnRelatedElement = CurveOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CurveOnRelatingElement = tape[ptr++];
    let CurveOnRelatedElement = tape[ptr++];
    return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.CurveOnRelatingElement);
    ;
    args.push(this.CurveOnRelatedElement);
    ;
    return args;
  }
};
var IfcConnectionGeometry = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcConnectionGeometry(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcConnectionPointEccentricity = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
    this.EccentricityInX = EccentricityInX;
    this.EccentricityInY = EccentricityInY;
    this.EccentricityInZ = EccentricityInZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    let EccentricityInX = tape[ptr++];
    let EccentricityInY = tape[ptr++];
    let EccentricityInZ = tape[ptr++];
    return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    ;
    args.push(this.PointOnRelatedElement);
    ;
    args.push(this.EccentricityInX);
    ;
    args.push(this.EccentricityInY);
    ;
    args.push(this.EccentricityInZ);
    ;
    return args;
  }
};
var IfcConnectionPointGeometry = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    ;
    args.push(this.PointOnRelatedElement);
    ;
    return args;
  }
};
var IfcConnectionSurfaceGeometry = class {
  constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
    this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceOnRelatingElement = tape[ptr++];
    let SurfaceOnRelatedElement = tape[ptr++];
    return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceOnRelatingElement);
    ;
    args.push(this.SurfaceOnRelatedElement);
    ;
    return args;
  }
};
var IfcConnectionVolumeGeometry = class {
  constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.VolumeOnRelatingElement = VolumeOnRelatingElement;
    this.VolumeOnRelatedElement = VolumeOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VolumeOnRelatingElement = tape[ptr++];
    let VolumeOnRelatedElement = tape[ptr++];
    return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.VolumeOnRelatingElement);
    ;
    args.push(this.VolumeOnRelatedElement);
    ;
    return args;
  }
};
var IfcConstraint = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    return args;
  }
};
var IfcConstructionEquipmentResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionEquipmentResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionMaterialResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionMaterialResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionProductResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionProductResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConstructionResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    return args;
  }
};
var IfcConstructionResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    return args;
  }
};
var IfcContext = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
};
var IfcContextDependentUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    return args;
  }
};
var IfcController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcConversionBasedUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    args.push(this.ConversionFactor);
    ;
    return args;
  }
};
var IfcConversionBasedUnitWithOffset = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
    this.ConversionOffset = ConversionOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    let ConversionOffset = tape[ptr++];
    return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    args.push(this.ConversionFactor);
    ;
    args.push(this.ConversionOffset);
    ;
    return args;
  }
};
var IfcCooledBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCooledBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCoolingTower = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCoolingTowerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCoordinateOperation = class {
  constructor(expressID, type, SourceCRS, TargetCRS) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    ;
    args.push(this.TargetCRS);
    ;
    return args;
  }
};
var IfcCoordinateReferenceSystem = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.GeodeticDatum);
    ;
    args.push(this.VerticalDatum);
    ;
    return args;
  }
};
var IfcCostItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.CostValues = CostValues;
    this.CostQuantities = CostQuantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let CostValues = tape[ptr++];
    let CostQuantities = tape[ptr++];
    return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.CostValues);
    ;
    args.push(this.CostQuantities);
    ;
    return args;
  }
};
var IfcCostSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.SubmittedOn = SubmittedOn;
    this.UpdateDate = UpdateDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let SubmittedOn = tape[ptr++];
    let UpdateDate = tape[ptr++];
    return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.SubmittedOn);
    ;
    args.push(this.UpdateDate);
    ;
    return args;
  }
};
var IfcCostValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AppliedValue);
    ;
    args.push(this.UnitBasis);
    ;
    args.push(this.ApplicableDate);
    ;
    args.push(this.FixedUntilDate);
    ;
    args.push(this.Category);
    ;
    args.push(this.Condition);
    ;
    args.push(this.ArithmeticOperator);
    ;
    args.push(this.Components);
    ;
    return args;
  }
};
var IfcCovering = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCoveringType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCrewResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCrewResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCsgPrimitive3D = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcCsgPrimitive3D(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcCsgSolid = class {
  constructor(expressID, type, TreeRootExpression) {
    this.expressID = expressID;
    this.type = type;
    this.TreeRootExpression = TreeRootExpression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TreeRootExpression = tape[ptr++];
    return new IfcCsgSolid(expressID, type, TreeRootExpression);
  }
  ToTape() {
    let args = [];
    args.push(this.TreeRootExpression);
    ;
    return args;
  }
};
var IfcCurrencyRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMonetaryUnit = RelatingMonetaryUnit;
    this.RelatedMonetaryUnit = RelatedMonetaryUnit;
    this.ExchangeRate = ExchangeRate;
    this.RateDateTime = RateDateTime;
    this.RateSource = RateSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMonetaryUnit = tape[ptr++];
    let RelatedMonetaryUnit = tape[ptr++];
    let ExchangeRate = tape[ptr++];
    let RateDateTime = tape[ptr++];
    let RateSource = tape[ptr++];
    return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingMonetaryUnit);
    ;
    args.push(this.RelatedMonetaryUnit);
    ;
    args.push(this.ExchangeRate);
    ;
    args.push(this.RateDateTime);
    ;
    args.push(this.RateSource);
    ;
    return args;
  }
};
var IfcCurtainWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCurtainWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCurveBoundedPlane = class {
  constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.OuterBoundary);
    ;
    args.push(this.InnerBoundaries);
    ;
    return args;
  }
};
var IfcCurveBoundedSurface = class {
  constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.Boundaries = Boundaries;
    this.ImplicitOuter = ImplicitOuter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let Boundaries = tape[ptr++];
    let ImplicitOuter = tape[ptr++];
    return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.Boundaries);
    ;
    args.push(this.ImplicitOuter);
    ;
    return args;
  }
};
var IfcCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    return args;
  }
};
var IfcCurveStyle = class {
  constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveWidth = CurveWidth;
    this.CurveColour = CurveColour;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveWidth = tape[ptr++];
    let CurveColour = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.CurveFont);
    ;
    args.push(this.CurveWidth);
    ;
    args.push(this.CurveColour);
    ;
    args.push(this.ModelOrDraughting);
    ;
    return args;
  }
};
var IfcCurveStyleFont = class {
  constructor(expressID, type, Name, PatternList) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PatternList = PatternList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PatternList = tape[ptr++];
    return new IfcCurveStyleFont(expressID, type, Name, PatternList);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.PatternList);
    ;
    return args;
  }
};
var IfcCurveStyleFontAndScaling = class {
  constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveFontScaling = CurveFontScaling;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveFontScaling = tape[ptr++];
    return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.CurveFont);
    ;
    args.push(this.CurveFontScaling);
    ;
    return args;
  }
};
var IfcCurveStyleFontPattern = class {
  constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.VisibleSegmentLength = VisibleSegmentLength;
    this.InvisibleSegmentLength = InvisibleSegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VisibleSegmentLength = tape[ptr++];
    let InvisibleSegmentLength = tape[ptr++];
    return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.VisibleSegmentLength);
    ;
    args.push(this.InvisibleSegmentLength);
    ;
    return args;
  }
};
var IfcCylindricalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCylindricalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDeepFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcDeepFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcDerivedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.ParentProfile);
    ;
    args.push(this.Operator);
    ;
    args.push(this.Label);
    ;
    return args;
  }
};
var IfcDerivedUnit = class {
  constructor(expressID, type, Elements, UnitType, UserDefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
    this.UnitType = UnitType;
    this.UserDefinedType = UserDefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    let UnitType = tape[ptr++];
    let UserDefinedType = tape[ptr++];
    return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.UserDefinedType);
    ;
    return args;
  }
};
var IfcDerivedUnitElement = class {
  constructor(expressID, type, Unit, Exponent) {
    this.expressID = expressID;
    this.type = type;
    this.Unit = Unit;
    this.Exponent = Exponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Unit = tape[ptr++];
    let Exponent = tape[ptr++];
    return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
  }
  ToTape() {
    let args = [];
    args.push(this.Unit);
    ;
    args.push(this.Exponent);
    ;
    return args;
  }
};
var IfcDimensionalExponents = class {
  constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
    this.expressID = expressID;
    this.type = type;
    this.LengthExponent = LengthExponent;
    this.MassExponent = MassExponent;
    this.TimeExponent = TimeExponent;
    this.ElectricCurrentExponent = ElectricCurrentExponent;
    this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
    this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
    this.LuminousIntensityExponent = LuminousIntensityExponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LengthExponent = tape[ptr++];
    let MassExponent = tape[ptr++];
    let TimeExponent = tape[ptr++];
    let ElectricCurrentExponent = tape[ptr++];
    let ThermodynamicTemperatureExponent = tape[ptr++];
    let AmountOfSubstanceExponent = tape[ptr++];
    let LuminousIntensityExponent = tape[ptr++];
    return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
  }
  ToTape() {
    let args = [];
    args.push(this.LengthExponent);
    ;
    args.push(this.MassExponent);
    ;
    args.push(this.TimeExponent);
    ;
    args.push(this.ElectricCurrentExponent);
    ;
    args.push(this.ThermodynamicTemperatureExponent);
    ;
    args.push(this.AmountOfSubstanceExponent);
    ;
    args.push(this.LuminousIntensityExponent);
    ;
    return args;
  }
};
var IfcDirection = class {
  constructor(expressID, type, DirectionRatios) {
    this.expressID = expressID;
    this.type = type;
    this.DirectionRatios = DirectionRatios;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DirectionRatios = tape[ptr++];
    return new IfcDirection(expressID, type, DirectionRatios);
  }
  ToTape() {
    let args = [];
    args.push(this.DirectionRatios);
    ;
    return args;
  }
};
var IfcDiscreteAccessory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDiscreteAccessoryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDistanceExpression = class {
  constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
    this.expressID = expressID;
    this.type = type;
    this.DistanceAlong = DistanceAlong;
    this.OffsetLateral = OffsetLateral;
    this.OffsetVertical = OffsetVertical;
    this.OffsetLongitudinal = OffsetLongitudinal;
    this.AlongHorizontal = AlongHorizontal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DistanceAlong = tape[ptr++];
    let OffsetLateral = tape[ptr++];
    let OffsetVertical = tape[ptr++];
    let OffsetLongitudinal = tape[ptr++];
    let AlongHorizontal = tape[ptr++];
    return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
  }
  ToTape() {
    let args = [];
    args.push(this.DistanceAlong);
    ;
    args.push(this.OffsetLateral);
    ;
    args.push(this.OffsetVertical);
    ;
    args.push(this.OffsetLongitudinal);
    ;
    args.push(this.AlongHorizontal);
    ;
    return args;
  }
};
var IfcDistributionChamberElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDistributionChamberElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDistributionCircuit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDistributionControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcDistributionControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcDistributionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcDistributionElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcDistributionFlowElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcDistributionFlowElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcDistributionPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.FlowDirection = FlowDirection;
    this.PredefinedType = PredefinedType;
    this.SystemType = SystemType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let FlowDirection = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let SystemType = tape[ptr++];
    return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.FlowDirection);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.SystemType);
    ;
    return args;
  }
};
var IfcDistributionSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDocumentInformation = class {
  constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.Purpose = Purpose;
    this.IntendedUse = IntendedUse;
    this.Scope = Scope;
    this.Revision = Revision;
    this.DocumentOwner = DocumentOwner;
    this.Editors = Editors;
    this.CreationTime = CreationTime;
    this.LastRevisionTime = LastRevisionTime;
    this.ElectronicFormat = ElectronicFormat;
    this.ValidFrom = ValidFrom;
    this.ValidUntil = ValidUntil;
    this.Confidentiality = Confidentiality;
    this.Status = Status;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let Purpose = tape[ptr++];
    let IntendedUse = tape[ptr++];
    let Scope = tape[ptr++];
    let Revision = tape[ptr++];
    let DocumentOwner = tape[ptr++];
    let Editors = tape[ptr++];
    let CreationTime = tape[ptr++];
    let LastRevisionTime = tape[ptr++];
    let ElectronicFormat = tape[ptr++];
    let ValidFrom = tape[ptr++];
    let ValidUntil = tape[ptr++];
    let Confidentiality = tape[ptr++];
    let Status = tape[ptr++];
    return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Location);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.IntendedUse);
    ;
    args.push(this.Scope);
    ;
    args.push(this.Revision);
    ;
    args.push(this.DocumentOwner);
    ;
    args.push(this.Editors);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.LastRevisionTime);
    ;
    args.push(this.ElectronicFormat);
    ;
    args.push(this.ValidFrom);
    ;
    args.push(this.ValidUntil);
    ;
    args.push(this.Confidentiality);
    ;
    args.push(this.Status);
    ;
    return args;
  }
};
var IfcDocumentInformationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingDocument = RelatingDocument;
    this.RelatedDocuments = RelatedDocuments;
    this.RelationshipType = RelationshipType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    let RelatedDocuments = tape[ptr++];
    let RelationshipType = tape[ptr++];
    return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingDocument);
    ;
    args.push(this.RelatedDocuments);
    ;
    args.push(this.RelationshipType);
    ;
    return args;
  }
};
var IfcDocumentReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.ReferencedDocument = ReferencedDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ReferencedDocument = tape[ptr++];
    return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ReferencedDocument);
    ;
    return args;
  }
};
var IfcDoor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
};
var IfcDoorLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.ThresholdDepth = ThresholdDepth;
    this.ThresholdThickness = ThresholdThickness;
    this.TransomThickness = TransomThickness;
    this.TransomOffset = TransomOffset;
    this.LiningOffset = LiningOffset;
    this.ThresholdOffset = ThresholdOffset;
    this.CasingThickness = CasingThickness;
    this.CasingDepth = CasingDepth;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let ThresholdDepth = tape[ptr++];
    let ThresholdThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let TransomOffset = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let ThresholdOffset = tape[ptr++];
    let CasingThickness = tape[ptr++];
    let CasingDepth = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.LiningDepth);
    ;
    args.push(this.LiningThickness);
    ;
    args.push(this.ThresholdDepth);
    ;
    args.push(this.ThresholdThickness);
    ;
    args.push(this.TransomThickness);
    ;
    args.push(this.TransomOffset);
    ;
    args.push(this.LiningOffset);
    ;
    args.push(this.ThresholdOffset);
    ;
    args.push(this.CasingThickness);
    ;
    args.push(this.CasingDepth);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    args.push(this.LiningToPanelOffsetX);
    ;
    args.push(this.LiningToPanelOffsetY);
    ;
    return args;
  }
};
var IfcDoorPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.PanelDepth = PanelDepth;
    this.PanelOperation = PanelOperation;
    this.PanelWidth = PanelWidth;
    this.PanelPosition = PanelPosition;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let PanelDepth = tape[ptr++];
    let PanelOperation = tape[ptr++];
    let PanelWidth = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.PanelDepth);
    ;
    args.push(this.PanelOperation);
    ;
    args.push(this.PanelWidth);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
};
var IfcDoorStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
};
var IfcDoorStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.OperationType = OperationType;
    this.ConstructionType = ConstructionType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let OperationType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ConstructionType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.Sizeable);
    ;
    return args;
  }
};
var IfcDoorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
};
var IfcDraughtingPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcDraughtingPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcDuctFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDuctFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDuctSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDuctSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDuctSilencer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcDuctSilencerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    return args;
  }
};
var IfcEdgeCurve = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeGeometry = EdgeGeometry;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeGeometry = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.EdgeGeometry);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
};
var IfcEdgeLoop = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcEdgeLoop(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    ;
    return args;
  }
};
var IfcElectricAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricDistributionBoard = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricDistributionBoardType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricGenerator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricGeneratorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricMotor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricMotorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricTimeControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElectricTimeControlType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcElementAssembly = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.AssemblyPlace);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElementAssemblyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcElementComponent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcElementComponentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcElementQuantity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.MethodOfMeasurement = MethodOfMeasurement;
    this.Quantities = Quantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MethodOfMeasurement = tape[ptr++];
    let Quantities = tape[ptr++];
    return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MethodOfMeasurement);
    ;
    args.push(this.Quantities);
    ;
    return args;
  }
};
var IfcElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcElementarySurface = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcElementarySurface(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcEllipse = class {
  constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.SemiAxis1);
    ;
    args.push(this.SemiAxis2);
    ;
    return args;
  }
};
var IfcEllipseProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.SemiAxis1);
    ;
    args.push(this.SemiAxis2);
    ;
    return args;
  }
};
var IfcEnergyConversionDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcEnergyConversionDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcEngine = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEngineType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEvaporativeCooler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEvaporativeCoolerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEvaporator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEvaporatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcEvent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    this.EventOccurenceTime = EventOccurenceTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    let EventOccurenceTime = tape[ptr++];
    return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.EventTriggerType);
    ;
    args.push(this.UserDefinedEventTriggerType);
    ;
    args.push(this.EventOccurenceTime);
    ;
    return args;
  }
};
var IfcEventTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ActualDate = ActualDate;
    this.EarlyDate = EarlyDate;
    this.LateDate = LateDate;
    this.ScheduleDate = ScheduleDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ActualDate = tape[ptr++];
    let EarlyDate = tape[ptr++];
    let LateDate = tape[ptr++];
    let ScheduleDate = tape[ptr++];
    return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.ActualDate);
    ;
    args.push(this.EarlyDate);
    ;
    args.push(this.LateDate);
    ;
    args.push(this.ScheduleDate);
    ;
    return args;
  }
};
var IfcEventType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.EventTriggerType);
    ;
    args.push(this.UserDefinedEventTriggerType);
    ;
    return args;
  }
};
var IfcExtendedProperties = class {
  constructor(expressID, type, Name, Description, Properties) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties = tape[ptr++];
    return new IfcExtendedProperties(expressID, type, Name, Description, Properties);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    return args;
  }
};
var IfcExternalInformation = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcExternalInformation(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcExternalReference = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternalReference(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcExternalReferenceRelationship = class {
  constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingReference = RelatingReference;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingReference = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingReference);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    return args;
  }
};
var IfcExternalSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcExternalSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};
var IfcExternallyDefinedHatchStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcExternallyDefinedSurfaceStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcExternallyDefinedTextFont = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcExtrudedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    return args;
  }
};
var IfcExtrudedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    args.push(this.EndSweptArea);
    ;
    return args;
  }
};
var IfcFace = class {
  constructor(expressID, type, Bounds) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    return new IfcFace(expressID, type, Bounds);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    return args;
  }
};
var IfcFaceBasedSurfaceModel = class {
  constructor(expressID, type, FbsmFaces) {
    this.expressID = expressID;
    this.type = type;
    this.FbsmFaces = FbsmFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let FbsmFaces = tape[ptr++];
    return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.FbsmFaces);
    ;
    return args;
  }
};
var IfcFaceBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
};
var IfcFaceOuterBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
};
var IfcFaceSurface = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    args.push(this.FaceSurface);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
};
var IfcFacetedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcFacetedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
};
var IfcFacetedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    args.push(this.Voids);
    ;
    return args;
  }
};
var IfcFacility = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
};
var IfcFacilityPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
};
var IfcFailureConnectionCondition = class {
  constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TensionFailureX = TensionFailureX;
    this.TensionFailureY = TensionFailureY;
    this.TensionFailureZ = TensionFailureZ;
    this.CompressionFailureX = CompressionFailureX;
    this.CompressionFailureY = CompressionFailureY;
    this.CompressionFailureZ = CompressionFailureZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TensionFailureX = tape[ptr++];
    let TensionFailureY = tape[ptr++];
    let TensionFailureZ = tape[ptr++];
    let CompressionFailureX = tape[ptr++];
    let CompressionFailureY = tape[ptr++];
    let CompressionFailureZ = tape[ptr++];
    return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TensionFailureX);
    ;
    args.push(this.TensionFailureY);
    ;
    args.push(this.TensionFailureZ);
    ;
    args.push(this.CompressionFailureX);
    ;
    args.push(this.CompressionFailureY);
    ;
    args.push(this.CompressionFailureZ);
    ;
    return args;
  }
};
var IfcFan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFanType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFeatureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFeatureElementAddition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFeatureElementSubtraction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFillAreaStyle = class {
  constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FillStyles = FillStyles;
    this.ModelorDraughting = ModelorDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FillStyles = tape[ptr++];
    let ModelorDraughting = tape[ptr++];
    return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.FillStyles);
    ;
    args.push(this.ModelorDraughting);
    ;
    return args;
  }
};
var IfcFillAreaStyleHatching = class {
  constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
    this.expressID = expressID;
    this.type = type;
    this.HatchLineAppearance = HatchLineAppearance;
    this.StartOfNextHatchLine = StartOfNextHatchLine;
    this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
    this.PatternStart = PatternStart;
    this.HatchLineAngle = HatchLineAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let HatchLineAppearance = tape[ptr++];
    let StartOfNextHatchLine = tape[ptr++];
    let PointOfReferenceHatchLine = tape[ptr++];
    let PatternStart = tape[ptr++];
    let HatchLineAngle = tape[ptr++];
    return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.HatchLineAppearance);
    ;
    args.push(this.StartOfNextHatchLine);
    ;
    args.push(this.PointOfReferenceHatchLine);
    ;
    args.push(this.PatternStart);
    ;
    args.push(this.HatchLineAngle);
    ;
    return args;
  }
};
var IfcFillAreaStyleTiles = class {
  constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
    this.expressID = expressID;
    this.type = type;
    this.TilingPattern = TilingPattern;
    this.Tiles = Tiles;
    this.TilingScale = TilingScale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TilingPattern = tape[ptr++];
    let Tiles = tape[ptr++];
    let TilingScale = tape[ptr++];
    return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
  }
  ToTape() {
    let args = [];
    args.push(this.TilingPattern);
    ;
    args.push(this.Tiles);
    ;
    args.push(this.TilingScale);
    ;
    return args;
  }
};
var IfcFilter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFilterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFireSuppressionTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFireSuppressionTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFixedReferenceSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FixedReference = FixedReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FixedReference = tape[ptr++];
    return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Directrix);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.FixedReference);
    ;
    return args;
  }
};
var IfcFlowController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowInstrument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFlowInstrumentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFlowMeter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFlowMeterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFlowMovingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowMovingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFlowTreatmentDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFlowTreatmentDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFooting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFootingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFurnishingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcFurnishingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcFurniture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcFurnitureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.AssemblyPlace);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcGeographicElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcGeographicElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcGeometricCurveSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricCurveSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    return args;
  }
};
var IfcGeometricRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    args.push(this.CoordinateSpaceDimension);
    ;
    args.push(this.Precision);
    ;
    args.push(this.WorldCoordinateSystem);
    ;
    args.push(this.TrueNorth);
    ;
    return args;
  }
};
var IfcGeometricRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcGeometricRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcGeometricRepresentationSubContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
    this.ParentContext = ParentContext;
    this.TargetScale = TargetScale;
    this.TargetView = TargetView;
    this.UserDefinedTargetView = UserDefinedTargetView;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    let ParentContext = tape[ptr++];
    let TargetScale = tape[ptr++];
    let TargetView = tape[ptr++];
    let UserDefinedTargetView = tape[ptr++];
    return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    args.push(this.CoordinateSpaceDimension);
    ;
    args.push(this.Precision);
    ;
    args.push(this.WorldCoordinateSystem);
    ;
    args.push(this.TrueNorth);
    ;
    args.push(this.ParentContext);
    ;
    args.push(this.TargetScale);
    ;
    args.push(this.TargetView);
    ;
    args.push(this.UserDefinedTargetView);
    ;
    return args;
  }
};
var IfcGeometricSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    return args;
  }
};
var IfcGrid = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.UAxes = UAxes;
    this.VAxes = VAxes;
    this.WAxes = WAxes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let UAxes = tape[ptr++];
    let VAxes = tape[ptr++];
    let WAxes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.UAxes);
    ;
    args.push(this.VAxes);
    ;
    args.push(this.WAxes);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcGridAxis = class {
  constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.AxisTag = AxisTag;
    this.AxisCurve = AxisCurve;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let AxisTag = tape[ptr++];
    let AxisCurve = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.AxisTag);
    ;
    args.push(this.AxisCurve);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
};
var IfcGridPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementLocation = PlacementLocation;
    this.PlacementRefDirection = PlacementRefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementLocation = tape[ptr++];
    let PlacementRefDirection = tape[ptr++];
    return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.PlacementLocation);
    ;
    args.push(this.PlacementRefDirection);
    ;
    return args;
  }
};
var IfcGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
};
var IfcHalfSpaceSolid = class {
  constructor(expressID, type, BaseSurface, AgreementFlag) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    return args;
  }
};
var IfcHeatExchanger = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcHeatExchangerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcHumidifier = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcHumidifierType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.OverallWidth = OverallWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.OverallDepth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.FlangeEdgeRadius);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
};
var IfcImageTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.URLReference = URLReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let URLReference = tape[ptr++];
    return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.URLReference);
    ;
    return args;
  }
};
var IfcIndexedColourMap = class {
  constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
    this.expressID = expressID;
    this.type = type;
    this.MappedTo = MappedTo;
    this.Opacity = Opacity;
    this.Colours = Colours;
    this.ColourIndex = ColourIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappedTo = tape[ptr++];
    let Opacity = tape[ptr++];
    let Colours = tape[ptr++];
    let ColourIndex = tape[ptr++];
    return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.MappedTo);
    ;
    args.push(this.Opacity);
    ;
    args.push(this.Colours);
    ;
    args.push(this.ColourIndex);
    ;
    return args;
  }
};
var IfcIndexedPolyCurve = class {
  constructor(expressID, type, Points2, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points2;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points2 = tape[ptr++];
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcIndexedPolyCurve(expressID, type, Points2, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    ;
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcIndexedPolygonalFace = class {
  constructor(expressID, type, CoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    ;
    return args;
  }
};
var IfcIndexedPolygonalFaceWithVoids = class {
  constructor(expressID, type, CoordIndex, InnerCoordIndices) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
    this.InnerCoordIndices = InnerCoordIndices;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    let InnerCoordIndices = tape[ptr++];
    return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    ;
    args.push(this.InnerCoordIndices);
    ;
    return args;
  }
};
var IfcIndexedTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.MappedTo);
    ;
    args.push(this.TexCoords);
    ;
    return args;
  }
};
var IfcIndexedTriangleTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
    this.TexCoordIndex = TexCoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    let TexCoordIndex = tape[ptr++];
    return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.MappedTo);
    ;
    args.push(this.TexCoords);
    ;
    args.push(this.TexCoordIndex);
    ;
    return args;
  }
};
var IfcInterceptor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcInterceptorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcIntersectionCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
};
var IfcInventory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.Jurisdiction = Jurisdiction;
    this.ResponsiblePersons = ResponsiblePersons;
    this.LastUpdateDate = LastUpdateDate;
    this.CurrentValue = CurrentValue;
    this.OriginalValue = OriginalValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Jurisdiction = tape[ptr++];
    let ResponsiblePersons = tape[ptr++];
    let LastUpdateDate = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let OriginalValue = tape[ptr++];
    return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Jurisdiction);
    ;
    args.push(this.ResponsiblePersons);
    ;
    args.push(this.LastUpdateDate);
    ;
    args.push(this.CurrentValue);
    ;
    args.push(this.OriginalValue);
    ;
    return args;
  }
};
var IfcIrregularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    args.push(this.Values);
    ;
    return args;
  }
};
var IfcIrregularTimeSeriesValue = class {
  constructor(expressID, type, TimeStamp, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.TimeStamp = TimeStamp;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TimeStamp = tape[ptr++];
    let ListValues = tape[ptr++];
    return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.TimeStamp);
    ;
    args.push(this.ListValues);
    ;
    return args;
  }
};
var IfcJunctionBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcJunctionBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.Thickness = Thickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.LegSlope = LegSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let Thickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let LegSlope = tape[ptr++];
    return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.Width);
    ;
    args.push(this.Thickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    args.push(this.LegSlope);
    ;
    return args;
  }
};
var IfcLaborResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLaborResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLagTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.LagValue = LagValue;
    this.DurationType = DurationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let LagValue = tape[ptr++];
    let DurationType = tape[ptr++];
    return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.LagValue);
    ;
    args.push(this.DurationType);
    ;
    return args;
  }
};
var IfcLamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLibraryInformation = class {
  constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Version = Version;
    this.Publisher = Publisher;
    this.VersionDate = VersionDate;
    this.Location = Location;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Version = tape[ptr++];
    let Publisher = tape[ptr++];
    let VersionDate = tape[ptr++];
    let Location = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Version);
    ;
    args.push(this.Publisher);
    ;
    args.push(this.VersionDate);
    ;
    args.push(this.Location);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcLibraryReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Language = Language;
    this.ReferencedLibrary = ReferencedLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Language = tape[ptr++];
    let ReferencedLibrary = tape[ptr++];
    return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Language);
    ;
    args.push(this.ReferencedLibrary);
    ;
    return args;
  }
};
var IfcLightDistributionData = class {
  constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
    this.expressID = expressID;
    this.type = type;
    this.MainPlaneAngle = MainPlaneAngle;
    this.SecondaryPlaneAngle = SecondaryPlaneAngle;
    this.LuminousIntensity = LuminousIntensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MainPlaneAngle = tape[ptr++];
    let SecondaryPlaneAngle = tape[ptr++];
    let LuminousIntensity = tape[ptr++];
    return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
  }
  ToTape() {
    let args = [];
    args.push(this.MainPlaneAngle);
    ;
    args.push(this.SecondaryPlaneAngle);
    ;
    args.push(this.LuminousIntensity);
    ;
    return args;
  }
};
var IfcLightFixture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLightFixtureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcLightIntensityDistribution = class {
  constructor(expressID, type, LightDistributionCurve, DistributionData) {
    this.expressID = expressID;
    this.type = type;
    this.LightDistributionCurve = LightDistributionCurve;
    this.DistributionData = DistributionData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LightDistributionCurve = tape[ptr++];
    let DistributionData = tape[ptr++];
    return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
  }
  ToTape() {
    let args = [];
    args.push(this.LightDistributionCurve);
    ;
    args.push(this.DistributionData);
    ;
    return args;
  }
};
var IfcLightSource = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    return args;
  }
};
var IfcLightSourceAmbient = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    return args;
  }
};
var IfcLightSourceDirectional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
};
var IfcLightSourceGoniometric = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.ColourAppearance = ColourAppearance;
    this.ColourTemperature = ColourTemperature;
    this.LuminousFlux = LuminousFlux;
    this.LightEmissionSource = LightEmissionSource;
    this.LightDistributionDataSource = LightDistributionDataSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let ColourAppearance = tape[ptr++];
    let ColourTemperature = tape[ptr++];
    let LuminousFlux = tape[ptr++];
    let LightEmissionSource = tape[ptr++];
    let LightDistributionDataSource = tape[ptr++];
    return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.ColourAppearance);
    ;
    args.push(this.ColourTemperature);
    ;
    args.push(this.LuminousFlux);
    ;
    args.push(this.LightEmissionSource);
    ;
    args.push(this.LightDistributionDataSource);
    ;
    return args;
  }
};
var IfcLightSourcePositional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.ConstantAttenuation);
    ;
    args.push(this.DistanceAttenuation);
    ;
    args.push(this.QuadricAttenuation);
    ;
    return args;
  }
};
var IfcLightSourceSpot = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
    this.Orientation = Orientation;
    this.ConcentrationExponent = ConcentrationExponent;
    this.SpreadAngle = SpreadAngle;
    this.BeamWidthAngle = BeamWidthAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    let Orientation = tape[ptr++];
    let ConcentrationExponent = tape[ptr++];
    let SpreadAngle = tape[ptr++];
    let BeamWidthAngle = tape[ptr++];
    return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.ConstantAttenuation);
    ;
    args.push(this.DistanceAttenuation);
    ;
    args.push(this.QuadricAttenuation);
    ;
    args.push(this.Orientation);
    ;
    args.push(this.ConcentrationExponent);
    ;
    args.push(this.SpreadAngle);
    ;
    args.push(this.BeamWidthAngle);
    ;
    return args;
  }
};
var IfcLine = class {
  constructor(expressID, type, Pnt, Dir) {
    this.expressID = expressID;
    this.type = type;
    this.Pnt = Pnt;
    this.Dir = Dir;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Pnt = tape[ptr++];
    let Dir = tape[ptr++];
    return new IfcLine(expressID, type, Pnt, Dir);
  }
  ToTape() {
    let args = [];
    args.push(this.Pnt);
    ;
    args.push(this.Dir);
    ;
    return args;
  }
};
var IfcLineSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    return args;
  }
};
var IfcLinearPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementMeasuredAlong = PlacementMeasuredAlong;
    this.Distance = Distance;
    this.Orientation = Orientation;
    this.CartesianPosition = CartesianPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementMeasuredAlong = tape[ptr++];
    let Distance = tape[ptr++];
    let Orientation = tape[ptr++];
    let CartesianPosition = tape[ptr++];
    return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.PlacementMeasuredAlong);
    ;
    args.push(this.Distance);
    ;
    args.push(this.Orientation);
    ;
    args.push(this.CartesianPosition);
    ;
    return args;
  }
};
var IfcLinearPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
};
var IfcLocalPlacement = class {
  constructor(expressID, type, PlacementRelTo, RelativePlacement) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.RelativePlacement = RelativePlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let RelativePlacement = tape[ptr++];
    return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.RelativePlacement);
    ;
    return args;
  }
};
var IfcLoop = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcLoop(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcManifoldSolidBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcManifoldSolidBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
};
var IfcMapConversion = class {
  constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
    this.Eastings = Eastings;
    this.Northings = Northings;
    this.OrthogonalHeight = OrthogonalHeight;
    this.XAxisAbscissa = XAxisAbscissa;
    this.XAxisOrdinate = XAxisOrdinate;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    let Eastings = tape[ptr++];
    let Northings = tape[ptr++];
    let OrthogonalHeight = tape[ptr++];
    let XAxisAbscissa = tape[ptr++];
    let XAxisOrdinate = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    ;
    args.push(this.TargetCRS);
    ;
    args.push(this.Eastings);
    ;
    args.push(this.Northings);
    ;
    args.push(this.OrthogonalHeight);
    ;
    args.push(this.XAxisAbscissa);
    ;
    args.push(this.XAxisOrdinate);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
};
var IfcMappedItem = class {
  constructor(expressID, type, MappingSource, MappingTarget) {
    this.expressID = expressID;
    this.type = type;
    this.MappingSource = MappingSource;
    this.MappingTarget = MappingTarget;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingSource = tape[ptr++];
    let MappingTarget = tape[ptr++];
    return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingSource);
    ;
    args.push(this.MappingTarget);
    ;
    return args;
  }
};
var IfcMaterial = class {
  constructor(expressID, type, Name, Description, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterial(expressID, type, Name, Description, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    return args;
  }
};
var IfcMaterialClassificationRelationship = class {
  constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialClassifications = MaterialClassifications;
    this.ClassifiedMaterial = ClassifiedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialClassifications = tape[ptr++];
    let ClassifiedMaterial = tape[ptr++];
    return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialClassifications);
    ;
    args.push(this.ClassifiedMaterial);
    ;
    return args;
  }
};
var IfcMaterialConstituent = class {
  constructor(expressID, type, Name, Description, Material2, Fraction, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material2;
    this.Fraction = Fraction;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material2 = tape[ptr++];
    let Fraction = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialConstituent(expressID, type, Name, Description, Material2, Fraction, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Fraction);
    ;
    args.push(this.Category);
    ;
    return args;
  }
};
var IfcMaterialConstituentSet = class {
  constructor(expressID, type, Name, Description, MaterialConstituents) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialConstituents = MaterialConstituents;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialConstituents = tape[ptr++];
    return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MaterialConstituents);
    ;
    return args;
  }
};
var IfcMaterialDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcMaterialDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMaterialDefinitionRepresentation = class {
  constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
    this.RepresentedMaterial = RepresentedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    let RepresentedMaterial = tape[ptr++];
    return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    args.push(this.RepresentedMaterial);
    ;
    return args;
  }
};
var IfcMaterialLayer = class {
  constructor(expressID, type, Material2, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material2;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material2 = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    return new IfcMaterialLayer(expressID, type, Material2, LayerThickness, IsVentilated, Name, Description, Category, Priority);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    ;
    args.push(this.LayerThickness);
    ;
    args.push(this.IsVentilated);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    args.push(this.Priority);
    ;
    return args;
  }
};
var IfcMaterialLayerSet = class {
  constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialLayers = MaterialLayers;
    this.LayerSetName = LayerSetName;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialLayers = tape[ptr++];
    let LayerSetName = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialLayers);
    ;
    args.push(this.LayerSetName);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcMaterialLayerSetUsage = class {
  constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForLayerSet = ForLayerSet;
    this.LayerSetDirection = LayerSetDirection;
    this.DirectionSense = DirectionSense;
    this.OffsetFromReferenceLine = OffsetFromReferenceLine;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForLayerSet = tape[ptr++];
    let LayerSetDirection = tape[ptr++];
    let DirectionSense = tape[ptr++];
    let OffsetFromReferenceLine = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForLayerSet);
    ;
    args.push(this.LayerSetDirection);
    ;
    args.push(this.DirectionSense);
    ;
    args.push(this.OffsetFromReferenceLine);
    ;
    args.push(this.ReferenceExtent);
    ;
    return args;
  }
};
var IfcMaterialLayerWithOffsets = class {
  constructor(expressID, type, Material2, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material2;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
    this.OffsetDirection = OffsetDirection;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material2 = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    let OffsetDirection = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialLayerWithOffsets(expressID, type, Material2, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    ;
    args.push(this.LayerThickness);
    ;
    args.push(this.IsVentilated);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    args.push(this.Priority);
    ;
    args.push(this.OffsetDirection);
    ;
    args.push(this.OffsetValues);
    ;
    return args;
  }
};
var IfcMaterialList = class {
  constructor(expressID, type, Materials) {
    this.expressID = expressID;
    this.type = type;
    this.Materials = Materials;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Materials = tape[ptr++];
    return new IfcMaterialList(expressID, type, Materials);
  }
  ToTape() {
    let args = [];
    args.push(this.Materials);
    ;
    return args;
  }
};
var IfcMaterialProfile = class {
  constructor(expressID, type, Name, Description, Material2, Profile, Priority, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material2;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material2 = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialProfile(expressID, type, Name, Description, Material2, Profile, Priority, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Profile);
    ;
    args.push(this.Priority);
    ;
    args.push(this.Category);
    ;
    return args;
  }
};
var IfcMaterialProfileSet = class {
  constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialProfiles = MaterialProfiles;
    this.CompositeProfile = CompositeProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialProfiles = tape[ptr++];
    let CompositeProfile = tape[ptr++];
    return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MaterialProfiles);
    ;
    args.push(this.CompositeProfile);
    ;
    return args;
  }
};
var IfcMaterialProfileSetUsage = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    ;
    args.push(this.CardinalPoint);
    ;
    args.push(this.ReferenceExtent);
    ;
    return args;
  }
};
var IfcMaterialProfileSetUsageTapering = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
    this.ForProfileEndSet = ForProfileEndSet;
    this.CardinalEndPoint = CardinalEndPoint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    let ForProfileEndSet = tape[ptr++];
    let CardinalEndPoint = tape[ptr++];
    return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    ;
    args.push(this.CardinalPoint);
    ;
    args.push(this.ReferenceExtent);
    ;
    args.push(this.ForProfileEndSet);
    ;
    args.push(this.CardinalEndPoint);
    ;
    return args;
  }
};
var IfcMaterialProfileWithOffsets = class {
  constructor(expressID, type, Name, Description, Material2, Profile, Priority, Category, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material2;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material2 = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material2, Profile, Priority, Category, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Profile);
    ;
    args.push(this.Priority);
    ;
    args.push(this.Category);
    ;
    args.push(this.OffsetValues);
    ;
    return args;
  }
};
var IfcMaterialProperties = class {
  constructor(expressID, type, Name, Description, Properties, Material2) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties;
    this.Material = Material2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties = tape[ptr++];
    let Material2 = tape[ptr++];
    return new IfcMaterialProperties(expressID, type, Name, Description, Properties, Material2);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    args.push(this.Material);
    ;
    return args;
  }
};
var IfcMaterialRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMaterial = RelatingMaterial;
    this.RelatedMaterials = RelatedMaterials;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    let RelatedMaterials = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingMaterial);
    ;
    args.push(this.RelatedMaterials);
    ;
    args.push(this.Expression);
    ;
    return args;
  }
};
var IfcMaterialUsageDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcMaterialUsageDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMeasureWithUnit = class {
  constructor(expressID, type, ValueComponent, UnitComponent) {
    this.expressID = expressID;
    this.type = type;
    this.ValueComponent = ValueComponent;
    this.UnitComponent = UnitComponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ValueComponent = tape[ptr++];
    let UnitComponent = tape[ptr++];
    return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
  }
  ToTape() {
    let args = [];
    args.push(this.ValueComponent);
    ;
    args.push(this.UnitComponent);
    ;
    return args;
  }
};
var IfcMechanicalFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.NominalLength);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMechanicalFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.NominalLength);
    ;
    return args;
  }
};
var IfcMedicalDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMedicalDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMemberStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMemberType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMetric = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.Benchmark = Benchmark;
    this.ValueSource = ValueSource;
    this.DataValue = DataValue;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let Benchmark = tape[ptr++];
    let ValueSource = tape[ptr++];
    let DataValue = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    args.push(this.Benchmark);
    ;
    args.push(this.ValueSource);
    ;
    args.push(this.DataValue);
    ;
    args.push(this.ReferencePath);
    ;
    return args;
  }
};
var IfcMirroredProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.ParentProfile);
    ;
    args.push(this.Operator);
    ;
    args.push(this.Label);
    ;
    return args;
  }
};
var IfcMonetaryUnit = class {
  constructor(expressID, type, Currency) {
    this.expressID = expressID;
    this.type = type;
    this.Currency = Currency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Currency = tape[ptr++];
    return new IfcMonetaryUnit(expressID, type, Currency);
  }
  ToTape() {
    let args = [];
    args.push(this.Currency);
    ;
    return args;
  }
};
var IfcMotorConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcMotorConnectionType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcNamedUnit = class {
  constructor(expressID, type, Dimensions, UnitType) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    return args;
  }
};
var IfcObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
};
var IfcObjectDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcObjectPlacement = class {
  constructor(expressID, type, PlacementRelTo) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    return new IfcObjectPlacement(expressID, type, PlacementRelTo);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    return args;
  }
};
var IfcObjective = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.BenchmarkValues = BenchmarkValues;
    this.LogicalAggregator = LogicalAggregator;
    this.ObjectiveQualifier = ObjectiveQualifier;
    this.UserDefinedQualifier = UserDefinedQualifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let BenchmarkValues = tape[ptr++];
    let LogicalAggregator = tape[ptr++];
    let ObjectiveQualifier = tape[ptr++];
    let UserDefinedQualifier = tape[ptr++];
    return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    args.push(this.BenchmarkValues);
    ;
    args.push(this.LogicalAggregator);
    ;
    args.push(this.ObjectiveQualifier);
    ;
    args.push(this.UserDefinedQualifier);
    ;
    return args;
  }
};
var IfcOccupant = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheActor);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcOffsetCurve = class {
  constructor(expressID, type, BasisCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    return new IfcOffsetCurve(expressID, type, BasisCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    return args;
  }
};
var IfcOffsetCurve2D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Distance);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcOffsetCurve3D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Distance);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
};
var IfcOffsetCurveByDistances = class {
  constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.OffsetValues = OffsetValues;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let OffsetValues = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.OffsetValues);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcOpenShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcOpenShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
};
var IfcOpeningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcOpeningStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcOrganization = class {
  constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Roles);
    ;
    args.push(this.Addresses);
    ;
    return args;
  }
};
var IfcOrganizationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOrganization = RelatingOrganization;
    this.RelatedOrganizations = RelatedOrganizations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOrganization = tape[ptr++];
    let RelatedOrganizations = tape[ptr++];
    return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingOrganization);
    ;
    args.push(this.RelatedOrganizations);
    ;
    return args;
  }
};
var IfcOrientationExpression = class {
  constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
    this.expressID = expressID;
    this.type = type;
    this.LateralAxisDirection = LateralAxisDirection;
    this.VerticalAxisDirection = VerticalAxisDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LateralAxisDirection = tape[ptr++];
    let VerticalAxisDirection = tape[ptr++];
    return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.LateralAxisDirection);
    ;
    args.push(this.VerticalAxisDirection);
    ;
    return args;
  }
};
var IfcOrientedEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeElement = EdgeElement;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeElement = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.EdgeElement);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
};
var IfcOuterBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
};
var IfcOutlet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcOutletType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcOwnerHistory = class {
  constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
    this.expressID = expressID;
    this.type = type;
    this.OwningUser = OwningUser;
    this.OwningApplication = OwningApplication;
    this.State = State;
    this.ChangeAction = ChangeAction;
    this.LastModifiedDate = LastModifiedDate;
    this.LastModifyingUser = LastModifyingUser;
    this.LastModifyingApplication = LastModifyingApplication;
    this.CreationDate = CreationDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OwningUser = tape[ptr++];
    let OwningApplication = tape[ptr++];
    let State = tape[ptr++];
    let ChangeAction = tape[ptr++];
    let LastModifiedDate = tape[ptr++];
    let LastModifyingUser = tape[ptr++];
    let LastModifyingApplication = tape[ptr++];
    let CreationDate = tape[ptr++];
    return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
  }
  ToTape() {
    let args = [];
    args.push(this.OwningUser);
    ;
    args.push(this.OwningApplication);
    ;
    args.push(this.State);
    ;
    args.push(this.ChangeAction);
    ;
    args.push(this.LastModifiedDate);
    ;
    args.push(this.LastModifyingUser);
    ;
    args.push(this.LastModifyingApplication);
    ;
    args.push(this.CreationDate);
    ;
    return args;
  }
};
var IfcParameterizedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcPath = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcPath(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    ;
    return args;
  }
};
var IfcPcurve = class {
  constructor(expressID, type, BasisSurface, ReferenceCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.ReferenceCurve = ReferenceCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let ReferenceCurve = tape[ptr++];
    return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.ReferenceCurve);
    ;
    return args;
  }
};
var IfcPerformanceHistory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LifeCyclePhase = LifeCyclePhase;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LifeCyclePhase = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LifeCyclePhase);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPermeableCoveringProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.FrameDepth);
    ;
    args.push(this.FrameThickness);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
};
var IfcPermit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
};
var IfcPerson = class {
  constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.FamilyName = FamilyName;
    this.GivenName = GivenName;
    this.MiddleNames = MiddleNames;
    this.PrefixTitles = PrefixTitles;
    this.SuffixTitles = SuffixTitles;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let FamilyName = tape[ptr++];
    let GivenName = tape[ptr++];
    let MiddleNames = tape[ptr++];
    let PrefixTitles = tape[ptr++];
    let SuffixTitles = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.FamilyName);
    ;
    args.push(this.GivenName);
    ;
    args.push(this.MiddleNames);
    ;
    args.push(this.PrefixTitles);
    ;
    args.push(this.SuffixTitles);
    ;
    args.push(this.Roles);
    ;
    args.push(this.Addresses);
    ;
    return args;
  }
};
var IfcPersonAndOrganization = class {
  constructor(expressID, type, ThePerson, TheOrganization, Roles) {
    this.expressID = expressID;
    this.type = type;
    this.ThePerson = ThePerson;
    this.TheOrganization = TheOrganization;
    this.Roles = Roles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ThePerson = tape[ptr++];
    let TheOrganization = tape[ptr++];
    let Roles = tape[ptr++];
    return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
  }
  ToTape() {
    let args = [];
    args.push(this.ThePerson);
    ;
    args.push(this.TheOrganization);
    ;
    args.push(this.Roles);
    ;
    return args;
  }
};
var IfcPhysicalComplexQuantity = class {
  constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.HasQuantities = HasQuantities;
    this.Discrimination = Discrimination;
    this.Quality = Quality;
    this.Usage = Usage;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasQuantities = tape[ptr++];
    let Discrimination = tape[ptr++];
    let Quality = tape[ptr++];
    let Usage = tape[ptr++];
    return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.HasQuantities);
    ;
    args.push(this.Discrimination);
    ;
    args.push(this.Quality);
    ;
    args.push(this.Usage);
    ;
    return args;
  }
};
var IfcPhysicalQuantity = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPhysicalQuantity(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPhysicalSimpleQuantity = class {
  constructor(expressID, type, Name, Description, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
};
var IfcPile = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
    this.ConstructionType = ConstructionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ConstructionType);
    ;
    return args;
  }
};
var IfcPileType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPipeFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPipeFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPipeSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPipeSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPixelTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.Width = Width;
    this.Height = Height;
    this.ColourComponents = ColourComponents;
    this.Pixel = Pixel;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let Width = tape[ptr++];
    let Height = tape[ptr++];
    let ColourComponents = tape[ptr++];
    let Pixel = tape[ptr++];
    return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.Width);
    ;
    args.push(this.Height);
    ;
    args.push(this.ColourComponents);
    ;
    args.push(this.Pixel);
    ;
    return args;
  }
};
var IfcPlacement = class {
  constructor(expressID, type, Location) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    return new IfcPlacement(expressID, type, Location);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    return args;
  }
};
var IfcPlanarBox = class {
  constructor(expressID, type, SizeInX, SizeInY, Placement) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
    this.Placement = Placement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    let Placement = tape[ptr++];
    return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    ;
    args.push(this.SizeInY);
    ;
    args.push(this.Placement);
    ;
    return args;
  }
};
var IfcPlanarExtent = class {
  constructor(expressID, type, SizeInX, SizeInY) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    ;
    args.push(this.SizeInY);
    ;
    return args;
  }
};
var IfcPlane = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcPlane(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcPlate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPlateStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPlateType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPoint = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPoint(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPointOnCurve = class {
  constructor(expressID, type, BasisCurve, PointParameter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.PointParameter = PointParameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let PointParameter = tape[ptr++];
    return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.PointParameter);
    ;
    return args;
  }
};
var IfcPointOnSurface = class {
  constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.PointParameterU = PointParameterU;
    this.PointParameterV = PointParameterV;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let PointParameterU = tape[ptr++];
    let PointParameterV = tape[ptr++];
    return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.PointParameterU);
    ;
    args.push(this.PointParameterV);
    ;
    return args;
  }
};
var IfcPolyLoop = class {
  constructor(expressID, type, Polygon) {
    this.expressID = expressID;
    this.type = type;
    this.Polygon = Polygon;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Polygon = tape[ptr++];
    return new IfcPolyLoop(expressID, type, Polygon);
  }
  ToTape() {
    let args = [];
    args.push(this.Polygon);
    ;
    return args;
  }
};
var IfcPolygonalBoundedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Position = Position;
    this.PolygonalBoundary = PolygonalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Position = tape[ptr++];
    let PolygonalBoundary = tape[ptr++];
    return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    args.push(this.Position);
    ;
    args.push(this.PolygonalBoundary);
    ;
    return args;
  }
};
var IfcPolygonalFaceSet = class {
  constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Closed = Closed;
    this.Faces = Faces;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Closed = tape[ptr++];
    let Faces = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Closed);
    ;
    args.push(this.Faces);
    ;
    args.push(this.PnIndex);
    ;
    return args;
  }
};
var IfcPolyline = class {
  constructor(expressID, type, Points2) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points2 = tape[ptr++];
    return new IfcPolyline(expressID, type, Points2);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    ;
    return args;
  }
};
var IfcPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcPostalAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.InternalLocation = InternalLocation;
    this.AddressLines = AddressLines;
    this.PostalBox = PostalBox;
    this.Town = Town;
    this.Region = Region;
    this.PostalCode = PostalCode;
    this.Country = Country;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let InternalLocation = tape[ptr++];
    let AddressLines = tape[ptr++];
    let PostalBox = tape[ptr++];
    let Town = tape[ptr++];
    let Region = tape[ptr++];
    let PostalCode = tape[ptr++];
    let Country = tape[ptr++];
    return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    args.push(this.InternalLocation);
    ;
    args.push(this.AddressLines);
    ;
    args.push(this.PostalBox);
    ;
    args.push(this.Town);
    ;
    args.push(this.Region);
    ;
    args.push(this.PostalCode);
    ;
    args.push(this.Country);
    ;
    return args;
  }
};
var IfcPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcPreDefinedItem = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedItem(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcPreDefinedProperties = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPreDefinedProperties(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPreDefinedPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPreDefinedTextFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedTextFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcPresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPresentationLayerAssignment = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AssignedItems);
    ;
    args.push(this.Identifier);
    ;
    return args;
  }
};
var IfcPresentationLayerWithStyle = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
    this.LayerOn = LayerOn;
    this.LayerFrozen = LayerFrozen;
    this.LayerBlocked = LayerBlocked;
    this.LayerStyles = LayerStyles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    let LayerOn = tape[ptr++];
    let LayerFrozen = tape[ptr++];
    let LayerBlocked = tape[ptr++];
    let LayerStyles = tape[ptr++];
    return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AssignedItems);
    ;
    args.push(this.Identifier);
    ;
    args.push(this.LayerOn);
    ;
    args.push(this.LayerFrozen);
    ;
    args.push(this.LayerBlocked);
    ;
    args.push(this.LayerStyles);
    ;
    return args;
  }
};
var IfcPresentationStyle = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPresentationStyle(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcPresentationStyleAssignment = class {
  constructor(expressID, type, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Styles = tape[ptr++];
    return new IfcPresentationStyleAssignment(expressID, type, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Styles);
    ;
    return args;
  }
};
var IfcProcedure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProcedureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
};
var IfcProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcProductDefinitionShape = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    return args;
  }
};
var IfcProductRepresentation = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    return args;
  }
};
var IfcProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    return args;
  }
};
var IfcProfileProperties = class {
  constructor(expressID, type, Name, Description, Properties, ProfileDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties;
    this.ProfileDefinition = ProfileDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties = tape[ptr++];
    let ProfileDefinition = tape[ptr++];
    return new IfcProfileProperties(expressID, type, Name, Description, Properties, ProfileDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    args.push(this.ProfileDefinition);
    ;
    return args;
  }
};
var IfcProject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
};
var IfcProjectLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
};
var IfcProjectOrder = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
};
var IfcProjectedCRS = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
    this.MapProjection = MapProjection;
    this.MapZone = MapZone;
    this.MapUnit = MapUnit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    let MapProjection = tape[ptr++];
    let MapZone = tape[ptr++];
    let MapUnit = tape[ptr++];
    return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.GeodeticDatum);
    ;
    args.push(this.VerticalDatum);
    ;
    args.push(this.MapProjection);
    ;
    args.push(this.MapZone);
    ;
    args.push(this.MapUnit);
    ;
    return args;
  }
};
var IfcProjectionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPropertyAbstraction = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPropertyAbstraction(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPropertyBoundedValue = class {
  constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UpperBoundValue = UpperBoundValue;
    this.LowerBoundValue = LowerBoundValue;
    this.Unit = Unit;
    this.SetPointValue = SetPointValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UpperBoundValue = tape[ptr++];
    let LowerBoundValue = tape[ptr++];
    let Unit = tape[ptr++];
    let SetPointValue = tape[ptr++];
    return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UpperBoundValue);
    ;
    args.push(this.LowerBoundValue);
    ;
    args.push(this.Unit);
    ;
    args.push(this.SetPointValue);
    ;
    return args;
  }
};
var IfcPropertyDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPropertyDependencyRelationship = class {
  constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DependingProperty = DependingProperty;
    this.DependantProperty = DependantProperty;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DependingProperty = tape[ptr++];
    let DependantProperty = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DependingProperty);
    ;
    args.push(this.DependantProperty);
    ;
    args.push(this.Expression);
    ;
    return args;
  }
};
var IfcPropertyEnumeratedValue = class {
  constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.EnumerationValues = EnumerationValues;
    this.EnumerationReference = EnumerationReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let EnumerationReference = tape[ptr++];
    return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.EnumerationValues);
    ;
    args.push(this.EnumerationReference);
    ;
    return args;
  }
};
var IfcPropertyEnumeration = class {
  constructor(expressID, type, Name, EnumerationValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.EnumerationValues = EnumerationValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.EnumerationValues);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
};
var IfcPropertyListValue = class {
  constructor(expressID, type, Name, Description, ListValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ListValues = ListValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ListValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ListValues);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
};
var IfcPropertyReferenceValue = class {
  constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.PropertyReference = PropertyReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let PropertyReference = tape[ptr++];
    return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.PropertyReference);
    ;
    return args;
  }
};
var IfcPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.HasProperties);
    ;
    return args;
  }
};
var IfcPropertySetDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPropertySetTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.ApplicableEntity = ApplicableEntity;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let ApplicableEntity = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.ApplicableEntity);
    ;
    args.push(this.HasPropertyTemplates);
    ;
    return args;
  }
};
var IfcPropertySingleValue = class {
  constructor(expressID, type, Name, Description, NominalValue, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.NominalValue = NominalValue;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let NominalValue = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.NominalValue);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
};
var IfcPropertyTableValue = class {
  constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DefiningValues = DefiningValues;
    this.DefinedValues = DefinedValues;
    this.Expression = Expression;
    this.DefiningUnit = DefiningUnit;
    this.DefinedUnit = DefinedUnit;
    this.CurveInterpolation = CurveInterpolation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefiningValues = tape[ptr++];
    let DefinedValues = tape[ptr++];
    let Expression = tape[ptr++];
    let DefiningUnit = tape[ptr++];
    let DefinedUnit = tape[ptr++];
    let CurveInterpolation = tape[ptr++];
    return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DefiningValues);
    ;
    args.push(this.DefinedValues);
    ;
    args.push(this.Expression);
    ;
    args.push(this.DefiningUnit);
    ;
    args.push(this.DefinedUnit);
    ;
    args.push(this.CurveInterpolation);
    ;
    return args;
  }
};
var IfcPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcPropertyTemplateDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcProtectiveDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProtectiveDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.ProxyType = ProxyType;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let ProxyType = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.ProxyType);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcPump = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcPumpType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcQuantityArea = class {
  constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.AreaValue = AreaValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let AreaValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.AreaValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcQuantityCount = class {
  constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.CountValue = CountValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let CountValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.CountValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcQuantityLength = class {
  constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.LengthValue = LengthValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let LengthValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.LengthValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcQuantitySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcQuantityTime = class {
  constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.TimeValue = TimeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.TimeValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcQuantityVolume = class {
  constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.VolumeValue = VolumeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let VolumeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.VolumeValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcQuantityWeight = class {
  constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.WeightValue = WeightValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let WeightValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.WeightValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
};
var IfcRailing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRailingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRampFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRampFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRationalBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.KnotMultiplicities);
    ;
    args.push(this.Knots);
    ;
    args.push(this.KnotSpec);
    ;
    args.push(this.WeightsData);
    ;
    return args;
  }
};
var IfcRationalBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.UMultiplicities);
    ;
    args.push(this.VMultiplicities);
    ;
    args.push(this.UKnots);
    ;
    args.push(this.VKnots);
    ;
    args.push(this.KnotSpec);
    ;
    args.push(this.WeightsData);
    ;
    return args;
  }
};
var IfcRectangleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.WallThickness = WallThickness;
    this.InnerFilletRadius = InnerFilletRadius;
    this.OuterFilletRadius = OuterFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let WallThickness = tape[ptr++];
    let InnerFilletRadius = tape[ptr++];
    let OuterFilletRadius = tape[ptr++];
    return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.WallThickness);
    ;
    args.push(this.InnerFilletRadius);
    ;
    args.push(this.OuterFilletRadius);
    ;
    return args;
  }
};
var IfcRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    return args;
  }
};
var IfcRectangularPyramid = class {
  constructor(expressID, type, Position, XLength, YLength, Height) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.Height = Height;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let Height = tape[ptr++];
    return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.XLength);
    ;
    args.push(this.YLength);
    ;
    args.push(this.Height);
    ;
    return args;
  }
};
var IfcRectangularTrimmedSurface = class {
  constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.U1 = U1;
    this.V1 = V1;
    this.U2 = U2;
    this.V2 = V2;
    this.Usense = Usense;
    this.Vsense = Vsense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let U1 = tape[ptr++];
    let V1 = tape[ptr++];
    let U2 = tape[ptr++];
    let V2 = tape[ptr++];
    let Usense = tape[ptr++];
    let Vsense = tape[ptr++];
    return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.U1);
    ;
    args.push(this.V1);
    ;
    args.push(this.U2);
    ;
    args.push(this.V2);
    ;
    args.push(this.Usense);
    ;
    args.push(this.Vsense);
    ;
    return args;
  }
};
var IfcRecurrencePattern = class {
  constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
    this.expressID = expressID;
    this.type = type;
    this.RecurrenceType = RecurrenceType;
    this.DayComponent = DayComponent;
    this.WeekdayComponent = WeekdayComponent;
    this.MonthComponent = MonthComponent;
    this.Position = Position;
    this.Interval = Interval;
    this.Occurrences = Occurrences;
    this.TimePeriods = TimePeriods;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RecurrenceType = tape[ptr++];
    let DayComponent = tape[ptr++];
    let WeekdayComponent = tape[ptr++];
    let MonthComponent = tape[ptr++];
    let Position = tape[ptr++];
    let Interval = tape[ptr++];
    let Occurrences = tape[ptr++];
    let TimePeriods = tape[ptr++];
    return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
  }
  ToTape() {
    let args = [];
    args.push(this.RecurrenceType);
    ;
    args.push(this.DayComponent);
    ;
    args.push(this.WeekdayComponent);
    ;
    args.push(this.MonthComponent);
    ;
    args.push(this.Position);
    ;
    args.push(this.Interval);
    ;
    args.push(this.Occurrences);
    ;
    args.push(this.TimePeriods);
    ;
    return args;
  }
};
var IfcReference = class {
  constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
    this.expressID = expressID;
    this.type = type;
    this.TypeIdentifier = TypeIdentifier;
    this.AttributeIdentifier = AttributeIdentifier;
    this.InstanceName = InstanceName;
    this.ListPositions = ListPositions;
    this.InnerReference = InnerReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TypeIdentifier = tape[ptr++];
    let AttributeIdentifier = tape[ptr++];
    let InstanceName = tape[ptr++];
    let ListPositions = tape[ptr++];
    let InnerReference = tape[ptr++];
    return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
  }
  ToTape() {
    let args = [];
    args.push(this.TypeIdentifier);
    ;
    args.push(this.AttributeIdentifier);
    ;
    args.push(this.InstanceName);
    ;
    args.push(this.ListPositions);
    ;
    args.push(this.InnerReference);
    ;
    return args;
  }
};
var IfcReferent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.RestartDistance = RestartDistance;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let RestartDistance = tape[ptr++];
    return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.RestartDistance);
    ;
    return args;
  }
};
var IfcRegularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.TimeStep = TimeStep;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeStep = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    args.push(this.TimeStep);
    ;
    args.push(this.Values);
    ;
    return args;
  }
};
var IfcReinforcementBarProperties = class {
  constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
    this.expressID = expressID;
    this.type = type;
    this.TotalCrossSectionArea = TotalCrossSectionArea;
    this.SteelGrade = SteelGrade;
    this.BarSurface = BarSurface;
    this.EffectiveDepth = EffectiveDepth;
    this.NominalBarDiameter = NominalBarDiameter;
    this.BarCount = BarCount;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TotalCrossSectionArea = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let BarSurface = tape[ptr++];
    let EffectiveDepth = tape[ptr++];
    let NominalBarDiameter = tape[ptr++];
    let BarCount = tape[ptr++];
    return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
  }
  ToTape() {
    let args = [];
    args.push(this.TotalCrossSectionArea);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.BarSurface);
    ;
    args.push(this.EffectiveDepth);
    ;
    args.push(this.NominalBarDiameter);
    ;
    args.push(this.BarCount);
    ;
    return args;
  }
};
var IfcReinforcementDefinitionProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.DefinitionType = DefinitionType;
    this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefinitionType = tape[ptr++];
    let ReinforcementSectionDefinitions = tape[ptr++];
    return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DefinitionType);
    ;
    args.push(this.ReinforcementSectionDefinitions);
    ;
    return args;
  }
};
var IfcReinforcingBar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.PredefinedType = PredefinedType;
    this.BarSurface = BarSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let BarSurface = tape[ptr++];
    return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.BarLength);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.BarSurface);
    ;
    return args;
  }
};
var IfcReinforcingBarType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.BarSurface = BarSurface;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let BarSurface = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.BarLength);
    ;
    args.push(this.BarSurface);
    ;
    args.push(this.BendingShapeCode);
    ;
    args.push(this.BendingParameters);
    ;
    return args;
  }
};
var IfcReinforcingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    return args;
  }
};
var IfcReinforcingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcReinforcingMesh = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.MeshLength);
    ;
    args.push(this.MeshWidth);
    ;
    args.push(this.LongitudinalBarNominalDiameter);
    ;
    args.push(this.TransverseBarNominalDiameter);
    ;
    args.push(this.LongitudinalBarCrossSectionArea);
    ;
    args.push(this.TransverseBarCrossSectionArea);
    ;
    args.push(this.LongitudinalBarSpacing);
    ;
    args.push(this.TransverseBarSpacing);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcReinforcingMeshType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.MeshLength);
    ;
    args.push(this.MeshWidth);
    ;
    args.push(this.LongitudinalBarNominalDiameter);
    ;
    args.push(this.TransverseBarNominalDiameter);
    ;
    args.push(this.LongitudinalBarCrossSectionArea);
    ;
    args.push(this.TransverseBarCrossSectionArea);
    ;
    args.push(this.LongitudinalBarSpacing);
    ;
    args.push(this.TransverseBarSpacing);
    ;
    args.push(this.BendingShapeCode);
    ;
    args.push(this.BendingParameters);
    ;
    return args;
  }
};
var IfcRelAggregates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingObject);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
};
var IfcRelAssigns = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    return args;
  }
};
var IfcRelAssignsToActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingActor = RelatingActor;
    this.ActingRole = ActingRole;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingActor = tape[ptr++];
    let ActingRole = tape[ptr++];
    return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingActor);
    ;
    args.push(this.ActingRole);
    ;
    return args;
  }
};
var IfcRelAssignsToControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingControl = RelatingControl;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingControl = tape[ptr++];
    return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingControl);
    ;
    return args;
  }
};
var IfcRelAssignsToGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingGroup);
    ;
    return args;
  }
};
var IfcRelAssignsToGroupByFactor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
    this.Factor = Factor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    let Factor = tape[ptr++];
    return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingGroup);
    ;
    args.push(this.Factor);
    ;
    return args;
  }
};
var IfcRelAssignsToProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProcess = RelatingProcess;
    this.QuantityInProcess = QuantityInProcess;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let QuantityInProcess = tape[ptr++];
    return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingProcess);
    ;
    args.push(this.QuantityInProcess);
    ;
    return args;
  }
};
var IfcRelAssignsToProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProduct = RelatingProduct;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProduct = tape[ptr++];
    return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingProduct);
    ;
    return args;
  }
};
var IfcRelAssignsToResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingResource = RelatingResource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingResource = tape[ptr++];
    return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingResource);
    ;
    return args;
  }
};
var IfcRelAssociates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
};
var IfcRelAssociatesApproval = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingApproval);
    ;
    return args;
  }
};
var IfcRelAssociatesClassification = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingClassification = RelatingClassification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingClassification = tape[ptr++];
    return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingClassification);
    ;
    return args;
  }
};
var IfcRelAssociatesConstraint = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.Intent = Intent;
    this.RelatingConstraint = RelatingConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let Intent = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.Intent);
    ;
    args.push(this.RelatingConstraint);
    ;
    return args;
  }
};
var IfcRelAssociatesDocument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingDocument = RelatingDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingDocument);
    ;
    return args;
  }
};
var IfcRelAssociatesLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingLibrary = RelatingLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingLibrary = tape[ptr++];
    return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingLibrary);
    ;
    return args;
  }
};
var IfcRelAssociatesMaterial = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingMaterial = RelatingMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingMaterial);
    ;
    return args;
  }
};
var IfcRelConnects = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcRelConnectsElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    return args;
  }
};
var IfcRelConnectsPathElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RelatingPriorities = RelatingPriorities;
    this.RelatedPriorities = RelatedPriorities;
    this.RelatedConnectionType = RelatedConnectionType;
    this.RelatingConnectionType = RelatingConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RelatingPriorities = tape[ptr++];
    let RelatedPriorities = tape[ptr++];
    let RelatedConnectionType = tape[ptr++];
    let RelatingConnectionType = tape[ptr++];
    return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.RelatingPriorities);
    ;
    args.push(this.RelatedPriorities);
    ;
    args.push(this.RelatedConnectionType);
    ;
    args.push(this.RelatingConnectionType);
    ;
    return args;
  }
};
var IfcRelConnectsPortToElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPort);
    ;
    args.push(this.RelatedElement);
    ;
    return args;
  }
};
var IfcRelConnectsPorts = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedPort = RelatedPort;
    this.RealizingElement = RealizingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedPort = tape[ptr++];
    let RealizingElement = tape[ptr++];
    return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPort);
    ;
    args.push(this.RelatedPort);
    ;
    args.push(this.RealizingElement);
    ;
    return args;
  }
};
var IfcRelConnectsStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedStructuralActivity = RelatedStructuralActivity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedStructuralActivity = tape[ptr++];
    return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedStructuralActivity);
    ;
    return args;
  }
};
var IfcRelConnectsStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingStructuralMember);
    ;
    args.push(this.RelatedStructuralConnection);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.AdditionalConditions);
    ;
    args.push(this.SupportedLength);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    return args;
  }
};
var IfcRelConnectsWithEccentricity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    this.ConnectionConstraint = ConnectionConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    let ConnectionConstraint = tape[ptr++];
    return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingStructuralMember);
    ;
    args.push(this.RelatedStructuralConnection);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.AdditionalConditions);
    ;
    args.push(this.SupportedLength);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    args.push(this.ConnectionConstraint);
    ;
    return args;
  }
};
var IfcRelConnectsWithRealizingElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RealizingElements = RealizingElements;
    this.ConnectionType = ConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RealizingElements = tape[ptr++];
    let ConnectionType = tape[ptr++];
    return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.RealizingElements);
    ;
    args.push(this.ConnectionType);
    ;
    return args;
  }
};
var IfcRelContainedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedElements);
    ;
    args.push(this.RelatingStructure);
    ;
    return args;
  }
};
var IfcRelCoversBldgElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingBuildingElement);
    ;
    args.push(this.RelatedCoverings);
    ;
    return args;
  }
};
var IfcRelCoversSpaces = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedCoverings);
    ;
    return args;
  }
};
var IfcRelDeclares = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingContext = RelatingContext;
    this.RelatedDefinitions = RelatedDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingContext = tape[ptr++];
    let RelatedDefinitions = tape[ptr++];
    return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingContext);
    ;
    args.push(this.RelatedDefinitions);
    ;
    return args;
  }
};
var IfcRelDecomposes = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcRelDefines = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcRelDefinesByObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingObject = RelatingObject;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingObject = tape[ptr++];
    return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingObject);
    ;
    return args;
  }
};
var IfcRelDefinesByProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingPropertyDefinition = RelatingPropertyDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingPropertyDefinition = tape[ptr++];
    return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingPropertyDefinition);
    ;
    return args;
  }
};
var IfcRelDefinesByTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedPropertySets = RelatedPropertySets;
    this.RelatingTemplate = RelatingTemplate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedPropertySets = tape[ptr++];
    let RelatingTemplate = tape[ptr++];
    return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedPropertySets);
    ;
    args.push(this.RelatingTemplate);
    ;
    return args;
  }
};
var IfcRelDefinesByType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingType = RelatingType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingType = tape[ptr++];
    return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingType);
    ;
    return args;
  }
};
var IfcRelFillsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOpeningElement = RelatingOpeningElement;
    this.RelatedBuildingElement = RelatedBuildingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOpeningElement = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingOpeningElement);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    return args;
  }
};
var IfcRelFlowControlElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedControlElements = RelatedControlElements;
    this.RelatingFlowElement = RelatingFlowElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedControlElements = tape[ptr++];
    let RelatingFlowElement = tape[ptr++];
    return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedControlElements);
    ;
    args.push(this.RelatingFlowElement);
    ;
    return args;
  }
};
var IfcRelInterferesElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.InterferenceGeometry = InterferenceGeometry;
    this.InterferenceType = InterferenceType;
    this.ImpliedOrder = ImpliedOrder;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let InterferenceGeometry = tape[ptr++];
    let InterferenceType = tape[ptr++];
    let ImpliedOrder = tape[ptr++];
    return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.InterferenceGeometry);
    ;
    args.push(this.InterferenceType);
    ;
    args.push(this.ImpliedOrder);
    ;
    return args;
  }
};
var IfcRelNests = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingObject);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
};
var IfcRelPositions = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPositioningElement = RelatingPositioningElement;
    this.RelatedProducts = RelatedProducts;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPositioningElement = tape[ptr++];
    let RelatedProducts = tape[ptr++];
    return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPositioningElement);
    ;
    args.push(this.RelatedProducts);
    ;
    return args;
  }
};
var IfcRelProjectsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedFeatureElement = RelatedFeatureElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedFeatureElement = tape[ptr++];
    return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedFeatureElement);
    ;
    return args;
  }
};
var IfcRelReferencedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedElements);
    ;
    args.push(this.RelatingStructure);
    ;
    return args;
  }
};
var IfcRelSequence = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingProcess = RelatingProcess;
    this.RelatedProcess = RelatedProcess;
    this.TimeLag = TimeLag;
    this.SequenceType = SequenceType;
    this.UserDefinedSequenceType = UserDefinedSequenceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let RelatedProcess = tape[ptr++];
    let TimeLag = tape[ptr++];
    let SequenceType = tape[ptr++];
    let UserDefinedSequenceType = tape[ptr++];
    return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingProcess);
    ;
    args.push(this.RelatedProcess);
    ;
    args.push(this.TimeLag);
    ;
    args.push(this.SequenceType);
    ;
    args.push(this.UserDefinedSequenceType);
    ;
    return args;
  }
};
var IfcRelServicesBuildings = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSystem = RelatingSystem;
    this.RelatedBuildings = RelatedBuildings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSystem = tape[ptr++];
    let RelatedBuildings = tape[ptr++];
    return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSystem);
    ;
    args.push(this.RelatedBuildings);
    ;
    return args;
  }
};
var IfcRelSpaceBoundary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    return args;
  }
};
var IfcRelSpaceBoundary1stLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    args.push(this.ParentBoundary);
    ;
    return args;
  }
};
var IfcRelSpaceBoundary2ndLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
    this.CorrespondingBoundary = CorrespondingBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    let CorrespondingBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    args.push(this.ParentBoundary);
    ;
    args.push(this.CorrespondingBoundary);
    ;
    return args;
  }
};
var IfcRelVoidsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedOpeningElement = RelatedOpeningElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedOpeningElement = tape[ptr++];
    return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingBuildingElement);
    ;
    args.push(this.RelatedOpeningElement);
    ;
    return args;
  }
};
var IfcRelationship = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcReparametrisedCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
    this.ParamLength = ParamLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    let ParamLength = tape[ptr++];
    return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    ;
    args.push(this.SameSense);
    ;
    args.push(this.ParentCurve);
    ;
    args.push(this.ParamLength);
    ;
    return args;
  }
};
var IfcRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    return args;
  }
};
var IfcRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcRepresentationMap = class {
  constructor(expressID, type, MappingOrigin, MappedRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.MappingOrigin = MappingOrigin;
    this.MappedRepresentation = MappedRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingOrigin = tape[ptr++];
    let MappedRepresentation = tape[ptr++];
    return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingOrigin);
    ;
    args.push(this.MappedRepresentation);
    ;
    return args;
  }
};
var IfcResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
};
var IfcResourceApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatedResourceObjects = RelatedResourceObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    args.push(this.RelatingApproval);
    ;
    return args;
  }
};
var IfcResourceConstraintRelationship = class {
  constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingConstraint = RelatingConstraint;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingConstraint);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    return args;
  }
};
var IfcResourceLevelRelationship = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcResourceLevelRelationship(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcResourceTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ScheduleWork = ScheduleWork;
    this.ScheduleUsage = ScheduleUsage;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.ScheduleContour = ScheduleContour;
    this.LevelingDelay = LevelingDelay;
    this.IsOverAllocated = IsOverAllocated;
    this.StatusTime = StatusTime;
    this.ActualWork = ActualWork;
    this.ActualUsage = ActualUsage;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingWork = RemainingWork;
    this.RemainingUsage = RemainingUsage;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ScheduleWork = tape[ptr++];
    let ScheduleUsage = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let ScheduleContour = tape[ptr++];
    let LevelingDelay = tape[ptr++];
    let IsOverAllocated = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualWork = tape[ptr++];
    let ActualUsage = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingWork = tape[ptr++];
    let RemainingUsage = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.ScheduleWork);
    ;
    args.push(this.ScheduleUsage);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.ScheduleContour);
    ;
    args.push(this.LevelingDelay);
    ;
    args.push(this.IsOverAllocated);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualWork);
    ;
    args.push(this.ActualUsage);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingWork);
    ;
    args.push(this.RemainingUsage);
    ;
    args.push(this.Completion);
    ;
    return args;
  }
};
var IfcRevolvedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Axis);
    ;
    args.push(this.Angle);
    ;
    return args;
  }
};
var IfcRevolvedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Axis);
    ;
    args.push(this.Angle);
    ;
    args.push(this.EndSweptArea);
    ;
    return args;
  }
};
var IfcRightCircularCone = class {
  constructor(expressID, type, Position, Height, BottomRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.BottomRadius = BottomRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let BottomRadius = tape[ptr++];
    return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Height);
    ;
    args.push(this.BottomRadius);
    ;
    return args;
  }
};
var IfcRightCircularCylinder = class {
  constructor(expressID, type, Position, Height, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Height);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcRoof = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRoofType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcRoot = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcRoundedRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.RoundingRadius = RoundingRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let RoundingRadius = tape[ptr++];
    return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.RoundingRadius);
    ;
    return args;
  }
};
var IfcSIUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Prefix = Prefix;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Prefix = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Prefix);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcSanitaryTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSanitaryTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSchedulingTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    return args;
  }
};
var IfcSeamCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
};
var IfcSectionProperties = class {
  constructor(expressID, type, SectionType, StartProfile, EndProfile) {
    this.expressID = expressID;
    this.type = type;
    this.SectionType = SectionType;
    this.StartProfile = StartProfile;
    this.EndProfile = EndProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SectionType = tape[ptr++];
    let StartProfile = tape[ptr++];
    let EndProfile = tape[ptr++];
    return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.SectionType);
    ;
    args.push(this.StartProfile);
    ;
    args.push(this.EndProfile);
    ;
    return args;
  }
};
var IfcSectionReinforcementProperties = class {
  constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.LongitudinalStartPosition = LongitudinalStartPosition;
    this.LongitudinalEndPosition = LongitudinalEndPosition;
    this.TransversePosition = TransversePosition;
    this.ReinforcementRole = ReinforcementRole;
    this.SectionDefinition = SectionDefinition;
    this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LongitudinalStartPosition = tape[ptr++];
    let LongitudinalEndPosition = tape[ptr++];
    let TransversePosition = tape[ptr++];
    let ReinforcementRole = tape[ptr++];
    let SectionDefinition = tape[ptr++];
    let CrossSectionReinforcementDefinitions = tape[ptr++];
    return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.LongitudinalStartPosition);
    ;
    args.push(this.LongitudinalEndPosition);
    ;
    args.push(this.TransversePosition);
    ;
    args.push(this.ReinforcementRole);
    ;
    args.push(this.SectionDefinition);
    ;
    args.push(this.CrossSectionReinforcementDefinitions);
    ;
    return args;
  }
};
var IfcSectionedSolid = class {
  constructor(expressID, type, Directrix, CrossSections) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.CrossSections);
    ;
    return args;
  }
};
var IfcSectionedSolidHorizontal = class {
  constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
    this.FixedAxisVertical = FixedAxisVertical;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    let FixedAxisVertical = tape[ptr++];
    return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.CrossSections);
    ;
    args.push(this.CrossSectionPositions);
    ;
    args.push(this.FixedAxisVertical);
    ;
    return args;
  }
};
var IfcSectionedSpine = class {
  constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
    this.expressID = expressID;
    this.type = type;
    this.SpineCurve = SpineCurve;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SpineCurve = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
  }
  ToTape() {
    let args = [];
    args.push(this.SpineCurve);
    ;
    args.push(this.CrossSections);
    ;
    args.push(this.CrossSectionPositions);
    ;
    return args;
  }
};
var IfcSensor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSensorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcShadingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcShadingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcShapeAspect = class {
  constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
    this.expressID = expressID;
    this.type = type;
    this.ShapeRepresentations = ShapeRepresentations;
    this.Name = Name;
    this.Description = Description;
    this.ProductDefinitional = ProductDefinitional;
    this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ShapeRepresentations = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ProductDefinitional = tape[ptr++];
    let PartOfProductDefinitionShape = tape[ptr++];
    return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
  }
  ToTape() {
    let args = [];
    args.push(this.ShapeRepresentations);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ProductDefinitional);
    ;
    args.push(this.PartOfProductDefinitionShape);
    ;
    return args;
  }
};
var IfcShapeModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcShapeRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcShellBasedSurfaceModel = class {
  constructor(expressID, type, SbsmBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.SbsmBoundary = SbsmBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SbsmBoundary = tape[ptr++];
    return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.SbsmBoundary);
    ;
    return args;
  }
};
var IfcSimpleProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcSimpleProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
};
var IfcSimplePropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.PrimaryMeasureType = PrimaryMeasureType;
    this.SecondaryMeasureType = SecondaryMeasureType;
    this.Enumerators = Enumerators;
    this.PrimaryUnit = PrimaryUnit;
    this.SecondaryUnit = SecondaryUnit;
    this.Expression = Expression;
    this.AccessState = AccessState;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let PrimaryMeasureType = tape[ptr++];
    let SecondaryMeasureType = tape[ptr++];
    let Enumerators = tape[ptr++];
    let PrimaryUnit = tape[ptr++];
    let SecondaryUnit = tape[ptr++];
    let Expression = tape[ptr++];
    let AccessState = tape[ptr++];
    return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.PrimaryMeasureType);
    ;
    args.push(this.SecondaryMeasureType);
    ;
    args.push(this.Enumerators);
    ;
    args.push(this.PrimaryUnit);
    ;
    args.push(this.SecondaryUnit);
    ;
    args.push(this.Expression);
    ;
    args.push(this.AccessState);
    ;
    return args;
  }
};
var IfcSite = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.RefLatitude = RefLatitude;
    this.RefLongitude = RefLongitude;
    this.RefElevation = RefElevation;
    this.LandTitleNumber = LandTitleNumber;
    this.SiteAddress = SiteAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let RefLatitude = tape[ptr++];
    let RefLongitude = tape[ptr++];
    let RefElevation = tape[ptr++];
    let LandTitleNumber = tape[ptr++];
    let SiteAddress = tape[ptr++];
    return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.RefLatitude);
    ;
    args.push(this.RefLongitude);
    ;
    args.push(this.RefElevation);
    ;
    args.push(this.LandTitleNumber);
    ;
    args.push(this.SiteAddress);
    ;
    return args;
  }
};
var IfcSlab = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSlabElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSlabStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSlabType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSlippageConnectionCondition = class {
  constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SlippageX = SlippageX;
    this.SlippageY = SlippageY;
    this.SlippageZ = SlippageZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SlippageX = tape[ptr++];
    let SlippageY = tape[ptr++];
    let SlippageZ = tape[ptr++];
    return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.SlippageX);
    ;
    args.push(this.SlippageY);
    ;
    args.push(this.SlippageZ);
    ;
    return args;
  }
};
var IfcSolarDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSolarDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSolidModel = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcSolidModel(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSpace = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
    this.ElevationWithFlooring = ElevationWithFlooring;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ElevationWithFlooring = tape[ptr++];
    return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ElevationWithFlooring);
    ;
    return args;
  }
};
var IfcSpaceHeater = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSpaceHeaterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSpaceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};
var IfcSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};
var IfcSpatialElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
};
var IfcSpatialStructureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
};
var IfcSpatialZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSpatialZoneType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};
var IfcSphere = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphere(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcSphericalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphericalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
};
var IfcStackTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStackTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStair = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStairFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NumberOfRisers = NumberOfRisers;
    this.NumberOfTreads = NumberOfTreads;
    this.RiserHeight = RiserHeight;
    this.TreadLength = TreadLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NumberOfRisers = tape[ptr++];
    let NumberOfTreads = tape[ptr++];
    let RiserHeight = tape[ptr++];
    let TreadLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.NumberOfRisers);
    ;
    args.push(this.NumberOfTreads);
    ;
    args.push(this.RiserHeight);
    ;
    args.push(this.TreadLength);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStairFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStairType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    return args;
  }
};
var IfcStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
};
var IfcStructuralAnalysisModel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.OrientationOf2DPlane = OrientationOf2DPlane;
    this.LoadedBy = LoadedBy;
    this.HasResults = HasResults;
    this.SharedPlacement = SharedPlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OrientationOf2DPlane = tape[ptr++];
    let LoadedBy = tape[ptr++];
    let HasResults = tape[ptr++];
    let SharedPlacement = tape[ptr++];
    return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OrientationOf2DPlane);
    ;
    args.push(this.LoadedBy);
    ;
    args.push(this.HasResults);
    ;
    args.push(this.SharedPlacement);
    ;
    return args;
  }
};
var IfcStructuralConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    return args;
  }
};
var IfcStructuralConnectionCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralConnectionCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcStructuralCurveAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralCurveConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
};
var IfcStructuralCurveMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
};
var IfcStructuralCurveMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
};
var IfcStructuralCurveReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcStructuralLinearAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralLoad = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoad(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcStructuralLoadCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
    this.SelfWeightCoefficients = SelfWeightCoefficients;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    let SelfWeightCoefficients = tape[ptr++];
    return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ActionType);
    ;
    args.push(this.ActionSource);
    ;
    args.push(this.Coefficient);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.SelfWeightCoefficients);
    ;
    return args;
  }
};
var IfcStructuralLoadConfiguration = class {
  constructor(expressID, type, Name, Values, Locations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Values = Values;
    this.Locations = Locations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Values = tape[ptr++];
    let Locations = tape[ptr++];
    return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Values);
    ;
    args.push(this.Locations);
    ;
    return args;
  }
};
var IfcStructuralLoadGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ActionType);
    ;
    args.push(this.ActionSource);
    ;
    args.push(this.Coefficient);
    ;
    args.push(this.Purpose);
    ;
    return args;
  }
};
var IfcStructuralLoadLinearForce = class {
  constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LinearForceX = LinearForceX;
    this.LinearForceY = LinearForceY;
    this.LinearForceZ = LinearForceZ;
    this.LinearMomentX = LinearMomentX;
    this.LinearMomentY = LinearMomentY;
    this.LinearMomentZ = LinearMomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LinearForceX = tape[ptr++];
    let LinearForceY = tape[ptr++];
    let LinearForceZ = tape[ptr++];
    let LinearMomentX = tape[ptr++];
    let LinearMomentY = tape[ptr++];
    let LinearMomentZ = tape[ptr++];
    return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LinearForceX);
    ;
    args.push(this.LinearForceY);
    ;
    args.push(this.LinearForceZ);
    ;
    args.push(this.LinearMomentX);
    ;
    args.push(this.LinearMomentY);
    ;
    args.push(this.LinearMomentZ);
    ;
    return args;
  }
};
var IfcStructuralLoadOrResult = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadOrResult(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcStructuralLoadPlanarForce = class {
  constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PlanarForceX = PlanarForceX;
    this.PlanarForceY = PlanarForceY;
    this.PlanarForceZ = PlanarForceZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PlanarForceX = tape[ptr++];
    let PlanarForceY = tape[ptr++];
    let PlanarForceZ = tape[ptr++];
    return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.PlanarForceX);
    ;
    args.push(this.PlanarForceY);
    ;
    args.push(this.PlanarForceZ);
    ;
    return args;
  }
};
var IfcStructuralLoadSingleDisplacement = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DisplacementX);
    ;
    args.push(this.DisplacementY);
    ;
    args.push(this.DisplacementZ);
    ;
    args.push(this.RotationalDisplacementRX);
    ;
    args.push(this.RotationalDisplacementRY);
    ;
    args.push(this.RotationalDisplacementRZ);
    ;
    return args;
  }
};
var IfcStructuralLoadSingleDisplacementDistortion = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    this.Distortion = Distortion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    let Distortion = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DisplacementX);
    ;
    args.push(this.DisplacementY);
    ;
    args.push(this.DisplacementZ);
    ;
    args.push(this.RotationalDisplacementRX);
    ;
    args.push(this.RotationalDisplacementRY);
    ;
    args.push(this.RotationalDisplacementRZ);
    ;
    args.push(this.Distortion);
    ;
    return args;
  }
};
var IfcStructuralLoadSingleForce = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.ForceX);
    ;
    args.push(this.ForceY);
    ;
    args.push(this.ForceZ);
    ;
    args.push(this.MomentX);
    ;
    args.push(this.MomentY);
    ;
    args.push(this.MomentZ);
    ;
    return args;
  }
};
var IfcStructuralLoadSingleForceWarping = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
    this.WarpingMoment = WarpingMoment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    let WarpingMoment = tape[ptr++];
    return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.ForceX);
    ;
    args.push(this.ForceY);
    ;
    args.push(this.ForceZ);
    ;
    args.push(this.MomentX);
    ;
    args.push(this.MomentY);
    ;
    args.push(this.MomentZ);
    ;
    args.push(this.WarpingMoment);
    ;
    return args;
  }
};
var IfcStructuralLoadStatic = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadStatic(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcStructuralLoadTemperature = class {
  constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DeltaTConstant = DeltaTConstant;
    this.DeltaTY = DeltaTY;
    this.DeltaTZ = DeltaTZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DeltaTConstant = tape[ptr++];
    let DeltaTY = tape[ptr++];
    let DeltaTZ = tape[ptr++];
    return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DeltaTConstant);
    ;
    args.push(this.DeltaTY);
    ;
    args.push(this.DeltaTZ);
    ;
    return args;
  }
};
var IfcStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
};
var IfcStructuralPlanarAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralPointAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    return args;
  }
};
var IfcStructuralPointConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    return args;
  }
};
var IfcStructuralPointReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
};
var IfcStructuralReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
};
var IfcStructuralResultGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheoryType = TheoryType;
    this.ResultForLoadGroup = ResultForLoadGroup;
    this.IsLinear = IsLinear;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheoryType = tape[ptr++];
    let ResultForLoadGroup = tape[ptr++];
    let IsLinear = tape[ptr++];
    return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheoryType);
    ;
    args.push(this.ResultForLoadGroup);
    ;
    args.push(this.IsLinear);
    ;
    return args;
  }
};
var IfcStructuralSurfaceAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStructuralSurfaceConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    return args;
  }
};
var IfcStructuralSurfaceMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
};
var IfcStructuralSurfaceMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
};
var IfcStructuralSurfaceReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcStyleModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcStyledItem = class {
  constructor(expressID, type, Item, Styles, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Item = Item;
    this.Styles = Styles;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Item = tape[ptr++];
    let Styles = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcStyledItem(expressID, type, Item, Styles, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Item);
    ;
    args.push(this.Styles);
    ;
    args.push(this.Name);
    ;
    return args;
  }
};
var IfcStyledRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcSubContractResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSubContractResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSubedge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.ParentEdge = ParentEdge;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let ParentEdge = tape[ptr++];
    return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.ParentEdge);
    ;
    return args;
  }
};
var IfcSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSurfaceCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
};
var IfcSurfaceCurveSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.ReferenceSurface = ReferenceSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let ReferenceSurface = tape[ptr++];
    return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Directrix);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.ReferenceSurface);
    ;
    return args;
  }
};
var IfcSurfaceFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSurfaceOfLinearExtrusion = class {
  constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    return args;
  }
};
var IfcSurfaceOfRevolution = class {
  constructor(expressID, type, SweptCurve, Position, AxisPosition) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.AxisPosition = AxisPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let AxisPosition = tape[ptr++];
    return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    args.push(this.AxisPosition);
    ;
    return args;
  }
};
var IfcSurfaceReinforcementArea = class {
  constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SurfaceReinforcement1 = SurfaceReinforcement1;
    this.SurfaceReinforcement2 = SurfaceReinforcement2;
    this.ShearReinforcement = ShearReinforcement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SurfaceReinforcement1 = tape[ptr++];
    let SurfaceReinforcement2 = tape[ptr++];
    let ShearReinforcement = tape[ptr++];
    return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.SurfaceReinforcement1);
    ;
    args.push(this.SurfaceReinforcement2);
    ;
    args.push(this.ShearReinforcement);
    ;
    return args;
  }
};
var IfcSurfaceStyle = class {
  constructor(expressID, type, Name, Side, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Side = Side;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Side = tape[ptr++];
    let Styles = tape[ptr++];
    return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Side);
    ;
    args.push(this.Styles);
    ;
    return args;
  }
};
var IfcSurfaceStyleLighting = class {
  constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
    this.expressID = expressID;
    this.type = type;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.DiffuseReflectionColour = DiffuseReflectionColour;
    this.TransmissionColour = TransmissionColour;
    this.ReflectanceColour = ReflectanceColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DiffuseTransmissionColour = tape[ptr++];
    let DiffuseReflectionColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let ReflectanceColour = tape[ptr++];
    return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
  }
  ToTape() {
    let args = [];
    args.push(this.DiffuseTransmissionColour);
    ;
    args.push(this.DiffuseReflectionColour);
    ;
    args.push(this.TransmissionColour);
    ;
    args.push(this.ReflectanceColour);
    ;
    return args;
  }
};
var IfcSurfaceStyleRefraction = class {
  constructor(expressID, type, RefractionIndex, DispersionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.RefractionIndex = RefractionIndex;
    this.DispersionFactor = DispersionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RefractionIndex = tape[ptr++];
    let DispersionFactor = tape[ptr++];
    return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.RefractionIndex);
    ;
    args.push(this.DispersionFactor);
    ;
    return args;
  }
};
var IfcSurfaceStyleRendering = class {
  constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
    this.DiffuseColour = DiffuseColour;
    this.TransmissionColour = TransmissionColour;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.ReflectionColour = ReflectionColour;
    this.SpecularColour = SpecularColour;
    this.SpecularHighlight = SpecularHighlight;
    this.ReflectanceMethod = ReflectanceMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    let DiffuseColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let DiffuseTransmissionColour = tape[ptr++];
    let ReflectionColour = tape[ptr++];
    let SpecularColour = tape[ptr++];
    let SpecularHighlight = tape[ptr++];
    let ReflectanceMethod = tape[ptr++];
    return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    ;
    args.push(this.Transparency);
    ;
    args.push(this.DiffuseColour);
    ;
    args.push(this.TransmissionColour);
    ;
    args.push(this.DiffuseTransmissionColour);
    ;
    args.push(this.ReflectionColour);
    ;
    args.push(this.SpecularColour);
    ;
    args.push(this.SpecularHighlight);
    ;
    args.push(this.ReflectanceMethod);
    ;
    return args;
  }
};
var IfcSurfaceStyleShading = class {
  constructor(expressID, type, SurfaceColour, Transparency) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    ;
    args.push(this.Transparency);
    ;
    return args;
  }
};
var IfcSurfaceStyleWithTextures = class {
  constructor(expressID, type, Textures) {
    this.expressID = expressID;
    this.type = type;
    this.Textures = Textures;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Textures = tape[ptr++];
    return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
  }
  ToTape() {
    let args = [];
    args.push(this.Textures);
    ;
    return args;
  }
};
var IfcSurfaceTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    return args;
  }
};
var IfcSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcSweptDiskSolid = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.Radius);
    ;
    args.push(this.InnerRadius);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    return args;
  }
};
var IfcSweptDiskSolidPolygonal = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FilletRadius = FilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FilletRadius = tape[ptr++];
    return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.Radius);
    ;
    args.push(this.InnerRadius);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.FilletRadius);
    ;
    return args;
  }
};
var IfcSweptSurface = class {
  constructor(expressID, type, SweptCurve, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptSurface(expressID, type, SweptCurve, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    return args;
  }
};
var IfcSwitchingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSwitchingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
};
var IfcSystemFurnitureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcSystemFurnitureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.WebEdgeRadius = WebEdgeRadius;
    this.WebSlope = WebSlope;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let WebEdgeRadius = tape[ptr++];
    let WebSlope = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.FlangeEdgeRadius);
    ;
    args.push(this.WebEdgeRadius);
    ;
    args.push(this.WebSlope);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
};
var IfcTable = class {
  constructor(expressID, type, Name, Rows, Columns) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Rows = Rows;
    this.Columns = Columns;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Rows = tape[ptr++];
    let Columns = tape[ptr++];
    return new IfcTable(expressID, type, Name, Rows, Columns);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Rows);
    ;
    args.push(this.Columns);
    ;
    return args;
  }
};
var IfcTableColumn = class {
  constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.ReferencePath);
    ;
    return args;
  }
};
var IfcTableRow = class {
  constructor(expressID, type, RowCells, IsHeading) {
    this.expressID = expressID;
    this.type = type;
    this.RowCells = RowCells;
    this.IsHeading = IsHeading;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RowCells = tape[ptr++];
    let IsHeading = tape[ptr++];
    return new IfcTableRow(expressID, type, RowCells, IsHeading);
  }
  ToTape() {
    let args = [];
    args.push(this.RowCells);
    ;
    args.push(this.IsHeading);
    ;
    return args;
  }
};
var IfcTank = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTankType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTask = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Status = Status;
    this.WorkMethod = WorkMethod;
    this.IsMilestone = IsMilestone;
    this.Priority = Priority;
    this.TaskTime = TaskTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Status = tape[ptr++];
    let WorkMethod = tape[ptr++];
    let IsMilestone = tape[ptr++];
    let Priority = tape[ptr++];
    let TaskTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Status);
    ;
    args.push(this.WorkMethod);
    ;
    args.push(this.IsMilestone);
    ;
    args.push(this.Priority);
    ;
    args.push(this.TaskTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTaskTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.DurationType);
    ;
    args.push(this.ScheduleDuration);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.EarlyStart);
    ;
    args.push(this.EarlyFinish);
    ;
    args.push(this.LateStart);
    ;
    args.push(this.LateFinish);
    ;
    args.push(this.FreeFloat);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.IsCritical);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualDuration);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingTime);
    ;
    args.push(this.Completion);
    ;
    return args;
  }
};
var IfcTaskTimeRecurring = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
    this.Recurrence = Recurrence;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    let Recurrence = tape[ptr++];
    return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.DurationType);
    ;
    args.push(this.ScheduleDuration);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.EarlyStart);
    ;
    args.push(this.EarlyFinish);
    ;
    args.push(this.LateStart);
    ;
    args.push(this.LateFinish);
    ;
    args.push(this.FreeFloat);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.IsCritical);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualDuration);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingTime);
    ;
    args.push(this.Completion);
    ;
    args.push(this.Recurrence);
    ;
    return args;
  }
};
var IfcTaskType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.WorkMethod = WorkMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let WorkMethod = tape[ptr++];
    return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.WorkMethod);
    ;
    return args;
  }
};
var IfcTelecomAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.TelephoneNumbers = TelephoneNumbers;
    this.FacsimileNumbers = FacsimileNumbers;
    this.PagerNumber = PagerNumber;
    this.ElectronicMailAddresses = ElectronicMailAddresses;
    this.WWWHomePageURL = WWWHomePageURL;
    this.MessagingIDs = MessagingIDs;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let TelephoneNumbers = tape[ptr++];
    let FacsimileNumbers = tape[ptr++];
    let PagerNumber = tape[ptr++];
    let ElectronicMailAddresses = tape[ptr++];
    let WWWHomePageURL = tape[ptr++];
    let MessagingIDs = tape[ptr++];
    return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    args.push(this.TelephoneNumbers);
    ;
    args.push(this.FacsimileNumbers);
    ;
    args.push(this.PagerNumber);
    ;
    args.push(this.ElectronicMailAddresses);
    ;
    args.push(this.WWWHomePageURL);
    ;
    args.push(this.MessagingIDs);
    ;
    return args;
  }
};
var IfcTendon = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.TensionForce = TensionForce;
    this.PreStress = PreStress;
    this.FrictionCoefficient = FrictionCoefficient;
    this.AnchorageSlip = AnchorageSlip;
    this.MinCurvatureRadius = MinCurvatureRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let TensionForce = tape[ptr++];
    let PreStress = tape[ptr++];
    let FrictionCoefficient = tape[ptr++];
    let AnchorageSlip = tape[ptr++];
    let MinCurvatureRadius = tape[ptr++];
    return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.TensionForce);
    ;
    args.push(this.PreStress);
    ;
    args.push(this.FrictionCoefficient);
    ;
    args.push(this.AnchorageSlip);
    ;
    args.push(this.MinCurvatureRadius);
    ;
    return args;
  }
};
var IfcTendonAnchor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTendonAnchorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTendonConduit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTendonConduitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTendonType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.SheathDiameter = SheathDiameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let SheathDiameter = tape[ptr++];
    return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.SheathDiameter);
    ;
    return args;
  }
};
var IfcTessellatedFaceSet = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTessellatedFaceSet(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
};
var IfcTessellatedItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcTessellatedItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTextLiteral = class {
  constructor(expressID, type, Literal, Placement, Path2) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path2 = tape[ptr++];
    return new IfcTextLiteral(expressID, type, Literal, Placement, Path2);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    ;
    args.push(this.Placement);
    ;
    args.push(this.Path);
    ;
    return args;
  }
};
var IfcTextLiteralWithExtent = class {
  constructor(expressID, type, Literal, Placement, Path2, Extent, BoxAlignment) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path2;
    this.Extent = Extent;
    this.BoxAlignment = BoxAlignment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path2 = tape[ptr++];
    let Extent = tape[ptr++];
    let BoxAlignment = tape[ptr++];
    return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path2, Extent, BoxAlignment);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    ;
    args.push(this.Placement);
    ;
    args.push(this.Path);
    ;
    args.push(this.Extent);
    ;
    args.push(this.BoxAlignment);
    ;
    return args;
  }
};
var IfcTextStyle = class {
  constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TextCharacterAppearance = TextCharacterAppearance;
    this.TextStyle = TextStyle;
    this.TextFontStyle = TextFontStyle;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TextCharacterAppearance = tape[ptr++];
    let TextStyle = tape[ptr++];
    let TextFontStyle = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TextCharacterAppearance);
    ;
    args.push(this.TextStyle);
    ;
    args.push(this.TextFontStyle);
    ;
    args.push(this.ModelOrDraughting);
    ;
    return args;
  }
};
var IfcTextStyleFontModel = class {
  constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FontFamily = FontFamily;
    this.FontStyle = FontStyle;
    this.FontVariant = FontVariant;
    this.FontWeight = FontWeight;
    this.FontSize = FontSize;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FontFamily = tape[ptr++];
    let FontStyle = tape[ptr++];
    let FontVariant = tape[ptr++];
    let FontWeight = tape[ptr++];
    let FontSize = tape[ptr++];
    return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.FontFamily);
    ;
    args.push(this.FontStyle);
    ;
    args.push(this.FontVariant);
    ;
    args.push(this.FontWeight);
    ;
    args.push(this.FontSize);
    ;
    return args;
  }
};
var IfcTextStyleForDefinedFont = class {
  constructor(expressID, type, Colour, BackgroundColour) {
    this.expressID = expressID;
    this.type = type;
    this.Colour = Colour;
    this.BackgroundColour = BackgroundColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Colour = tape[ptr++];
    let BackgroundColour = tape[ptr++];
    return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
  }
  ToTape() {
    let args = [];
    args.push(this.Colour);
    ;
    args.push(this.BackgroundColour);
    ;
    return args;
  }
};
var IfcTextStyleTextModel = class {
  constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
    this.expressID = expressID;
    this.type = type;
    this.TextIndent = TextIndent;
    this.TextAlign = TextAlign;
    this.TextDecoration = TextDecoration;
    this.LetterSpacing = LetterSpacing;
    this.WordSpacing = WordSpacing;
    this.TextTransform = TextTransform;
    this.LineHeight = LineHeight;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TextIndent = tape[ptr++];
    let TextAlign = tape[ptr++];
    let TextDecoration = tape[ptr++];
    let LetterSpacing = tape[ptr++];
    let WordSpacing = tape[ptr++];
    let TextTransform = tape[ptr++];
    let LineHeight = tape[ptr++];
    return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
  }
  ToTape() {
    let args = [];
    args.push(this.TextIndent);
    ;
    args.push(this.TextAlign);
    ;
    args.push(this.TextDecoration);
    ;
    args.push(this.LetterSpacing);
    ;
    args.push(this.WordSpacing);
    ;
    args.push(this.TextTransform);
    ;
    args.push(this.LineHeight);
    ;
    return args;
  }
};
var IfcTextureCoordinate = class {
  constructor(expressID, type, Maps) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    return new IfcTextureCoordinate(expressID, type, Maps);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    return args;
  }
};
var IfcTextureCoordinateGenerator = class {
  constructor(expressID, type, Maps, Mode, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Mode = Mode;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Mode = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.Mode);
    ;
    args.push(this.Parameter);
    ;
    return args;
  }
};
var IfcTextureMap = class {
  constructor(expressID, type, Maps, Vertices, MappedTo) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Vertices = Vertices;
    this.MappedTo = MappedTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Vertices = tape[ptr++];
    let MappedTo = tape[ptr++];
    return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.Vertices);
    ;
    args.push(this.MappedTo);
    ;
    return args;
  }
};
var IfcTextureVertex = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTextureVertex(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
};
var IfcTextureVertexList = class {
  constructor(expressID, type, TexCoordsList) {
    this.expressID = expressID;
    this.type = type;
    this.TexCoordsList = TexCoordsList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TexCoordsList = tape[ptr++];
    return new IfcTextureVertexList(expressID, type, TexCoordsList);
  }
  ToTape() {
    let args = [];
    args.push(this.TexCoordsList);
    ;
    return args;
  }
};
var IfcTimePeriod = class {
  constructor(expressID, type, StartTime, EndTime) {
    this.expressID = expressID;
    this.type = type;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    return new IfcTimePeriod(expressID, type, StartTime, EndTime);
  }
  ToTape() {
    let args = [];
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    return args;
  }
};
var IfcTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
};
var IfcTimeSeriesValue = class {
  constructor(expressID, type, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ListValues = tape[ptr++];
    return new IfcTimeSeriesValue(expressID, type, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.ListValues);
    ;
    return args;
  }
};
var IfcTopologicalRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcTopologicalRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTopologyRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
};
var IfcToroidalSurface = class {
  constructor(expressID, type, Position, MajorRadius, MinorRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.MajorRadius = MajorRadius;
    this.MinorRadius = MinorRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let MajorRadius = tape[ptr++];
    let MinorRadius = tape[ptr++];
    return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.MajorRadius);
    ;
    args.push(this.MinorRadius);
    ;
    return args;
  }
};
var IfcTransformer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTransformerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTransitionCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.StartRadius = StartRadius;
    this.EndRadius = EndRadius;
    this.IsStartRadiusCCW = IsStartRadiusCCW;
    this.IsEndRadiusCCW = IsEndRadiusCCW;
    this.TransitionCurveType = TransitionCurveType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let StartRadius = tape[ptr++];
    let EndRadius = tape[ptr++];
    let IsStartRadiusCCW = tape[ptr++];
    let IsEndRadiusCCW = tape[ptr++];
    let TransitionCurveType = tape[ptr++];
    return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    args.push(this.StartRadius);
    ;
    args.push(this.EndRadius);
    ;
    args.push(this.IsStartRadiusCCW);
    ;
    args.push(this.IsEndRadiusCCW);
    ;
    args.push(this.TransitionCurveType);
    ;
    return args;
  }
};
var IfcTransportElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTransportElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTrapeziumProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomXDim = BottomXDim;
    this.TopXDim = TopXDim;
    this.YDim = YDim;
    this.TopXOffset = TopXOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomXDim = tape[ptr++];
    let TopXDim = tape[ptr++];
    let YDim = tape[ptr++];
    let TopXOffset = tape[ptr++];
    return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.BottomXDim);
    ;
    args.push(this.TopXDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.TopXOffset);
    ;
    return args;
  }
};
var IfcTriangulatedFaceSet = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Normals);
    ;
    args.push(this.Closed);
    ;
    args.push(this.CoordIndex);
    ;
    args.push(this.PnIndex);
    ;
    return args;
  }
};
var IfcTriangulatedIrregularNetwork = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
    this.Flags = Flags;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    let Flags = tape[ptr++];
    return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Normals);
    ;
    args.push(this.Closed);
    ;
    args.push(this.CoordIndex);
    ;
    args.push(this.PnIndex);
    ;
    args.push(this.Flags);
    ;
    return args;
  }
};
var IfcTrimmedCurve = class {
  constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Trim1 = Trim1;
    this.Trim2 = Trim2;
    this.SenseAgreement = SenseAgreement;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Trim1 = tape[ptr++];
    let Trim2 = tape[ptr++];
    let SenseAgreement = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Trim1);
    ;
    args.push(this.Trim2);
    ;
    args.push(this.SenseAgreement);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
};
var IfcTubeBundle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTubeBundleType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcTypeObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    return args;
  }
};
var IfcTypeProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    return args;
  }
};
var IfcTypeProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcTypeResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    return args;
  }
};
var IfcUShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
};
var IfcUnitAssignment = class {
  constructor(expressID, type, Units) {
    this.expressID = expressID;
    this.type = type;
    this.Units = Units;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Units = tape[ptr++];
    return new IfcUnitAssignment(expressID, type, Units);
  }
  ToTape() {
    let args = [];
    args.push(this.Units);
    ;
    return args;
  }
};
var IfcUnitaryControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcUnitaryControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcUnitaryEquipment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcUnitaryEquipmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcValve = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcValveType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcVector = class {
  constructor(expressID, type, Orientation, Magnitude) {
    this.expressID = expressID;
    this.type = type;
    this.Orientation = Orientation;
    this.Magnitude = Magnitude;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Orientation = tape[ptr++];
    let Magnitude = tape[ptr++];
    return new IfcVector(expressID, type, Orientation, Magnitude);
  }
  ToTape() {
    let args = [];
    args.push(this.Orientation);
    ;
    args.push(this.Magnitude);
    ;
    return args;
  }
};
var IfcVertex = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcVertex(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcVertexLoop = class {
  constructor(expressID, type, LoopVertex) {
    this.expressID = expressID;
    this.type = type;
    this.LoopVertex = LoopVertex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LoopVertex = tape[ptr++];
    return new IfcVertexLoop(expressID, type, LoopVertex);
  }
  ToTape() {
    let args = [];
    args.push(this.LoopVertex);
    ;
    return args;
  }
};
var IfcVertexPoint = class {
  constructor(expressID, type, VertexGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.VertexGeometry = VertexGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VertexGeometry = tape[ptr++];
    return new IfcVertexPoint(expressID, type, VertexGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.VertexGeometry);
    ;
    return args;
  }
};
var IfcVibrationDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcVibrationDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcVibrationIsolator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcVibrationIsolatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcVirtualElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
};
var IfcVirtualGridIntersection = class {
  constructor(expressID, type, IntersectingAxes, OffsetDistances) {
    this.expressID = expressID;
    this.type = type;
    this.IntersectingAxes = IntersectingAxes;
    this.OffsetDistances = OffsetDistances;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let IntersectingAxes = tape[ptr++];
    let OffsetDistances = tape[ptr++];
    return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
  }
  ToTape() {
    let args = [];
    args.push(this.IntersectingAxes);
    ;
    args.push(this.OffsetDistances);
    ;
    return args;
  }
};
var IfcVoidingFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWallElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWallStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWasteTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWasteTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWindow = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
};
var IfcWindowLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.TransomThickness = TransomThickness;
    this.MullionThickness = MullionThickness;
    this.FirstTransomOffset = FirstTransomOffset;
    this.SecondTransomOffset = SecondTransomOffset;
    this.FirstMullionOffset = FirstMullionOffset;
    this.SecondMullionOffset = SecondMullionOffset;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningOffset = LiningOffset;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let MullionThickness = tape[ptr++];
    let FirstTransomOffset = tape[ptr++];
    let SecondTransomOffset = tape[ptr++];
    let FirstMullionOffset = tape[ptr++];
    let SecondMullionOffset = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.LiningDepth);
    ;
    args.push(this.LiningThickness);
    ;
    args.push(this.TransomThickness);
    ;
    args.push(this.MullionThickness);
    ;
    args.push(this.FirstTransomOffset);
    ;
    args.push(this.SecondTransomOffset);
    ;
    args.push(this.FirstMullionOffset);
    ;
    args.push(this.SecondMullionOffset);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    args.push(this.LiningOffset);
    ;
    args.push(this.LiningToPanelOffsetX);
    ;
    args.push(this.LiningToPanelOffsetY);
    ;
    return args;
  }
};
var IfcWindowPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.FrameDepth);
    ;
    args.push(this.FrameThickness);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
};
var IfcWindowStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
};
var IfcWindowStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ConstructionType = ConstructionType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ConstructionType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.Sizeable);
    ;
    return args;
  }
};
var IfcWindowType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
};
var IfcWorkCalendar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.WorkingTimes = WorkingTimes;
    this.ExceptionTimes = ExceptionTimes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let WorkingTimes = tape[ptr++];
    let ExceptionTimes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.WorkingTimes);
    ;
    args.push(this.ExceptionTimes);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWorkControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    return args;
  }
};
var IfcWorkPlan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWorkSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
};
var IfcWorkTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.RecurrencePattern = RecurrencePattern;
    this.Start = Start;
    this.Finish = Finish;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let RecurrencePattern = tape[ptr++];
    let Start = tape[ptr++];
    let Finish = tape[ptr++];
    return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.RecurrencePattern);
    ;
    args.push(this.Start);
    ;
    args.push(this.Finish);
    ;
    return args;
  }
};
var IfcZShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    return args;
  }
};
var IfcZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
};

// dist/web-ifc-api.ts
var WebIFCWasm = require_web_ifc();
function ms() {
  return new Date().getTime();
}
var IfcAPI = class {
  constructor() {
    this.wasmModule = void 0;
    this.fs = void 0;
  }
  async Init() {
    if (WebIFCWasm) {
      this.wasmModule = await WebIFCWasm({noInitialRun: true});
      this.fs = this.wasmModule.FS;
    } else {
      console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
    }
  }
  OpenModel(data, settings) {
    this.wasmModule["FS_createDataFile"]("/", "filename", data, true, true, true);
    let s = {
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      ...settings
    };
    let result = this.wasmModule.OpenModel(s);
    this.wasmModule["FS_unlink"]("/filename");
    return result;
  }
  ExportFileAsIFC(modelID) {
    this.wasmModule.ExportFileAsIFC(modelID);
    let result = this.fs.readFile("/export.ifc");
    this.wasmModule["FS_unlink"]("/export.ifc");
    return result;
  }
  GetGeometry(modelID, geometryExpressID) {
    return this.wasmModule.GetGeometry(modelID, geometryExpressID);
  }
  GetLine(modelID, expressID, flatten2 = false) {
    let rawLineData = this.GetRawLineData(modelID, expressID);
    let lineData = FromRawLineData[rawLineData.type](rawLineData);
    if (flatten2) {
      this.FlattenLine(modelID, lineData);
    }
    return lineData;
  }
  WriteLine(modelID, lineObject) {
    Object.keys(lineObject).forEach((propertyName) => {
      let property = lineObject[propertyName];
      if (property && property.expressID !== void 0) {
        this.WriteLine(modelID, property);
        lineObject[propertyName] = {
          type: 5,
          value: property.expressID
        };
      } else if (Array.isArray(property) && property.length > 0) {
        for (let i = 0; i < property.length; i++) {
          if (property[i].expressID !== void 0) {
            this.WriteLine(modelID, property[i]);
            lineObject[propertyName][i] = {
              type: 5,
              value: property[i].expressID
            };
          }
        }
      }
    });
    let rawLineData = {
      ID: lineObject.expressID,
      type: lineObject.type,
      arguments: lineObject.ToTape()
    };
    this.WriteRawLineData(modelID, rawLineData);
  }
  FlattenLine(modelID, line) {
    Object.keys(line).forEach((propertyName) => {
      let property = line[propertyName];
      if (property && property.type === 5) {
        line[propertyName] = this.GetLine(modelID, property.value, true);
      } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
        for (let i = 0; i < property.length; i++) {
          line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
        }
      }
    });
  }
  GetRawLineData(modelID, expressID) {
    return this.wasmModule.GetLine(modelID, expressID);
  }
  WriteRawLineData(modelID, data) {
    return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
  }
  GetLineIDsWithType(modelID, type) {
    return this.wasmModule.GetLineIDsWithType(modelID, type);
  }
  GetAllLines(modelID) {
    return this.wasmModule.GetAllLines(modelID);
  }
  SetGeometryTransformation(modelID, transformationMatrix) {
    if (transformationMatrix.length != 16) {
      console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
      return;
    }
    this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
  }
  GetVertexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
  }
  GetIndexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
  }
  getSubArray(heap, startPtr, sizeBytes) {
    return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
  }
  CloseModel(modelID) {
    this.wasmModule.CloseModel(modelID);
  }
  IsModelOpen(modelID) {
    return this.wasmModule.IsModelOpen(modelID);
  }
  LoadAllGeometry(modelID) {
    return this.wasmModule.LoadAllGeometry(modelID);
  }
  GetFlatMesh(modelID, expressID) {
    return this.wasmModule.GetFlatMesh(modelID, expressID);
  }
  SetWasmPath(path) {
    WasmPath = path;
  }
};

// examples/viewer/web-ifc-three.ts
var THREE = __toModule(require_three());
var IfcThree = class {
  constructor(ifcAPI2) {
    this.ifcAPI = ifcAPI2;
  }
  LoadAllGeometry(scene2, modelID) {
    const flatMeshes = this.getFlatMeshes(modelID);
    const startUploadingTime = ms();
    for (let i = 0; i < flatMeshes.size(); i++) {
      const placedGeometries = flatMeshes.get(i).geometries;
      for (let j = 0; j < placedGeometries.size(); j++)
        scene2.add(this.getPlacedGeometry(modelID, placedGeometries.get(j)));
    }
    console.log(`Uploading took ${ms() - startUploadingTime} ms`);
  }
  getFlatMeshes(modelID) {
    const startGeomTime = ms();
    const flatMeshes = this.ifcAPI.LoadAllGeometry(modelID);
    const endGeomTime = ms();
    console.log(`Loaded ${flatMeshes.size()} flatMeshes`);
    console.log(`Loading geometry took ${endGeomTime - startGeomTime} ms`);
    return flatMeshes;
  }
  getPlacedGeometry(modelID, placedGeometry) {
    const geometry = this.getBufferGeometry(modelID, placedGeometry);
    const material = this.getMeshMaterial(placedGeometry.color);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.matrix = this.getMeshMatrix(placedGeometry.flatTransformation);
    mesh.matrixAutoUpdate = false;
    return mesh;
  }
  getBufferGeometry(modelID, placedGeometry) {
    const geometry = this.ifcAPI.GetGeometry(modelID, placedGeometry.geometryExpressID);
    const verts = this.ifcAPI.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());
    const indices = this.ifcAPI.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());
    const bufferGeometry = this.ifcGeometryToBuffer(verts, indices);
    return bufferGeometry;
  }
  getMeshMaterial(color) {
    const col = new THREE.Color(color.x, color.y, color.z);
    const material = new THREE.MeshPhongMaterial({color: col, side: THREE.DoubleSide});
    material.transparent = color.w !== 1;
    if (material.transparent)
      material.opacity = color.w;
    return material;
  }
  getMeshMatrix(matrix) {
    const mat = new THREE.Matrix4();
    mat.fromArray(matrix);
    return mat;
  }
  ifcGeometryToBuffer(vertexData, indexData) {
    const geometry = new THREE.BufferGeometry();
    const buffer32 = new THREE.InterleavedBuffer(vertexData, 6);
    geometry.setAttribute("position", new THREE.InterleavedBufferAttribute(buffer32, 3, 0));
    geometry.setAttribute("normal", new THREE.InterleavedBufferAttribute(buffer32, 3, 3));
    geometry.setIndex(new THREE.BufferAttribute(indexData, 1));
    return geometry;
  }
};

// node_modules/three/build/three.module.js
var REVISION = "126";
var MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2};
var TOUCH = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3};
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide2 = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
var _seed = 1234567;
var MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n, m) {
    return (n % m + m) % m;
  },
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  lerp: function(x, y, t) {
    return (1 - t) * x + t * y;
  },
  damp: function(x, y, lambda, dt) {
    return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
  },
  pingpong: function(x, length = 1) {
    return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
  },
  smoothstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s) {
    if (s !== void 0)
      _seed = s % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q, a, b, c, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch (order) {
      case "XYX":
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case "YZY":
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case "ZXZ":
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case "XZX":
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case "YXY":
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case "ZYZ":
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
};
var Vector2 = class {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
var _canvas;
var ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i = 0, l = image.length; i < l; i++) {
            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options) {
    super(width, height, options);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerp(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    const EPS = 1e-6;
    let r = vFrom.dot(vTo) + 1;
    if (r < EPS) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera2) {
    return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
  }
  unproject(camera2) {
    return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
};
Vector3.prototype.isVector3 = true;
var _vector = /* @__PURE__ */ new Vector3();
var _quaternion = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box.copy(geometry.boundingBox);
      _box.applyMatrix4(object.matrixWorld);
      this.union(_box);
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$1);
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0.subVectors(triangle.a, _center);
    _v1.subVectors(triangle.b, _center);
    _v2.subVectors(triangle.c, _center);
    _f0.subVectors(_v1, _v0);
    _f1.subVectors(_v2, _v1);
    _f2.subVectors(_v0, _v2);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$1 = /* @__PURE__ */ new Vector3();
var _box = /* @__PURE__ */ new Box3();
var _v0 = /* @__PURE__ */ new Vector3();
var _v1 = /* @__PURE__ */ new Vector3();
var _v2 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
var _box$1 = /* @__PURE__ */ new Box3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$2 = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$2));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$2.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);
    const tca = _vector$2.dot(this.direction);
    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$2) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix42 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix42().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$1.set(te[0], te[1], te[2]).length();
    const sy = _v1$1.set(te[4], te[5], te[6]).length();
    const sz = _v1$1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
};
Matrix42.prototype.isMatrix4 = true;
var _v1$1 = /* @__PURE__ */ new Vector3();
var _m1 = /* @__PURE__ */ new Matrix42();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix42();
var _quaternion$1 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order, update) {
    const clamp = MathUtils.clamp;
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }
  reorder(newOrder) {
    _quaternion$1.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$1, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
var _object3DId = 0;
var _v1$2 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix42();
var _target = new Vector3();
var _position = new Vector3();
var _scale = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = {type: "added"};
var _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix42()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix42();
  this.matrixWorld = new Matrix42();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m) {
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name2) {
    return this.getObjectByProperty("name", name2);
  },
  getObjectByProperty: function(name2, value) {
    if (this[name2] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name2, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target = new Vector3();
    }
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return void 0;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return void 0;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$1 = /* @__PURE__ */ new Vector3();
var _v3 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target = new Vector3();
    }
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$1.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$1);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$1);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target = new Vector3();
    }
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      data.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data.size = this.size;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data.morphTargets = true;
    if (this.morphNormals === true)
      data.morphNormals = true;
    if (this.skinning === true)
      data.skinning = true;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var _hslA = {h: 0, s: 0, l: 0};
var _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var Color3 = class {
  constructor(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  setHSL(h, s, l) {
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    l = MathUtils.clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name2 = m[1];
      const components = m[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = {h: 0, s: 0, l: 0};
    }
    const r = this.r, g = this.g, b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color3.NAMES = _colorKeywords;
Color3.prototype.isColor = true;
Color3.prototype.r = 1;
Color3.prototype.g = 1;
Color3.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color3(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$3 = new Vector3();
var _vector2$1 = new Vector2();
function BufferAttribute2(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
Object.defineProperty(BufferAttribute2.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute2.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color = new Color3();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.fromBufferAttribute(this, i);
        _vector$3.applyMatrix3(m);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyMatrix4(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  applyNormalMatrix: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyNormalMatrix(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  transformDirection: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.transformDirection(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute2.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute2.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max)
      max = array[i];
  }
  return max;
}
var _id = 0;
var _m1$2 = new Matrix42();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();
function BufferGeometry2() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
BufferGeometry2.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry2,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  },
  getAttribute: function(name2) {
    return this.attributes[name2];
  },
  setAttribute: function(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  },
  deleteAttribute: function(name2) {
    delete this.attributes[name2];
    return this;
  },
  hasAttribute: function(name2) {
    return this.attributes[name2] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function(x, y, z) {
    _m1$2.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function(x, y, z) {
    _m1$2.makeScale(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$4);
            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$4);
            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$4.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute2(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp2.x;
      tangents[v * 4 + 1] = tmp2.y;
      tangents[v * 4 + 2] = tmp2.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute2(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$4.fromBufferAttribute(normals, i);
      _vector$4.normalize();
      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        index = indices2[i] * itemSize;
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute2(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry2();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = {attributes: {}};
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data.data);
      if (attribute.name !== "")
        attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry2().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name2] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var _inverseMatrix = new Matrix42();
var _ray = new Ray();
var _sphere = new Sphere();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
function Mesh2(geometry = new BufferGeometry2(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh2.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh2,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name2 = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide2, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);
        _morphB.addScaledVector(_tempB.sub(_vB), influence);
        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }
    _vA.add(_morphA);
    _vB.add(_morphB);
    _vC.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);
      _uvB.fromBufferAttribute(uv2, b);
      _uvC.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    const face = {
      a,
      b: a,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry2 {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
var UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};
  for (const name2 in this.uniforms) {
    const uniform = this.uniforms[name2];
    const value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name2] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name2] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name2] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name2] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name2] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name2] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name2] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name2] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data.extensions = extensions;
  return data;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix42();
  this.projectionMatrix = new Matrix42();
  this.projectionMatrixInverse = new Matrix42();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer2, scene2) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer2.xr.enabled;
    const currentRenderTarget = renderer2.getRenderTarget();
    renderer2.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer2.setRenderTarget(renderTarget, 0);
    renderer2.render(scene2, cameraPX);
    renderer2.setRenderTarget(renderTarget, 1);
    renderer2.render(scene2, cameraNX);
    renderer2.setRenderTarget(renderTarget, 2);
    renderer2.render(scene2, cameraPY);
    renderer2.setRenderTarget(renderTarget, 3);
    renderer2.render(scene2, cameraNY);
    renderer2.setRenderTarget(renderTarget, 4);
    renderer2.render(scene2, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer2.setRenderTarget(renderTarget, 5);
    renderer2.render(scene2, cameraNZ);
    renderer2.setRenderTarget(currentRenderTarget);
    renderer2.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer2, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh2(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    camera2.update(renderer2, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer2, color, depth, stencil) {
    const currentRenderTarget = renderer2.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer2.setRenderTarget(this, i);
      renderer2.clear(color, depth, stencil);
    }
    renderer2.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var DataTexture = class extends Texture {
  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _sphere$1 = /* @__PURE__ */ new Sphere();
var _vector$5 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);
    _sphere$1.radius = 0.7071067811865476;
    _sphere$1.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class extends BufferGeometry2 {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
var UniformsLib = {
  common: {
    diffuse: {value: new Color3(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color3(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color3(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color3(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color3(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color3(0)},
        specular: {value: new Color3(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color3(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color3(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color3(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color3(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer2, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color3(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene2, camera2, forceClear) {
    let background = scene2.isScene === true ? scene2.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer2.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer2.autoClear || forceClear) {
      renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh2(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer3, scene3, camera3) {
          this.matrixWorld.copyPosition(camera3.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      if (background.isWebGLCubeRenderTarget) {
        background = background.texture;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh2(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name2 === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name2 === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera2) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera2, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera2, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera2, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer2) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer2.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer2, texture);
            cubemaps.set(texture, renderTarget);
            renderer2.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name2);
    }
    extensions[name2] = extension;
    return extension;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name2) {
      const extension = getExtension(name2);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name2 in geometry.attributes) {
      attributes.remove(geometry.attributes[name2]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = morphAttributes[name2];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }
    influences.sort(absNumericalSort);
    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i, morphNormals[index]);
        }
        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
          geometry.deleteAttribute("morphTarget" + i);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
          geometry.deleteAttribute("morphNormal" + i);
        }
        morphInfluences[i] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
var DataTexture3D = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name2, value, textures) {
  const u = this.map[name2];
  if (u !== void 0)
    u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name2) {
  const v = object[name2];
  if (v !== void 0)
    this.setValue(gl, name2, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values)
      r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false)
      continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name2 = info.name;
    attributes[name2] = gl.getAttribLocation(program, name2);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
  const gl = renderer2.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer2.gammaFactor > 0 ? renderer2.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer2.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer2, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene2, object) {
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer2.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer2.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer2.maxMorphTargets,
      maxMorphNormals: renderer2.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer2.shadowMap.type,
      toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer2.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide2,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array.push(name2);
        array.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(renderer2.outputEncoding);
      array.push(renderer2.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene2, renderCallDepth) {
    let list;
    if (lists.has(scene2) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene2, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene2).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene2).push(list);
      } else {
        list = lists.get(scene2)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color3()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color3(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color3(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color3(),
            groundColor: new Color3()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color3(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix42();
  const matrix42 = new Matrix42();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera2) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera2.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera2) {
    lights.setupView(lightsArray, camera2);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene2, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene2) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene2, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene2).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene2).push(renderState);
      } else {
        renderState = renderStates.get(scene2)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide2};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry2();
  fullScreenTri.setAttribute("position", new BufferAttribute2(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh2(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene2, camera2) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene2, camera2, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera2);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera2) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera2, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera2.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera2, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide2 ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === UnsignedShort565Type)
      return 33635;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBFormat)
      return 6407;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBIntegerFormat)
      return 36248;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {convert};
}
function ArrayCamera(array = []) {
  PerspectiveCamera.call(this);
  this.cameras = array;
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer2, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    renderer2.setFramebuffer(null);
    renderer2.setRenderTarget(renderer2.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    }
    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
    camera2.translateX(xOffset);
    camera2.translateZ(zOffset);
    camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
    camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera2, parent) {
    if (parent === null) {
      camera2.matrixWorld.copy(camera2.matrix);
    } else {
      camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
    }
    camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
  }
  this.getCamera = function(camera2) {
    cameraVR.near = cameraR.near = cameraL.near = camera2.near;
    cameraVR.far = cameraR.far = cameraL.far = camera2.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera2.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i = 0; i < cameras2.length; i++) {
      updateCamera(cameras2[i], parent);
    }
    camera2.matrixWorld.copy(cameraVR.matrixWorld);
    camera2.matrix.copy(cameraVR.matrix);
    camera2.matrix.decompose(camera2.position, camera2.quaternion, camera2.scale);
    const children = camera2.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer2.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera2 = cameras[i];
        camera2.matrix.fromArray(view.transform.matrix);
        camera2.projectionMatrix.fromArray(view.projectionMatrix);
        camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i === 0) {
          cameraVR.matrix.copy(camera2.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera2);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  const _this = this;
  let _isContextLost = false;
  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix42();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target = new Color3();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera2, scene2, geometry, material, object, group) {
    if (scene2 === null)
      scene2 = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera2, scene2, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer2 = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer2 = indexedBufferRenderer;
      renderer2.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer2.setMode(1);
      } else {
        renderer2.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer2.setMode(1);
      } else if (object.isLineLoop) {
        renderer2.setMode(2);
      } else {
        renderer2.setMode(3);
      }
    } else if (object.isPoints) {
      renderer2.setMode(0);
    } else if (object.isSprite) {
      renderer2.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer2.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer2.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer2.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene2, camera2) {
    currentRenderState = renderStates.get(scene2);
    currentRenderState.init();
    scene2.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera2.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    const compiled = new WeakMap();
    scene2.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene2, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene2, object);
          compiled.set(material);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (xr.isPresenting)
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  this.render = function(scene2, camera2) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera2 !== void 0 && camera2.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene2.autoUpdate === true)
      scene2.updateMatrixWorld();
    if (camera2.parent === null)
      camera2.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera2 = xr.getCamera(camera2);
    }
    if (scene2.isScene === true)
      scene2.onBeforeRender(_this, scene2, camera2, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene2, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
    currentRenderList = renderLists.get(scene2, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene2, camera2, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene2, camera2);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera2);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene2, camera2, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene2, camera2);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene2, camera2);
    if (scene2.isScene === true)
      scene2.onAfterRender(_this, scene2, camera2);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera2, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera2.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera2);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera2, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene2, camera2) {
    const overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera2.isArrayCamera) {
        const cameras = camera2.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera22 = cameras[j];
          if (object.layers.test(camera22.layers)) {
            state.viewport(_currentViewport.copy(camera22.viewport));
            currentRenderState.setupLightsView(camera22);
            renderObject(object, scene2, camera22, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene2, camera2, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene2, camera2, geometry, material, group) {
    object.onBeforeRender(_this, scene2, camera2, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera2, scene2, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera2, scene2, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene2, camera2, geometry, material, group);
  }
  function initMaterial(material, scene2, object) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let program = materialProperties.program;
    let programChange = true;
    materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
    materialProperties.fog = scene2.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters2.uniforms;
      materialProperties.outputEncoding = parameters2.outputEncoding;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera2, scene2, material, object) {
    if (scene2.isScene !== true)
      scene2 = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene2.fog;
    const environment = material.isMeshStandardMaterial ? scene2.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera2 !== _currentCamera) {
        const useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera2, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene2, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene2, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene2, object);
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene2, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene2, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene2, object);
      }
    } else {
      initMaterial(material, scene2, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera2) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera2) {
        _currentCamera = camera2;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value && _currentRenderTarget === null)
      _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density) {
    this.name = "";
    this.color = new Color3(color);
    this.density = density !== void 0 ? density : 25e-5;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near, far) {
    this.name = "";
    this.color = new Color3(color);
    this.near = near !== void 0 ? near : 1;
    this.far = far !== void 0 ? far : 1e3;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null)
      data.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
};
Scene.prototype.isScene = true;
function InterleavedBuffer2(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer2.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer2.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  clone: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer2(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
var _vector$6 = new Vector3();
function InterleavedBufferAttribute2(interleavedBuffer, itemSize, offset, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute2.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute2.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  },
  clone: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute2(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute2(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color3(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix42();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry2();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer2(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute2(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute2(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB$1.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$4 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, {distance, object});
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera2) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera2.matrixWorld);
      _v2$2.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$4.distanceTo(_v2$2) / camera2.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false)
      data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
};
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$7 = new Vector3();
var _matrix$1 = new Matrix42();
function SkinnedMesh(geometry, material) {
  Mesh2.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix42();
  this.bindMatrixInverse = new Matrix42();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh2.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh2.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh2.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
var _offsetMatrix = /* @__PURE__ */ new Matrix42();
var _identityMatrix = /* @__PURE__ */ new Matrix42();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix42());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix42();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name2) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name2) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix42().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
var _instanceLocalMatrix = new Matrix42();
var _instanceWorldMatrix = new Matrix42();
var _instanceIntersects = [];
var _mesh = new Mesh2();
function InstancedMesh(geometry, material, count) {
  Mesh2.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute2(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh2.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh2.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute2(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  },
  setMatrixAt: function(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color3(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix42();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry2(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);
          _end.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i = 0, l = indices.length - 1; i < l; i += step) {
          const a = indices[i];
          const b = indices[i + 1];
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i = 0, l = positionAttribute.count - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name2 = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
var _start$1 = new Vector3();
var _end$1 = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);
          _end$1.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color3(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix$2 = new Matrix42();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();
function Points(geometry = new BufferGeometry2(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i = 0, il = indices.length; i < il; i++) {
          const a = indices[i];
          _position$1.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          _position$1.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name2 = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$2.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {width, height};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var _v0$2 = new Vector3();
var _v1$5 = new Vector3();
var _normal$1 = new Vector3();
var _triangle = new Triangle();
var Earcut = {
  triangulate: function(data, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
var ShapeUtils = {
  area: function(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
var ExtrudeGeometry = class extends BufferGeometry2 {
  constructor(shapes, options) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      let depth = options.depth !== void 0 ? options.depth : 100;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0)
            k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = BufferGeometry2.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry2.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;
    for (let j = 0; j <= slices; j++) {
      const u = j / slices;
      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, v);
    }
  }
  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d = (i + 1) * sliceCount + j;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry2.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
var ShapeGeometry = class extends BufferGeometry2 {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = BufferGeometry2.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  }
};
function toJSON$1(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color3(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color3(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color3(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color3()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
var MeshPhongMaterial2 = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color3(16777215);
    this.specular = new Color3(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color3(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial2.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {TOON: ""};
    this.type = "MeshToonMaterial";
    this.color = new Color3(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color3(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color3(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color3(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {MATCAP: ""};
    this.type = "MeshMatcapMaterial";
    this.color = new Color3(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = {MATCAP: ""};
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name2, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name2;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
var KeyframeTrack = class {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name2) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
var DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
var loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = {mipmaps: []};
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
};
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  getTangent: function(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix42();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color3(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color3(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix42();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera2) {
    this.camera = camera2;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix42();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld);
    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera2 = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera2.far;
    if (fov2 !== camera2.fov || aspect2 !== camera2.aspect || far !== camera2.far) {
      camera2.fov = fov2;
      camera2.aspect = aspect2;
      camera2.far = far;
      camera2.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix42();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera2 = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    camera2.position.copy(_lightPositionWorld$1);
    _lookTarget$1.copy(camera2.position);
    _lookTarget$1.add(this._cubeDirections[viewportIndex]);
    camera2.up.copy(this._cubeUps[viewportIndex]);
    camera2.lookAt(_lookTarget$1);
    camera2.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z);
    _projScreenMatrix$1.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
LightProbe.prototype.isLightProbe = true;
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  },
  extractUrlBase: function(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry2.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry2.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry2.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data = BufferGeometry2.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute2.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute2.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute2.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data = BufferAttribute2.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color3();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  }
  lineTo(x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
};
var Font = class {
  constructor(data) {
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {offsetX: glyph.ha * scale, path};
}
Font.prototype.isFont = true;
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color3().set(skyColor);
    const color2 = new Color3().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color3().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var _eyeRight = new Matrix42();
var _eyeLeft = new Matrix42();
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  },
  setValue: function(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    },
    function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0)
      return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer2.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer2.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer2.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data) {
    const ib = InterleavedBuffer2.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data) {
    const json = InterleavedBuffer2.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera2) {
    if (camera2 && camera2.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera2.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera2).sub(this.ray.origin).normalize();
      this.camera = camera2;
    } else if (camera2 && camera2.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera2.near + camera2.far) / (camera2.near - camera2.far)).unproject(camera2);
      this.ray.direction.set(0, 0, -1).transformDirection(camera2.matrixWorld);
      this.camera = camera2;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera2.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive = false, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$8 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target = new Vector2();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = MathUtils.clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    if (target === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$a = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix42();
var _matrixWorldInv = /* @__PURE__ */ new Matrix42();
var SkeletonHelper = class extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry2();
    const vertices = [];
    const colors = [];
    const color1 = new Color3(0, 0, 1);
    const color2 = new Color3(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color3(color1);
    color2 = new Color3(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry2();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "GridHelper";
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
var backgroundBox = new Mesh2(new BoxGeometry(), backgroundMaterial);
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix42.prototype.extractPosition = function(m) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m);
};
Matrix42.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix42.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix42.prototype.setRotationFromQuaternion = function(q) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q);
};
Matrix42.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix42.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix42.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix42.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix42.prototype.rotateAxis = function(v) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v.transformDirection(this);
};
Matrix42.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix42.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix42.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix42.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix42.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix42.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix42.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix42.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix42.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix42.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a, b, c, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a, b, c, target);
};
Triangle.normal = function(a, b, c, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a, b, c, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m);
};
Vector3.prototype.getScaleFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name2) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name2);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh2.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh2.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute2.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute2.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute2.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute2.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry2.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry2.prototype.addAttribute = function(name2, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name2, new BufferAttribute2(arguments[1], arguments[2]));
  }
  if (name2 === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name2, attribute);
};
BufferGeometry2.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry2.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry2.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry2.prototype.removeAttribute = function(name2) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name2);
};
BufferGeometry2.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry2.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer2.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer2.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer2.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color3();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial2.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(Audio.prototype, {
  load: {
    value: function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer2, scene2) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer2, scene2);
};
CubeCamera.prototype.clear = function(renderer2, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer2, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/three/examples/jsm/controls/OrbitControls.js
var OrbitControls = function(object, domElement) {
  if (domElement === void 0)
    console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
  if (domElement === document)
    console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
  this.object = object;
  this.domElement = domElement;
  this.enabled = true;
  this.target = new Vector3();
  this.minDistance = 0;
  this.maxDistance = Infinity;
  this.minZoom = 0;
  this.maxZoom = Infinity;
  this.minPolarAngle = 0;
  this.maxPolarAngle = Math.PI;
  this.minAzimuthAngle = -Infinity;
  this.maxAzimuthAngle = Infinity;
  this.enableDamping = false;
  this.dampingFactor = 0.05;
  this.enableZoom = true;
  this.zoomSpeed = 1;
  this.enableRotate = true;
  this.rotateSpeed = 1;
  this.enablePan = true;
  this.panSpeed = 1;
  this.screenSpacePanning = true;
  this.keyPanSpeed = 7;
  this.autoRotate = false;
  this.autoRotateSpeed = 2;
  this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};
  this.mouseButtons = {LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN};
  this.touches = {ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN};
  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom;
  this._domElementKeyEvents = null;
  this.getPolarAngle = function() {
    return spherical.phi;
  };
  this.getAzimuthalAngle = function() {
    return spherical.theta;
  };
  this.listenToKeyEvents = function(domElement2) {
    domElement2.addEventListener("keydown", onKeyDown);
    this._domElementKeyEvents = domElement2;
  };
  this.saveState = function() {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };
  this.reset = function() {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  };
  this.update = function() {
    var offset = new Vector3();
    var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    var quatInverse = quat.clone().invert();
    var lastPosition = new Vector3();
    var lastQuaternion = new Quaternion();
    var twoPI = 2 * Math.PI;
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target);
      offset.applyQuaternion(quat);
      spherical.setFromVector3(offset);
      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }
      if (scope.enableDamping) {
        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
      } else {
        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;
      }
      var min = scope.minAzimuthAngle;
      var max = scope.maxAzimuthAngle;
      if (isFinite(min) && isFinite(max)) {
        if (min < -Math.PI)
          min += twoPI;
        else if (min > Math.PI)
          min -= twoPI;
        if (max < -Math.PI)
          max += twoPI;
        else if (max > Math.PI)
          max -= twoPI;
        if (min <= max) {
          spherical.theta = Math.max(min, Math.min(max, spherical.theta));
        } else {
          spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
        }
      }
      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale;
      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
      if (scope.enableDamping === true) {
        scope.target.addScaledVector(panOffset, scope.dampingFactor);
      } else {
        scope.target.add(panOffset);
      }
      offset.setFromSpherical(spherical);
      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);
      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }
      scale = 1;
      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }
      return false;
    };
  }();
  this.dispose = function() {
    scope.domElement.removeEventListener("contextmenu", onContextMenu);
    scope.domElement.removeEventListener("pointerdown", onPointerDown);
    scope.domElement.removeEventListener("wheel", onMouseWheel);
    scope.domElement.removeEventListener("touchstart", onTouchStart);
    scope.domElement.removeEventListener("touchend", onTouchEnd);
    scope.domElement.removeEventListener("touchmove", onTouchMove);
    scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
    scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
    if (scope._domElementKeyEvents !== null) {
      scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
    }
  };
  var scope = this;
  var changeEvent = {type: "change"};
  var startEvent = {type: "start"};
  var endEvent = {type: "end"};
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  };
  var state = STATE.NONE;
  var EPS = 1e-6;
  var spherical = new Spherical();
  var sphericalDelta = new Spherical();
  var scale = 1;
  var panOffset = new Vector3();
  var zoomChanged = false;
  var rotateStart = new Vector2();
  var rotateEnd = new Vector2();
  var rotateDelta = new Vector2();
  var panStart = new Vector2();
  var panEnd = new Vector2();
  var panDelta = new Vector2();
  var dollyStart = new Vector2();
  var dollyEnd = new Vector2();
  var dollyDelta = new Vector2();
  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }
  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }
  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }
  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }
  var panLeft = function() {
    var v = new Vector3();
    return function panLeft2(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0);
      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();
  var panUp = function() {
    var v = new Vector3();
    return function panUp2(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }
      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }();
  var pan = function() {
    var offset = new Vector3();
    return function pan2(deltaX, deltaY) {
      var element = scope.domElement;
      if (scope.object.isPerspectiveCamera) {
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length();
        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
        scope.enablePan = false;
      }
    };
  }();
  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      scope.enableZoom = false;
    }
  }
  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      scope.enableZoom = false;
    }
  }
  function handleMouseDownRotate(event) {
    rotateStart.set(event.clientX, event.clientY);
  }
  function handleMouseDownDolly(event) {
    dollyStart.set(event.clientX, event.clientY);
  }
  function handleMouseDownPan(event) {
    panStart.set(event.clientX, event.clientY);
  }
  function handleMouseMoveRotate(event) {
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }
  function handleMouseMoveDolly(event) {
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);
    if (dollyDelta.y > 0) {
      dollyOut(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyIn(getZoomScale());
    }
    dollyStart.copy(dollyEnd);
    scope.update();
  }
  function handleMouseMovePan(event) {
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }
  function handleMouseUp() {
  }
  function handleMouseWheel(event) {
    if (event.deltaY < 0) {
      dollyIn(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyOut(getZoomScale());
    }
    scope.update();
  }
  function handleKeyDown(event) {
    var needsUpdate = false;
    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        needsUpdate = true;
        break;
      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        needsUpdate = true;
        break;
      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      scope.update();
    }
  }
  function handleTouchStartRotate(event) {
    if (event.touches.length == 1) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateStart.set(x, y);
    }
  }
  function handleTouchStartPan(event) {
    if (event.touches.length == 1) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }
  function handleTouchStartDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyStart.set(0, distance);
  }
  function handleTouchStartDollyPan(event) {
    if (scope.enableZoom)
      handleTouchStartDolly(event);
    if (scope.enablePan)
      handleTouchStartPan(event);
  }
  function handleTouchStartDollyRotate(event) {
    if (scope.enableZoom)
      handleTouchStartDolly(event);
    if (scope.enableRotate)
      handleTouchStartRotate(event);
  }
  function handleTouchMoveRotate(event) {
    if (event.touches.length == 1) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateEnd.set(x, y);
    }
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
  }
  function handleTouchMovePan(event) {
    if (event.touches.length == 1) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
    }
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
  }
  function handleTouchMoveDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyEnd.set(0, distance);
    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
    dollyOut(dollyDelta.y);
    dollyStart.copy(dollyEnd);
  }
  function handleTouchMoveDollyPan(event) {
    if (scope.enableZoom)
      handleTouchMoveDolly(event);
    if (scope.enablePan)
      handleTouchMovePan(event);
  }
  function handleTouchMoveDollyRotate(event) {
    if (scope.enableZoom)
      handleTouchMoveDolly(event);
    if (scope.enableRotate)
      handleTouchMoveRotate(event);
  }
  function handleTouchEnd() {
  }
  function onPointerDown(event) {
    if (scope.enabled === false)
      return;
    switch (event.pointerType) {
      case "mouse":
      case "pen":
        onMouseDown(event);
        break;
    }
  }
  function onPointerMove(event) {
    if (scope.enabled === false)
      return;
    switch (event.pointerType) {
      case "mouse":
      case "pen":
        onMouseMove(event);
        break;
    }
  }
  function onPointerUp(event) {
    switch (event.pointerType) {
      case "mouse":
      case "pen":
        onMouseUp(event);
        break;
    }
  }
  function onMouseDown(event) {
    event.preventDefault();
    scope.domElement.focus ? scope.domElement.focus() : window.focus();
    var mouseAction;
    switch (event.button) {
      case 0:
        mouseAction = scope.mouseButtons.LEFT;
        break;
      case 1:
        mouseAction = scope.mouseButtons.MIDDLE;
        break;
      case 2:
        mouseAction = scope.mouseButtons.RIGHT;
        break;
      default:
        mouseAction = -1;
    }
    switch (mouseAction) {
      case MOUSE.DOLLY:
        if (scope.enableZoom === false)
          return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;
      case MOUSE.ROTATE:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enablePan === false)
            return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        } else {
          if (scope.enableRotate === false)
            return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        }
        break;
      case MOUSE.PAN:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enableRotate === false)
            return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        } else {
          if (scope.enablePan === false)
            return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        }
        break;
      default:
        state = STATE.NONE;
    }
    if (state !== STATE.NONE) {
      scope.domElement.ownerDocument.addEventListener("pointermove", onPointerMove);
      scope.domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      scope.dispatchEvent(startEvent);
    }
  }
  function onMouseMove(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false)
          return;
        handleMouseMoveRotate(event);
        break;
      case STATE.DOLLY:
        if (scope.enableZoom === false)
          return;
        handleMouseMoveDolly(event);
        break;
      case STATE.PAN:
        if (scope.enablePan === false)
          return;
        handleMouseMovePan(event);
        break;
    }
  }
  function onMouseUp(event) {
    scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
    scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
    if (scope.enabled === false)
      return;
    handleMouseUp(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
      return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }
  function onKeyDown(event) {
    if (scope.enabled === false || scope.enablePan === false)
      return;
    handleKeyDown(event);
  }
  function onTouchStart(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
    switch (event.touches.length) {
      case 1:
        switch (scope.touches.ONE) {
          case TOUCH.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchStartRotate(event);
            state = STATE.TOUCH_ROTATE;
            break;
          case TOUCH.PAN:
            if (scope.enablePan === false)
              return;
            handleTouchStartPan(event);
            state = STATE.TOUCH_PAN;
            break;
          default:
            state = STATE.NONE;
        }
        break;
      case 2:
        switch (scope.touches.TWO) {
          case TOUCH.DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchStartDollyPan(event);
            state = STATE.TOUCH_DOLLY_PAN;
            break;
          case TOUCH.DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchStartDollyRotate(event);
            state = STATE.TOUCH_DOLLY_ROTATE;
            break;
          default:
            state = STATE.NONE;
        }
        break;
      default:
        state = STATE.NONE;
    }
    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }
  function onTouchMove(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
    event.stopPropagation();
    switch (state) {
      case STATE.TOUCH_ROTATE:
        if (scope.enableRotate === false)
          return;
        handleTouchMoveRotate(event);
        scope.update();
        break;
      case STATE.TOUCH_PAN:
        if (scope.enablePan === false)
          return;
        handleTouchMovePan(event);
        scope.update();
        break;
      case STATE.TOUCH_DOLLY_PAN:
        if (scope.enableZoom === false && scope.enablePan === false)
          return;
        handleTouchMoveDollyPan(event);
        scope.update();
        break;
      case STATE.TOUCH_DOLLY_ROTATE:
        if (scope.enableZoom === false && scope.enableRotate === false)
          return;
        handleTouchMoveDollyRotate(event);
        scope.update();
        break;
      default:
        state = STATE.NONE;
    }
  }
  function onTouchEnd(event) {
    if (scope.enabled === false)
      return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  function onContextMenu(event) {
    if (scope.enabled === false)
      return;
    event.preventDefault();
  }
  scope.domElement.addEventListener("contextmenu", onContextMenu);
  scope.domElement.addEventListener("pointerdown", onPointerDown);
  scope.domElement.addEventListener("wheel", onMouseWheel);
  scope.domElement.addEventListener("touchstart", onTouchStart);
  scope.domElement.addEventListener("touchend", onTouchEnd);
  scope.domElement.addEventListener("touchmove", onTouchMove);
  this.update();
};
OrbitControls.prototype = Object.create(EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls;
var MapControls = function(object, domElement) {
  OrbitControls.call(this, object, domElement);
  this.screenSpacePanning = false;
  this.mouseButtons.LEFT = MOUSE.PAN;
  this.mouseButtons.RIGHT = MOUSE.ROTATE;
  this.touches.ONE = TOUCH.PAN;
  this.touches.TWO = TOUCH.DOLLY_ROTATE;
};
MapControls.prototype = Object.create(EventDispatcher.prototype);
MapControls.prototype.constructor = MapControls;

// examples/viewer/web-ifc-scene.ts
var THREE2 = __toModule(require_three());
var scene = new THREE2.Scene();
var camera = new THREE2.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1e3);
var renderer = new THREE2.WebGLRenderer({antialias: true});
var controls;
function Init3DView() {
  renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.9);
  document.body.appendChild(renderer.domElement);
  controls = new OrbitControls(camera, renderer.domElement);
  const directionalLight1 = new THREE2.DirectionalLight(16772863, 0.8);
  directionalLight1.position.set(1, 1, 1);
  scene.add(directionalLight1);
  const directionalLight2 = new THREE2.DirectionalLight(16777215, 0.8);
  directionalLight2.position.set(-1, 0.5, -1);
  scene.add(directionalLight2);
  const ambientLight = new THREE2.AmbientLight(16777198, 0.25);
  scene.add(ambientLight);
  scene.background = new THREE2.Color(9226206);
  camera.position.z = 5;
  AnimationLoop();
}
function AnimationLoop() {
  requestAnimationFrame(AnimationLoop);
  controls.update();
  renderer.render(scene, camera);
}

// examples/viewer/web-ifc-viewer.ts
var ifcAPI = new IfcAPI();
var ifcThree = new IfcThree(ifcAPI);
window.InitWebIfcViewer = async () => {
  await ifcAPI.Init();
  const fileInput = document.getElementById("finput");
  fileInput.addEventListener("change", fileInputChanged);
  Init3DView();
};
async function fileInputChanged() {
  let fileInput = document.getElementById("finput");
  if (fileInput.files.length == 0)
    return console.log("No files selected!");
  const file = fileInput.files[0];
  const reader = getFileReader(fileInput);
  reader.readAsArrayBuffer(file);
}
function getFileReader(fileInput) {
  var reader = new FileReader();
  reader.onload = () => {
    const data = getData(reader);
    LoadModel(data);
    fileInput.value = "";
  };
  return reader;
}
function getData(reader) {
  const startRead = ms();
  const data = new Uint8Array(reader.result);
  const readTime = ms() - startRead;
  console.log(`Reading took ${readTime} ms`);
  return data;
}
function LoadModel(data) {
  const start = ms();
  const modelID = ifcAPI.OpenModel(data, {COORDINATE_TO_ORIGIN: true, USE_FAST_BOOLS: true});
  const time = ms() - start;
  console.log(`Opening model took ${time} ms`);
  ifcThree.LoadAllGeometry(scene, modelID);
}
